/*----- PROTECTED REGION ID(ApogeeCamera.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        ApogeeCamera.cpp
//
// description : C++ source for the ApogeeCamera class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               ApogeeCamera are implemented in this file.
//
// project :     Apogee CCD Camera
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <ApogeeCamera.h>
#include <ApogeeCameraClass.h>

/*----- PROTECTED REGION END -----*/	//	ApogeeCamera.cpp

/**
 *  ApogeeCamera class description:
 *
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name      |  Method name
//================================================================
//  State             |  Inherited (no method)
//  Status            |  Inherited (no method)
//  StartAcquisition  |  start_acquisition
//  StopAcquisition   |  stop_acquisition
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  ADC_Gain            |  Tango::DevUShort	Scalar
//  ADC_Offset          |  Tango::DevUShort	Scalar
//  CoolingDrive        |  Tango::DevDouble	Scalar
//  CoolingEnable       |  Tango::DevBoolean	Scalar
//  CoolingSetpoint     |  Tango::DevDouble	Scalar
//  CoolingStatus       |  Tango::DevState	Scalar
//  CoolingTemperature  |  Tango::DevDouble	Scalar
//  EnableFastReadout   |  Tango::DevBoolean	Scalar
//  IntegrationTime     |  Tango::DevDouble	Scalar
//  ROI_HBin            |  Tango::DevUShort	Scalar
//  ROI_HSize           |  Tango::DevUShort	Scalar
//  ROI_HStart          |  Tango::DevUShort	Scalar
//  ROI_VBin            |  Tango::DevUShort	Scalar
//  ROI_VSize           |  Tango::DevUShort	Scalar
//  ROI_VStart          |  Tango::DevUShort	Scalar
//  Image               |  Tango::DevUShort	Image  ( max = 4096 x 4096)
//================================================================

namespace ApogeeCamera_ns
{
/*----- PROTECTED REGION ID(ApogeeCamera::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::ApogeeCamera()
 *	Description : Constructors for a Tango device
 *                implementing the classApogeeCamera
 */
//--------------------------------------------------------
ApogeeCamera::ApogeeCamera(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(ApogeeCamera::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::constructor_1
}
//--------------------------------------------------------
ApogeeCamera::ApogeeCamera(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(ApogeeCamera::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::constructor_2
}
//--------------------------------------------------------
ApogeeCamera::ApogeeCamera(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(ApogeeCamera::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void ApogeeCamera::delete_device()
{
	DEBUG_STREAM << "ApogeeCamera::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if(dev) {
		dev->terminate();
		int *retval;
		dev->join((void**)&retval);
		delete retval;
	}

	delete[] attr_Image_read;

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::delete_device
	delete[] attr_ADC_Gain_read;
	delete[] attr_ADC_Offset_read;
	delete[] attr_CoolingDrive_read;
	delete[] attr_CoolingEnable_read;
	delete[] attr_CoolingSetpoint_read;
	delete[] attr_CoolingStatus_read;
	delete[] attr_CoolingTemperature_read;
	delete[] attr_EnableFastReadout_read;
	delete[] attr_IntegrationTime_read;
	delete[] attr_ROI_HBin_read;
	delete[] attr_ROI_HSize_read;
	delete[] attr_ROI_HStart_read;
	delete[] attr_ROI_VBin_read;
	delete[] attr_ROI_VSize_read;
	delete[] attr_ROI_VStart_read;
}

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void ApogeeCamera::init_device()
{
	DEBUG_STREAM << "ApogeeCamera::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	set_state(Tango::INIT);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::init_device_before


	//	Get the device properties from database
	get_device_property();

	attr_ADC_Gain_read = new Tango::DevUShort[1];
	attr_ADC_Offset_read = new Tango::DevUShort[1];
	attr_CoolingDrive_read = new Tango::DevDouble[1];
	attr_CoolingEnable_read = new Tango::DevBoolean[1];
	attr_CoolingSetpoint_read = new Tango::DevDouble[1];
	attr_CoolingStatus_read = new Tango::DevState[1];
	attr_CoolingTemperature_read = new Tango::DevDouble[1];
	attr_EnableFastReadout_read = new Tango::DevBoolean[1];
	attr_IntegrationTime_read = new Tango::DevDouble[1];
	attr_ROI_HBin_read = new Tango::DevUShort[1];
	attr_ROI_HSize_read = new Tango::DevUShort[1];
	attr_ROI_HStart_read = new Tango::DevUShort[1];
	attr_ROI_VBin_read = new Tango::DevUShort[1];
	attr_ROI_VSize_read = new Tango::DevUShort[1];
	attr_ROI_VStart_read = new Tango::DevUShort[1];
	/*----- PROTECTED REGION ID(ApogeeCamera::init_device) ENABLED START -----*/

	attr_Image_read = new Tango::DevUShort[4096*4096];
	img_x = 0;
	img_y = 0;

	// Create device monitoring thread
	try {
		dev = new ApogeeMon(this);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to initialize camera",
					e.what(),
					(const char*)"ApogeeCam::init_device()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::init_device
}

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void ApogeeCamera::get_device_property()
{
	/*----- PROTECTED REGION ID(ApogeeCamera::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Polling"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on ApogeeCameraClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		ApogeeCameraClass	*ds_class =
			(static_cast<ApogeeCameraClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Polling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  polling;
		else {
			//	Try to initialize Polling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  polling;
		}
		//	And try to extract Polling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  polling;

	}

	/*----- PROTECTED REGION ID(ApogeeCamera::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void ApogeeCamera::always_executed_hook()
{
// 	DEBUG_STREAM << "ApogeeCamera::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void ApogeeCamera::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "ApogeeCamera::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void ApogeeCamera::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "ApogeeCamera::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::write_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute ADC_Gain related method
 *	Description:
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ADC_Gain(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ADC_Gain(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ADC_Gain) ENABLED START -----*/

	*attr_ADC_Gain_read = dev->getADCgain();

	//	Set the attribute value
	attr.set_value(attr_ADC_Gain_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ADC_Gain
}
//--------------------------------------------------------
/**
 *	Write attribute ADC_Gain related method
 *	Description:
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ADC_Gain(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ADC_Gain(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ADC_Gain) ENABLED START -----*/

	try {
		dev->setADCgain(w_val);

	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to set ADC gain",
					e.what(),
					(const char*)"ApogeeCamera::write_ADC_Gain()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ADC_Gain
}
//--------------------------------------------------------
/**
 *	Read attribute ADC_Offset related method
 *	Description:
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ADC_Offset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ADC_Offset(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ADC_Offset) ENABLED START -----*/

	*attr_ADC_Offset_read = dev->getADCoffset();

	//	Set the attribute value
	attr.set_value(attr_ADC_Offset_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ADC_Offset
}
//--------------------------------------------------------
/**
 *	Write attribute ADC_Offset related method
 *	Description:
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ADC_Offset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ADC_Offset(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ADC_Offset) ENABLED START -----*/

	try {
		dev->setADCoffset(w_val);

	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to set ADC offset",
					e.what(),
					(const char*)"ApogeeCamera::write_ADC_Offset()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ADC_Offset
}
//--------------------------------------------------------
/**
 *	Read attribute CoolingDrive related method
 *	Description: Drive of the thermoelectric cooler in percentage
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_CoolingDrive(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_CoolingDrive(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_CoolingDrive) ENABLED START -----*/

	*attr_CoolingDrive_read = dev->getCoolingDrive();

	//	Set the attribute value
	attr.set_value(attr_CoolingDrive_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_CoolingDrive
}
//--------------------------------------------------------
/**
 *	Read attribute CoolingEnable related method
 *	Description: Enable TEC cooling of the CCD
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_CoolingEnable(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_CoolingEnable(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_CoolingEnable) ENABLED START -----*/

	*attr_CoolingEnable_read = dev->isCoolingEnabled();

	//	Set the attribute value
	attr.set_value(attr_CoolingEnable_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_CoolingEnable
}
//--------------------------------------------------------
/**
 *	Write attribute CoolingEnable related method
 *	Description: Enable TEC cooling of the CCD
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_CoolingEnable(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_CoolingEnable(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_CoolingEnable) ENABLED START -----*/

	try {
		dev->enableCooling(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to change cooling status",
					e.what(),
					(const char*)"ApogeeCamera::write_CoolingEnable()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_CoolingEnable
}
//--------------------------------------------------------
/**
 *	Read attribute CoolingSetpoint related method
 *	Description: Camera sensor cooling setpoint
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_CoolingSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_CoolingSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_CoolingSetpoint) ENABLED START -----*/

	*attr_CoolingSetpoint_read = dev->getCoolingSetpoint();

	//	Set the attribute value
	attr.set_value(attr_CoolingSetpoint_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_CoolingSetpoint
}
//--------------------------------------------------------
/**
 *	Write attribute CoolingSetpoint related method
 *	Description: Camera sensor cooling setpoint
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_CoolingSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_CoolingSetpoint(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_CoolingSetpoint) ENABLED START -----*/

	try {
		dev->setCoolingSetpoint(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to set cooling setpoint",
					e.what(),
					(const char*)"ApogeeCamera::write_CoolingSetpoint()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_CoolingSetpoint
}
//--------------------------------------------------------
/**
 *	Read attribute CoolingStatus related method
 *	Description:
 *
 *	Data type:	Tango::DevState
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_CoolingStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_CoolingStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_CoolingStatus) ENABLED START -----*/

	*attr_CoolingStatus_read = ConvertCoolerStatus(dev->getCoolingStatus());

	//	Set the attribute value
	attr.set_value(attr_CoolingStatus_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_CoolingStatus
}
//--------------------------------------------------------
/**
 *	Read attribute CoolingTemperature related method
 *	Description: Actual temperature of the camera sensor
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_CoolingTemperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_CoolingTemperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_CoolingTemperature) ENABLED START -----*/

	*attr_CoolingTemperature_read = dev->getCoolingTemperature();

	//	Set the attribute value
	attr.set_value(attr_CoolingTemperature_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_CoolingTemperature
}
//--------------------------------------------------------
/**
 *	Read attribute EnableFastReadout related method
 *	Description: Enable fast readout
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_EnableFastReadout(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_EnableFastReadout(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_EnableFastReadout) ENABLED START -----*/

	*attr_EnableFastReadout_read = dev->getFastReadoutState();

	//	Set the attribute value
	attr.set_value(attr_EnableFastReadout_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_EnableFastReadout
}
//--------------------------------------------------------
/**
 *	Write attribute EnableFastReadout related method
 *	Description: Enable fast readout
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_EnableFastReadout(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_EnableFastReadout(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_EnableFastReadout) ENABLED START -----*/

	try {
		dev->setFastReadoutState(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to set fast readout",
					e.what(),
					(const char*)"ApogeeCamera::write_EnableFastReadout()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_EnableFastReadout
}
//--------------------------------------------------------
/**
 *	Read attribute IntegrationTime related method
 *	Description: Camera integration time
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_IntegrationTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_IntegrationTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_IntegrationTime) ENABLED START -----*/

	*attr_IntegrationTime_read = dev->getIntegrationTime();

	//	Set the attribute value
	attr.set_value(attr_IntegrationTime_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_IntegrationTime
}
//--------------------------------------------------------
/**
 *	Write attribute IntegrationTime related method
 *	Description: Camera integration time
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_IntegrationTime(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_IntegrationTime(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_IntegrationTime) ENABLED START -----*/

	try {
		dev->setIntegrationTime(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set integration time",
					e.what(),
					(const char*)"ApogeeCamera::write_IntegrationTime()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_IntegrationTime
}
//--------------------------------------------------------
/**
 *	Read attribute ROI_HBin related method
 *	Description: Horizontal binning of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ROI_HBin(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ROI_HBin(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ROI_HBin) ENABLED START -----*/

	*attr_ROI_HBin_read = dev->getRoiHBin();

	//	Set the attribute value
	attr.set_value(attr_ROI_HBin_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ROI_HBin
}
//--------------------------------------------------------
/**
 *	Write attribute ROI_HBin related method
 *	Description: Horizontal binning of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ROI_HBin(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ROI_HBin(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ROI_HBin) ENABLED START -----*/

	try {
		dev->setRoiHBin(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set ROI horizontal bin",
					e.what(),
					(const char*)"ApogeeCamera::write_ROI_HBin()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ROI_HBin
}
//--------------------------------------------------------
/**
 *	Read attribute ROI_HSize related method
 *	Description: Horizontal size of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ROI_HSize(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ROI_HSize(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ROI_HSize) ENABLED START -----*/

	*attr_ROI_HSize_read = dev->getRoiHSize();

	//	Set the attribute value
	attr.set_value(attr_ROI_HSize_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ROI_HSize
}
//--------------------------------------------------------
/**
 *	Write attribute ROI_HSize related method
 *	Description: Horizontal size of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ROI_HSize(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ROI_HSize(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ROI_HSize) ENABLED START -----*/

	try {
		dev->setRoiHSize(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set ROI horizontal size",
					e.what(),
					(const char*)"ApogeeCamera::write_ROI_HSize()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ROI_HSize
}
//--------------------------------------------------------
/**
 *	Read attribute ROI_HStart related method
 *	Description: Horizontal start position for ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ROI_HStart(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ROI_HStart(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ROI_HStart) ENABLED START -----*/

	*attr_ROI_HStart_read = dev->getRoiHStart();

	//	Set the attribute value
	attr.set_value(attr_ROI_HStart_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ROI_HStart
}
//--------------------------------------------------------
/**
 *	Write attribute ROI_HStart related method
 *	Description: Horizontal start position for ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ROI_HStart(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ROI_HStart(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ROI_HStart) ENABLED START -----*/

	try {
		dev->setRoiHStart(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set ROI horizontal start pixel",
					e.what(),
					(const char*)"ApogeeCamera::write_ROI_HStart()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ROI_HStart
}
//--------------------------------------------------------
/**
 *	Read attribute ROI_VBin related method
 *	Description: Vertical binning of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ROI_VBin(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ROI_VBin(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ROI_VBin) ENABLED START -----*/

	*attr_ROI_VBin_read = dev->getRoiVBin();

	//	Set the attribute value
	attr.set_value(attr_ROI_VBin_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ROI_VBin
}
//--------------------------------------------------------
/**
 *	Write attribute ROI_VBin related method
 *	Description: Vertical binning of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ROI_VBin(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ROI_VBin(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ROI_VBin) ENABLED START -----*/

	try {
		dev->setRoiVBin(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set ROI vertical bin",
					e.what(),
					(const char*)"ApogeeCamera::write_ROI_VBin()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ROI_VBin
}
//--------------------------------------------------------
/**
 *	Read attribute ROI_VSize related method
 *	Description: Vertical size of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ROI_VSize(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ROI_VSize(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ROI_VSize) ENABLED START -----*/

	*attr_ROI_VSize_read = dev->getRoiVSize();

	//	Set the attribute value
	attr.set_value(attr_ROI_VSize_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ROI_VSize
}
//--------------------------------------------------------
/**
 *	Write attribute ROI_VSize related method
 *	Description: Vertical size of ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ROI_VSize(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ROI_VSize(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ROI_VSize) ENABLED START -----*/

	try {
		dev->setRoiVSize(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set ROI vertical size",
					e.what(),
					(const char*)"ApogeeCamera::write_ROI_VSize()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ROI_VSize
}
//--------------------------------------------------------
/**
 *	Read attribute ROI_VStart related method
 *	Description: Vertical start position for ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::read_ROI_VStart(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_ROI_VStart(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_ROI_VStart) ENABLED START -----*/

	*attr_ROI_VStart_read = dev->getRoiVStart();

	//	Set the attribute value
	attr.set_value(attr_ROI_VStart_read);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_ROI_VStart
}
//--------------------------------------------------------
/**
 *	Write attribute ROI_VStart related method
 *	Description: Vertical start position for ROI
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void ApogeeCamera::write_ROI_VStart(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::write_ROI_VStart(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(ApogeeCamera::write_ROI_VStart) ENABLED START -----*/

	try {
		dev->setRoiVStart(w_val);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Cannot set ROI vertical start pixel",
					e.what(),
					(const char*)"ApogeeCamera::write_ROI_VStart()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::write_ROI_VStart
}
//--------------------------------------------------------
/**
 *	Read attribute Image related method
 *	Description: Last acquired image
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Image max = 4096 x 4096
 */
//--------------------------------------------------------
void ApogeeCamera::read_Image(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ApogeeCamera::read_Image(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::read_Image) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(attr_Image_read, img_x, img_y);

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::read_Image
}

//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void ApogeeCamera::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(ApogeeCamera::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command StartAcquisition related method
 *	Description: Start an acquisition of n images. If n = -1 the acquisition is continuous.
 *
 *	@param argin Numer of images to acquire (-1 for continuous acquisition)
 */
//--------------------------------------------------------
void ApogeeCamera::start_acquisition(Tango::DevLong argin)
{
	DEBUG_STREAM << "ApogeeCamera::StartAcquisition()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::start_acquisition) ENABLED START -----*/

	try {
		dev->StartAcquisition(argin);
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to start acquisition",
					e.what(),
					(const char*)"ApogeeCamera::StartAcquisition()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::start_acquisition
}
//--------------------------------------------------------
/**
 *	Command StopAcquisition related method
 *	Description: Stop a running acquisition
 *
 */
//--------------------------------------------------------
void ApogeeCamera::stop_acquisition()
{
	DEBUG_STREAM << "ApogeeCamera::StopAcquisition()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ApogeeCamera::stop_acquisition) ENABLED START -----*/

	try {
		dev->StopAcquisition();
	} catch(std::runtime_error &e) {
		Tango::Except::throw_exception(
					(const char*)"Failed to start acquisition",
					e.what(),
					(const char*)"ApogeeCamera::StartAcquisition()");
	}

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::stop_acquisition
}
//--------------------------------------------------------
/**
 *	Method      : ApogeeCamera::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void ApogeeCamera::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(ApogeeCamera::add_dynamic_commands) ENABLED START -----*/

	//	Add your own code to create and add dynamic commands if any

	/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::add_dynamic_commands
}

/*----- PROTECTED REGION ID(ApogeeCamera::namespace_ending) ENABLED START -----*/

//	Additional Methods

Tango::DevState ApogeeCamera::ConvertCoolerStatus(Apg::CoolerStatus status) {
	if(status == Apg::CoolerStatus_Off)
		return Tango::OFF;
	else if(status == Apg::CoolerStatus_RampingToSetPoint)
		return Tango::MOVING;
	else if(status == Apg::CoolerStatus_AtSetPoint)
		return Tango::ON;
	else if(status == Apg::CoolerStatus_Revision)
		return Tango::ALARM;
	else if(status == Apg::CoolerStatus_Suspended)
		return Tango::STANDBY;
	else
		return Tango::UNKNOWN;
}


std::vector<DeviceInfo> FindDeviceUsbEx::Find()
{
	std::vector<DeviceInfo> out;

	// Find devices
	std::string devstr = FindDeviceUsb::Find();

	size_t index = 0;

	while(index < devstr.length()) {

		size_t s = devstr.find("<d>", index);
		if(s==std::string::npos)
			break;
		size_t e = devstr.find("</d>", index);
		if(e==std::string::npos)
			break;
		index = e+3;

		// Extract device description
		std::string dev = devstr.substr(s+3, e-s-3);

		// Example string:
		// <d>address=0,interface=usb,deviceType=camera,id=0x49,firmwareRev=0x21,model=AltaU-4020ML,interfaceStatus=NA</d>
		DeviceInfo info;

		// Search for address
		s = dev.find("address=");
		if(s == std::string::npos)
			// Missing address
			continue;
		e = dev.find(",", s);
		if(e == std::string::npos)
			e = dev.find("</d>", s);
		if(e == std::string::npos)
			continue;
		info.address = dev.substr(s+strlen("address="), e-s-strlen("address="));

		// Search for interface
		s = dev.find("interface=");
		if(s == std::string::npos)
			// Missing address
			continue;
		e = dev.find(",", s);
		if(e == std::string::npos)
			e = dev.find("</d>", s);
		if(e == std::string::npos)
			continue;
		info.interface = dev.substr(s+strlen("interface="), e-s-strlen("interface="));

		// Search for device type
		s = dev.find("deviceType=");
		if(s == std::string::npos)
			// Missing address
			continue;
		e = dev.find(",", s);
		if(e == std::string::npos)
			e = dev.find("</d>", s);
		if(e == std::string::npos)
			continue;
		info.type = dev.substr(s+strlen("deviceType="), e-s-strlen("deviceType="));

		// Search for model
		s = dev.find("model=");
		if(s == std::string::npos)
			// Missing address
			continue;
		e = dev.find(",", s);
		if(e == std::string::npos)
			e = dev.find("</d>", s);
		if(e == std::string::npos)
			continue;
		info.model = dev.substr(s+strlen("model="), e-s-strlen("model="));

		// Search for ID
		s = dev.find("id=");
		if(s == std::string::npos)
			// Missing address
			continue;
		e = dev.find(",", s);
		if(e == std::string::npos)
			e = dev.find("</d>", s);
		if(e == std::string::npos)
			continue;
		{
			std::stringstream ss;
			ss << std::hex << std::showbase << dev.substr(s+strlen("id="), e-s-strlen("id="));
			ss >> info.id;
		}

		// Search for firmware rev.
		s = dev.find("firmwareRev=");
		if(s == std::string::npos)
			// Missing address
			continue;
		e = dev.find(",", s);
		if(e == std::string::npos)
			e = dev.find("</d>", s);
		if(e == std::string::npos)
			continue;
		{
			std::stringstream ss;
			ss << std::hex << std::showbase << dev.substr(s+strlen("firmwareRev="), e-s-strlen("firmwareRev="));
			ss >> info.firmware;
		}

		out.push_back(info);
	}

	for(size_t i = 0; i < out.size(); i++) {
		cout << "[" << i << "] address = " << out[i].address << ", model = " << out[i].model << endl;
	}

	return out;
}


// ApogeeMon constructor. Initialize communication with the camera
ApogeeMon::ApogeeMon(ApogeeCamera *parent) :
	_cam(NULL),
	_terminate(false),
	_parent(parent),  // Store parent pointer
	_adc_speed(Apg::AdcSpeed_Normal),
	_cooling_enable(false),
	_cooling_setpoint(0.0),
	_cooling_temperature(0.0),
	_cooling_status(Apg::CoolerStatus_Off),
	_cooling_drive(0.0),
	_min_exposure(0.0),
	_max_exposure(0.0),
	_roi_v_bin(1),
	_roi_v_size(0),
	_roi_v_start(0),
	_roi_h_bin(1),
	_roi_h_size(0),
	_roi_h_start(0),
	_max_pixel_h(0),
	_max_pixel_v(0),
	_max_bin_h(1),
	_max_bin_v(1),
	_adc_gain(0),
	_adc_offset(0),
	_exposure(0.0),
	_acq_continuous(false),
	_start_newacq(false),
	_firmware(0)
{
	// Start monitoring thread
	start_undetached();
}


DeviceInfo ApogeeMon::findCamera() {

	// Search for available devices
	FindDeviceUsbEx look4cam;
	std::vector<DeviceInfo> devs = look4cam.Find();
	_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Found " << devs.size() << " Apogee devices" << endl;

	// Search for a device of type camera
	for(size_t i = 0; i < devs.size(); i++) {
		if(devs[i].type == "camera") {
			if(devs[i].model.find("Ascent") != std::string::npos) {
				// Camera found!
				_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Found a camera of type " << devs[i].model << ". Initializing." << endl;
				return devs[i];
			} else {
				_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Ignoring an unsupported camera model: " << devs[i].model << endl;
			}
		}
	}

	// No supported camera found
	throw std::runtime_error("No supported camera found");
}

void ApogeeMon::initialize() {
	// Lock camera
	omni_mutex_lock sync(this->_lock);

	// Check if a camera already exists (should never happen, it indicates a bug in the program)
	if(_cam) {
		throw std::runtime_error("Camera is already initialized!");
	}

	// Create camera object
	Ascent *cam = new Ascent();
	if(!cam) {
		throw std::runtime_error("Allocation of camera object failed");
	}
	_cam = static_cast<ApogeeCam*>(cam);

	// Open connection to the camera
	_cam->OpenConnection(_devinfo.interface, _devinfo.address, _devinfo.firmware, _devinfo.id);
	_cam->Init();

	// Init successfull. Store camera object
	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Initialized camera with address " << _devinfo.address << ". Model is " << _cam->GetModel() << " (Sensor: " << _cam->GetSensor() << ", Firmware: " << _cam->GetFirmwareRev() << ", S/N: " << _cam->GetSerialNumber() << ")" << endl;

	// Store camera firmware
	_firmware = _cam->GetFirmwareRev();

	// Pipeline download should be enabled or the camera will hang in ImagingActive state
	_cam->SetPipelineDownload(true);

	// Setup camera with memorized attribute values
	Tango::MultiAttribute* attrs = _parent->get_device_attr();

	{
		// Readout speed
		Tango::WAttribute& att = attrs->get_w_attr_by_name("EnableFastReadout");
		Tango::DevBoolean val;
		att.get_write_value(val);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'EnableFastReadout' to " << val << endl;
		if(val)
			_adc_speed = Apg::AdcSpeed_Fast;
		else
			_adc_speed = Apg::AdcSpeed_Normal;
		_cam->SetCcdAdcSpeed(_adc_speed);
	}
	{
		// ADC gain
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ADC_Gain");
		att.get_write_value(_adc_gain);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ADC_Gain' to " << _adc_gain << endl;
		_cam->SetAdcGain(_adc_gain, 0, 0);
		_cam->SetAdcGain(_adc_gain, 1, 0);
	}
	{
		// ADC offset
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ADC_Offset");
		att.get_write_value(_adc_offset);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ADC_Offset' to " << _adc_offset << endl;
		_cam->SetAdcOffset(_adc_offset, 0, 0);
		_cam->SetAdcOffset(_adc_offset, 1, 0);
	}
	{
		// Enable cooling
		Tango::WAttribute& att = attrs->get_w_attr_by_name("CoolingEnable");
		att.get_write_value(_cooling_enable);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'CoolingEnable' to " << _cooling_enable << endl;
		_cam->SetCooler(_cooling_enable);
	}
	{
		// Cooling setpoint
		Tango::WAttribute& att = attrs->get_w_attr_by_name("CoolingSetpoint");
		att.get_write_value(_cooling_setpoint);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'CoolingSetpoint' to " << _cooling_setpoint << endl;
		_cam->SetCoolerSetPoint(_cooling_setpoint);
	}

	// Cooling variables
	_cooling_temperature = _cam->GetTempCcd();
	_cooling_status = _cam->GetCoolerStatus();
	_cooling_drive = _cam->GetCoolerDrive();

	// Get ROI max values
	_max_pixel_h = _cam->GetMaxImgCols();
	_max_pixel_v = _cam->GetMaxImgRows();
	_max_bin_h = 10; // _cam->GetMaxBinCols(); NOTE: hardware binning is not working. We revert to software binning
	_max_bin_v = 10; // _cam->GetMaxBinRows();
	_cam->SetRoiBinCol(1);
	_cam->SetRoiBinRow(1);

	{
		// Roi H binning
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ROI_HBin");
		att.get_write_value(_roi_h_bin);
		if(_roi_h_bin > _max_bin_h) {
			_roi_h_bin = _max_bin_h;
			att.set_write_value(_roi_h_bin);
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized value above the allowed maximum. Setting 'ROI_HBin' to maximum of " << _roi_h_bin << endl;
		}
		else if(_roi_h_bin < 1) {
			_roi_h_bin = 1;
			att.set_write_value(_roi_h_bin);
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized value below the allowed minimum. Setting 'ROI_HBin' to minimum of " << _roi_h_bin << endl;
		}
		else if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ROI_HBin' to " << _roi_h_bin << endl;
		//_cam->SetRoiBinCol(_roi_h_bin); NOTE: hardware binning disabled
	}
	{
		// Roi H size
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ROI_HSize");
		att.get_write_value(_roi_h_size);
		if(_roi_h_size < 1 || _roi_h_size > _max_pixel_h) {
			_roi_h_size = _max_pixel_h;
			att.set_write_value(_roi_h_size);
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized value not valid. Setting 'ROI_HSize' to maximum of " << _roi_h_size << endl;
		}
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ROI_HSize' to " << _roi_h_size << endl;
		_cam->SetRoiNumCols(_roi_h_size);
	}
	{
		// Roi H start
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ROI_HStart");
		att.get_write_value(_roi_h_start);
		// WORKAROUND for firmware 108: start row and col must be 1. Default is zero but gives a completely corrpted image
		if(_roi_h_start < 1 && _firmware <= 108) {
			_roi_h_start = 1;
			att.set_write_value(_roi_h_start);
		}
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ROI_HStart' to " << _roi_h_start << endl;
		_cam->SetRoiStartCol(_roi_h_start);
	}
	{
		// Roi V binning
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ROI_VBin");
		att.get_write_value(_roi_v_bin);
		if(_roi_v_bin > _max_bin_v) {
			_roi_v_bin = _max_bin_v;
			att.set_write_value(_roi_v_bin);
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized value above the allowed maximum. Setting 'ROI_VBin' to maximum of " << _roi_v_bin << endl;
		}
		else if(_roi_v_bin < 1) {
			_roi_v_bin = 1;
			att.set_write_value(_roi_v_bin);
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized value below the allowed minimum. Setting 'ROI_VBin' to minimum of " << _roi_v_bin << endl;
		}
		else if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ROI_VBin' to " << _roi_v_bin << endl;
		//_cam->SetRoiBinRow(_roi_v_bin); NOTE: hardware binning disabled
	}
	{
		// Roi V size
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ROI_VSize");
		att.get_write_value(_roi_v_size);
		if(_roi_v_size < 1 || _roi_v_size > _max_pixel_v) {
			_roi_v_size = _max_pixel_v;
			att.set_write_value(_roi_v_size);
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized value not valid. Setting 'ROI_VSize' to maximum of " << _roi_v_size << endl;
		}
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ROI_VSize' to " << _roi_v_size << endl;
		_cam->SetRoiNumRows(_roi_v_size);
	}
	{
		// Roi V start
		Tango::WAttribute& att = attrs->get_w_attr_by_name("ROI_VStart");
		att.get_write_value(_roi_v_start);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'ROI_VStart' to " << _roi_v_start << endl;
		_cam->SetRoiStartRow(_roi_v_start);
	}

	// Get minimum and maximum exposure times
	_min_exposure = _cam->GetMinExposureTime();
	_max_exposure = _cam->GetMaxExposureTime();
	{
		// Integration time
		Tango::WAttribute& att = attrs->get_w_attr_by_name("IntegrationTime");
		att.get_write_value(_exposure);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Restoring 'IntegrationTime' to " << _exposure << endl;
		if(_exposure < _min_exposure) {
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized 'IntegrationTime' value was less than minimum allowed. Setting minimum." << endl;
			att.set_write_value(_min_exposure);
			_exposure = _min_exposure;
		}
		if(_exposure > _max_exposure) {
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Memorized 'IntegrationTime' value was more than maximum allowed. Setting maximum." << endl;
			att.set_write_value(_max_exposure);
			_exposure = _max_exposure;
		}
	}

	// Pre-allocate image buffer
	_image.clear();
	_image.reserve(_cam->GetMaxImgCols() * _cam->GetMaxImgRows());
}


// Close camera
void ApogeeMon::closeCamera() {
	// Lock camera
	omni_mutex_lock sync(this->_lock);
	if(_cam) {
		// Delete camera object (connection is closed automatically)
		delete _cam;
		_cam = NULL;
	}
}

// ApogeeMon destructor
ApogeeMon::~ApogeeMon() {
	closeCamera();
}

// Start acquisition
void ApogeeMon::StartAcquisition(int frames) {
	if(frames == 0 || frames < -1)
		throw std::runtime_error("Invalid number of frames");
	omni_mutex_lock sync(this->_lock);
	if(frames == -1) {
		_acq_continuous = true;
		_cam->SetImageCount(1);
	} else {
		_start_newacq = true;
		_cam->SetImageCount(frames);
	}
}

// Stop acquisition
void ApogeeMon::StopAcquisition() {
	omni_mutex_lock sync(this->_lock);
	_acq_continuous = false;
	_start_newacq = false;
	_cam->StopExposure(false);
}

// Set cooling status
void ApogeeMon::enableCooling(bool enable) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_cooling_enable == enable)
		return;
	// Lock camera object
	omni_mutex_lock sync(this->_lock);
	// Write
	_cam->SetCooler(enable);
}

// Set cooling setpoint temperature
void ApogeeMon::setCoolingSetpoint(double temperature) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(temperature == _cooling_setpoint)
		return;
	// Lock camera object
	omni_mutex_lock sync(this->_lock);
	// Write
	_cam->SetCoolerSetPoint(temperature);
}


// Horizontal ROI commands
void ApogeeMon::setRoiHBin(uint16_t bin) {
	uint16_t val = 0;
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_roi_h_bin == bin)
		return;
	if(bin < 1)
		throw std::runtime_error("Minimum bin is 1");
	if(bin > _max_bin_h) {
		std::stringstream msg;
		msg << "Maximum binning is " << _max_bin_h;
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock qsync(this->_queue_lock);
	CameraOperation cmd(APG_HBIN, bin);
	_queue.push(cmd);
}

void ApogeeMon::setRoiHSize(uint16_t pixel) {
	// Take into account software binning
	pixel *= _roi_h_bin;
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_roi_h_size == pixel)
		return;
	if(pixel < 1)
		throw std::runtime_error("Minimum size is 1");
	// Check maximum size
	if(pixel > _max_pixel_h) {
		std::stringstream msg;
		msg << "Maximum size is " << (_max_pixel_h / _roi_h_bin);
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock qsync(this->_queue_lock);
	CameraOperation cmd(APG_HSIZE, pixel);
	_queue.push(cmd);
}

void ApogeeMon::setRoiHStart(uint16_t pixel) {
	// Take into account software binning
	pixel *= _roi_h_bin;
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_roi_h_start == pixel)
		return;
	// If firmware is 108 minimum start column is 1
	if(_firmware <= 108 && pixel < 1)
		throw std::runtime_error("Minimum horizontal start pixel in 1 with firmware up to version 108");
	// Check maximum start
	if(pixel > _max_pixel_h-1) {
		std::stringstream msg;
		msg << "Maximum start pixel is " << (_max_pixel_h / _roi_h_bin);
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock qsync(this->_queue_lock);
	CameraOperation cmd(APG_HSTART, pixel);
	_queue.push(cmd);
}

// Vertical ROI commands
void ApogeeMon::setRoiVBin(uint16_t bin) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_roi_v_bin == bin)
		return;
	if(bin < 1)
		throw std::runtime_error("Minimum bin is 1");
	// Check maximum bin
	if(bin > _max_bin_v) {
		std::stringstream msg;
		msg << "Maximum binning is " << _max_bin_v;
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock qsync(this->_queue_lock);
	CameraOperation cmd(APG_VBIN, bin);
	_queue.push(cmd);
}

void ApogeeMon::setRoiVSize(uint16_t pixel) {
	// Take into account software binning
	pixel *= _roi_v_bin;
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_roi_v_size == pixel)
		return;
	if(pixel < 1)
		throw std::runtime_error("Minimum size is 1");
	// Check maximum size
	if(pixel > _max_pixel_v) {
		std::stringstream msg;
		msg << "Maximum size is " << (_max_pixel_v / _roi_v_bin);
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock qsync(this->_queue_lock);
	CameraOperation cmd(APG_VSIZE, pixel);
	_queue.push(cmd);
}

void ApogeeMon::setRoiVStart(uint16_t pixel) {
	// Take into account software binning
	pixel *= _roi_v_bin;
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_roi_v_start == pixel)
		return;
	// Check maximum start
	if(pixel > _max_pixel_v) {
		std::stringstream msg;
		msg << "Maximum start pixel is " << (_max_pixel_v / _roi_v_bin);
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock sync(this->_queue_lock);
	CameraOperation cmd(APG_VSTART, pixel);
	_queue.push(cmd);
}


void ApogeeMon::setADCgain(uint16_t gain) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");

	if(gain == _adc_gain)
		return;

	if(gain > 63)
		throw std::runtime_error("Gain exceeding maximum value");

	// Submit to queue
	omni_mutex_lock sync(this->_queue_lock);
	CameraOperation cmd(APG_ADCGAIN, gain);
	_queue.push(cmd);
}


void ApogeeMon::setADCoffset(uint16_t offset) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");

	if(offset == _adc_offset)
		return;

	if(offset > 511)
		throw std::runtime_error("Offset exceeding maximum value");

	// Submit to queue
	omni_mutex_lock sync(this->_queue_lock);
	CameraOperation cmd(APG_ADCOFFSET, offset);
	_queue.push(cmd);
}


// Integration time
void ApogeeMon::setIntegrationTime(double time) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(time == _exposure)
		return;

	// Check that the supplied time is withing the acceptable range
	if(time < _min_exposure) {
		std::stringstream msg;
		msg << "Exposure time is below the minimum value of " << _cam->GetMinExposureTime() << " s";
		throw std::runtime_error(msg.str());
	}
	if(time > _max_exposure) {
		std::stringstream msg;
		msg << "Exposure time is above the maximum value of " << _cam->GetMaxExposureTime() << " s";
		throw std::runtime_error(msg.str());
	}
	// Submit to queue
	omni_mutex_lock sync(this->_queue_lock);
	CameraOperation cmd(APG_EXPOSURE, time);
	_queue.push(cmd);
}

void ApogeeMon::setFastReadoutState(bool state) {
	// Check if camera exists
	if(!_cam)
		throw std::runtime_error("No camera initialized");
	if(_adc_speed == Apg::AdcSpeed_Normal) {
		if(!state)
			return;
	} else {
		if(state)
			return;
	}
	// Submit to queue
	omni_mutex_lock sync(this->_queue_lock);
	CameraOperation cmd(APG_READOUT, uint16_t(state));
	_queue.push(cmd);
}

// Extract error type from message
Apg::ErrorType ApogeeMon::getErrorCode(const std::string& msg) {
	size_t pos = msg.rfind(':');
	int err;
	if(pos != std::string::npos && pos != msg.size()-1) {
		std::stringstream ss;
		ss << msg.substr(pos+1, msg.size()-pos);
		if(!(ss >> err)) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to recover error type" << endl;
			err = Apg::ErrorType_Connection;
		}
	}
	return static_cast<Apg::ErrorType>(err);
}

void *ApogeeMon::run_undetached(void *arg) {

	// Initialize return value
	int *result = new int(0);

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Starting polling thread" << endl;

	// Wait for the DServer to become available (it means initialization has ended)
	Tango::Util *tg = Tango::Util::instance();
	do {
		msleep(500);
		try {
			tg->get_dserver_device();
			break;
		} catch(Tango::DevFailed &e) {
			if(_parent->get_logger()->is_debug_enabled())
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Waiting for the DServer to finish initialization" << endl;
		}
		if(_terminate) {
			*result = -1;
			return result;
		}
	} while(true);

	try {
		// Find camera
		_devinfo = findCamera();

		// Initialize
		initialize();

		// Init done
		_parent->set_state(Tango::STANDBY);

	} catch(std::runtime_error &e) {
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize camera. Error: " << e.what() << endl;
		closeCamera();
		_parent->set_state(Tango::FAULT);
	}

	// Timing structures
	struct timeval s, e;
	struct timeval tt;
	gettimeofday(&tt, NULL);
	struct timespec sl;

	size_t _retry = 0;

	while(!_terminate) {

		// Start of polling cycle
		gettimeofday(&s, NULL);


		if(_parent->get_state() != Tango::FAULT) {

			try {
				Apg::Status status;
				{
					// Get camera imaging status
					{
						omni_mutex_lock sync(this->_lock);
						status = _cam->GetImagingStatus();
					}

					// Update CCD temperature reading every 2 seconds
					if(ELAPSED_TIME_MS(tt, s) > 10000) {

						double ccd_temp = 0.0;
						double ccd_setpoint = 0.0;
						bool cooler_on = false;
						Apg::CoolerStatus cs;
						{
							omni_mutex_lock sync(this->_lock);
							// Update measure time
							gettimeofday(&tt, NULL);
							ccd_temp = _cam->GetTempCcd();
							ccd_setpoint = _cam->GetCoolerSetPoint();
							cooler_on = _cam->IsCoolerOn();
							cs = _cam->GetCoolerStatus();
						}

						if(ccd_temp != _cooling_temperature) {
							_cooling_temperature = ccd_temp;
							_parent->push_change_event("CoolingTemperature", &_cooling_temperature);
						}
						if(ccd_setpoint != _cooling_setpoint) {
							_cooling_setpoint = ccd_setpoint;
							_parent->push_change_event("CoolingSetpoint", &_cooling_setpoint);
						}
						if(cooler_on != _cooling_enable) {
							_cooling_enable = cooler_on;
							_parent->push_change_event("CoolingEnable", &_cooling_enable);
						}
						if(cs != _cooling_status) {
							_cooling_status = cs;
							{
								Tango::AutoTangoMonitor sync(_parent);
								*(_parent->attr_CoolingStatus_read) = _parent->ConvertCoolerStatus(_cooling_status);
							}
							_parent->push_change_event("CoolingStatus", _parent->attr_CoolingStatus_read);
						}
					}
				}

				if(status == Apg::Status_ConnectionError) {
					_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Camera status: connection error" << endl;
					closeCamera();
					_parent->set_state(Tango::FAULT);
					continue;

				} else if(status == Apg::Status_DataError) {
					_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Camera status: data error" << endl;
					// TODO

				} else if(status == Apg::Status_PatternError) {
					_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Camera status: pattern error" << endl;
					// TODO

				} else {

					// Check command queue
					if(!_queue.empty()) {
						if(status == Apg::Status_Exposing || status == Apg::Status_ImagingActive || Apg::Status_ImageReady) {
							omni_mutex_lock sync(this->_lock);
							_cam->StopExposure(false);
						}

						omni_mutex_lock qsync(this->_queue_lock);
						while(!_queue.empty()) {
							// Process commands
							CameraOperation cmd = _queue.front();
							_queue.pop();

							if(_parent->get_logger()->is_debug_enabled())
								_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Processing command " << cmd << ". Remaining objects on queue: " << _queue.size() << endl;

							switch(cmd.getCommand()) {
								case APG_EXPOSURE:
									_exposure = cmd.getDouble();
									_parent->push_change_event("IntegrationTime", &_exposure);
									break;
								case APG_HBIN:
									// NOTE: hardware binning disabled
// 									try {
// 										omni_mutex_lock sync(this->_lock);
// 										_cam->SetRoiBinCol(cmd.getUShort());
// 									} catch(std::runtime_error &e) {
// 										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set horizontal binning. Error: " << e.what() << endl;
// 										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
// 											throw;
// 										break;
// 									}
									_roi_h_bin = cmd.getUShort();
									*(_parent->attr_ROI_HBin_read) = _roi_h_bin;
									_parent->push_change_event("ROI_HBin", _parent->attr_ROI_HBin_read);
									*(_parent->attr_ROI_HSize_read) = _roi_h_size / _roi_h_bin;
									_parent->push_change_event("ROI_HSize", _parent->attr_ROI_HSize_read);
									*(_parent->attr_ROI_HStart_read) = _roi_h_start / _roi_h_bin;
									_parent->push_change_event("ROI_HStart", _parent->attr_ROI_HStart_read);
									break;
								case APG_HSIZE:
									try {
										omni_mutex_lock sync(this->_lock);
										_cam->SetRoiNumCols(cmd.getUShort());
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set horizontal size. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_roi_h_size = cmd.getUShort();
									*(_parent->attr_ROI_HSize_read) = _roi_h_size / _roi_h_bin;
									_parent->push_change_event("ROI_HSize", _parent->attr_ROI_HSize_read);
									break;
								case APG_HSTART:
									try {
										omni_mutex_lock sync(this->_lock);
										_cam->SetRoiStartCol(cmd.getUShort());
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set horizontal start pixel. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_roi_h_start = cmd.getUShort();
									*(_parent->attr_ROI_HStart_read) = _roi_h_start / _roi_h_bin;
									_parent->push_change_event("ROI_HStart", _parent->attr_ROI_HStart_read);
									break;
								case APG_VBIN:
									// NOTE: hardware binning disabled
// 									try {
// 										omni_mutex_lock sync(this->_lock);
// 										_cam->SetRoiBinRow(cmd.getUShort());
// 									} catch(std::runtime_error &e) {
// 										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set vertical binning. Error: " << e.what() << endl;
// 										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
// 											throw;
// 										break;
// 									}
									_roi_v_bin = cmd.getUShort();
									*(_parent->attr_ROI_VBin_read) = _roi_v_bin;
									_parent->push_change_event("ROI_VBin", _parent->attr_ROI_VBin_read);
									*(_parent->attr_ROI_VSize_read) = _roi_v_size / _roi_v_bin;
									_parent->push_change_event("ROI_VSize", _parent->attr_ROI_VSize_read);
									*(_parent->attr_ROI_VStart_read) = _roi_v_start / _roi_v_bin;
									_parent->push_change_event("ROI_VStart", _parent->attr_ROI_VStart_read);
									break;
								case APG_VSIZE:
									try {
										omni_mutex_lock sync(this->_lock);
										_cam->SetRoiNumRows(cmd.getUShort());
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set vertical size. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_roi_v_size = cmd.getUShort();
									*(_parent->attr_ROI_VSize_read) = _roi_v_size / _roi_v_bin;
									_parent->push_change_event("ROI_VSize", _parent->attr_ROI_VSize_read);
									break;
								case APG_VSTART:
									try {
										omni_mutex_lock sync(this->_lock);
										_cam->SetRoiStartRow(cmd.getUShort());
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set horizontal start pixel. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_roi_v_start = cmd.getUShort();
									*(_parent->attr_ROI_VStart_read) = _roi_v_start / _roi_v_bin;
									_parent->push_change_event("ROI_VStart", _parent->attr_ROI_VStart_read);
									break;
								case APG_READOUT:
									try {
										omni_mutex_lock sync(this->_lock);
										if(cmd.getUShort() == 1)
											_cam->SetCcdAdcSpeed(Apg::AdcSpeed_Fast);
										else
											_cam->SetCcdAdcSpeed(Apg::AdcSpeed_Normal);
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set ADC speed. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_adc_speed = (cmd.getUShort() == 1) ? Apg::AdcSpeed_Fast : Apg::AdcSpeed_Normal;
									*(_parent->attr_EnableFastReadout_read) = (_adc_speed != Apg::AdcSpeed_Normal);
									_parent->push_change_event("EnableFastReadout", _parent->attr_EnableFastReadout_read);
									break;
								case APG_ADCGAIN:
									try {
										omni_mutex_lock sync(this->_lock);
										_cam->SetAdcGain(cmd.getUShort(), 0, 0);
										_cam->SetAdcGain(cmd.getUShort(), 1, 0);
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set ADC speed. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_adc_gain = cmd.getUShort();
									_parent->push_change_event("ADC_Gain", &_adc_gain);
									break;
								case APG_ADCOFFSET:
									try {
										omni_mutex_lock sync(this->_lock);
										_cam->SetAdcOffset(cmd.getUShort(), 0, 0);
										_cam->SetAdcOffset(cmd.getUShort(), 1, 0);
									} catch(std::runtime_error &e) {
										_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set ADC speed. Error: " << e.what() << endl;
										if(getErrorCode(e.what()) < Apg::ErrorType_Configuration)
											throw;
										break;
									}
									_adc_offset = cmd.getUShort();
									_parent->push_change_event("ADC_Offset", &_adc_offset);
									break;
								default:
									_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got unknown command with ID " << cmd.getCommand() << endl;
									break;
							}
						}

						// We should check again the status, so we go back to the beginning of the polling loop
						continue;
					}

					if(status == Apg::Status_Idle) {
						// Should never happen after Init()
						_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Unexpected IDLE status" << endl;

					} else if(status == Apg::Status_Exposing) {
						// Exposure running
						if(_parent->get_logger()->is_debug_enabled())
							_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Exposure running. Exposure time: " << _exposure << endl;

					} else if(status == Apg::Status_ImagingActive) {
						// Imaging active
						if(_parent->get_logger()->is_debug_enabled())
							_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Imaging active" << endl;

					} else if(status == Apg::Status_ImageReady) {
						// Image ready to readout
						if(_parent->get_logger()->is_debug_enabled())
							_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Image ready" << endl;
						uint16_t count = 0;
						{
							// Get image from camera
							omni_mutex_lock sync(this->_lock);
							count = _cam->GetImageCount();
							_cam->GetImage(_image);
						}
						if(_parent->get_logger()->is_debug_enabled())
							_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Acquired a sequence of " << count << " images. Buffer size is: " << _image.size() << endl;
						if(count > 0) {
							size_t img_size = _image.size() / count;
							if(_roi_h_bin > 1 || _roi_v_bin > 1) {
								// In-place software binning
								img_size = binImageInPlace(_image, _roi_v_size * count, _roi_v_bin, _roi_h_size, _roi_h_bin) / count;
							}
							size_t img_x = _roi_h_size / _roi_h_bin;
							size_t img_y = _roi_v_size / _roi_v_bin;
							if(img_size == img_x*img_y && img_x < 4096 && img_y < 4096) {
								_parent->img_x = img_x;
								_parent->img_y = img_y;
								for(size_t i = 0; i < count; i++) {
									{
										Tango::AutoTangoMonitor sync(_parent);
										memcpy((void*)_parent->attr_Image_read, (void*)(_image.data() + (i * img_size)), sizeof(uint16_t) * img_size);
									}
									// Fire change event
									_parent->push_change_event("Image", _parent->attr_Image_read, img_x, img_y, false);
								}
							} else {
								_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Failed to read image sequence. Image too big (size = " << img_size << ", x = " << img_x << ", y = " << img_y << ")" << endl;
							}
						}
						// After reading out an image we start a new polling cycle without waiting so that we immediately start a new exposure
						continue;

					} else if(status == Apg::Status_Flushing) {
						if(_parent->get_logger()->is_debug_enabled())
							_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Flushing camera" << endl;

						// Camera is idle. We can start another acquisition
						if(_acq_continuous || _start_newacq) {
							omni_mutex_lock sync(_lock);
							if(_start_newacq)
								_start_newacq = false;
							// Start exposure
							_parent->set_state(Tango::ON);
							_cam->StartExposure(_exposure, false);
						} else {
							_parent->set_state(Tango::STANDBY);
						}

					} else if(status == Apg::Status_WaitingOnTrigger) {
						// TODO

					} else {
						_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Unexpected status code: " << status << endl;
					}
				}

			} catch(std::runtime_error &e) {
				// Log error
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Exception in polling loop: " << e.what() << endl;
				Apg::ErrorType err = getErrorCode(e.what());
				switch(err) {
					default:
					case Apg::ErrorType_Configuration:
					case Apg::ErrorType_InvalidMode:
					case Apg::ErrorType_InvalidOperation:
					case Apg::ErrorType_InvalidUsage:
						// Just ignore these. They're anyway logged
						break;

					case Apg::ErrorType_Serious:
						// Reset and init
						try {
							omni_mutex_lock sync(this->_lock);
							_cam->Reset();
							_cam->Init();
							_parent->set_state(Tango::STANDBY);
							break;
						} catch(std::runtime_error &e2) {
							_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Exception while resetting camera: " << e.what() << endl;
						}
					case Apg::ErrorType_Critical:
						// Close camera and search again
						try {
							closeCamera();
							_devinfo = findCamera();
							initialize();
							_parent->set_state(Tango::STANDBY);
							break;
						} catch(std::runtime_error &e2) {
							_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Exception while reconnecting to camera: " << e.what() << endl;
						}
					case Apg::ErrorType_Connection:
						// Camera is not anymore connected. May need a powercycle
						_parent->set_state(Tango::FAULT);
						_retry = 0;
						break;
				}

			} catch(Tango::DevFailed &e) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Tango exception in polling loop: " << e.errors[0].desc << endl;
			}

		} else {
			// Fault state
			msleep(5000);

			// Try to find the camera
			try {
				_devinfo = findCamera();
				initialize();
				_parent->set_state(Tango::STANDBY);

			} catch(std::runtime_error &e2) {
				_retry++;
				std::stringstream msg;
				msg << "Reconnection to camera failed (attempt " << _retry << ")";
				_parent->set_status(msg.str());
			}
		}

		// End of polling cycle
		gettimeofday(&e, NULL);

		int remain = int(_parent->polling) - ELAPSED_TIME_MS(s, e);
		if(remain > 0 && remain < int(_parent->polling)) {
			msleep(remain);
		}
	}

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Terminating polling thread" << endl;

	*result = 0;
	return result;
}


size_t ApogeeMon::binImageInPlace(std::vector<uint16_t> &image, uint16_t rows, uint16_t bin_r, uint16_t cols, uint16_t bin_c) {

	uint16_t bin_sz_c = cols / bin_c;
	uint16_t bin_sz_r = rows / bin_r;

	MatrixProxy<uint16_t> img_in(image, rows, cols);
	MatrixProxy<uint16_t> img_out(image, bin_sz_r, bin_sz_c);

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Binning images down to " << bin_sz_r << " x " << bin_sz_c << endl;

	for(size_t i = 0; i < bin_sz_r; i++) {
		for(size_t j = 0; j < bin_sz_c; j++) {
			uint32_t value = img_in[i*bin_r][j*bin_c];
			for(size_t k = 0; k < bin_c; k++) {
				for(size_t l = 0; l < bin_r; l++) {
					if(k != 0 || l != 0) {
						img_out[i][j] += img_in[i*bin_r+k][j*bin_c+l];
					}
				}
			}
			// Saturation control to avoid overflow
			if(value > 65535)
				img_out[i][j] = 65535;
			else
				img_out[i][j] = value & 0xFFFF;
		}
	}
	return bin_sz_r*bin_sz_c;
}



// Millisecond sleep
void ApogeeMon::msleep(uint32_t msec) {
	if(msec <= 0)
		return;
	struct timespec st;
	struct timeval start, stop;
	gettimeofday(&start, NULL);
	// Setup delay
	st.tv_sec = msec / 1000;
	st.tv_nsec = (msec % 1000) * 1000000;

	while(1) {
		int ans = nanosleep(&st, NULL);
		if(ans == -1 && errno == EINTR) {
			// Nanosleep was interrupted by a signal
			gettimeofday(&stop, NULL);
			uint32_t rem = msec - ELAPSED_TIME_MS(start, stop);
			if(rem > 0) {
				st.tv_sec = rem / 1000;
				st.tv_nsec = (rem % 1000) * 1000000;
			} else {
				break;
			}
		} else {
			break;
		}
	}
}


/*----- PROTECTED REGION END -----*/	//	ApogeeCamera::namespace_ending
} //	namespace
