/*----- PROTECTED REGION ID(XIMCSrv.cpp) ENABLED START -----*/
// kate: replace-tabs off; indent-width 4; indent-mode cstyle; remove-trailing-spaces all; tab-indents on; tab-width 4; indent-width 4
//=============================================================================
//
// file :        XIMCSrv.cpp
//
// description : C++ source for the XIMCSrv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               XIMCSrv are implemented in this file.
//
// project :     Device server for XIMC controller
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <XIMCSrv.h>
#include <XIMCSrvClass.h>

/*----- PROTECTED REGION END -----*/	//	XIMCSrv.cpp

/**
 *  XIMCSrv class description:
 *    Device server for XIMC controllers like Standa 8SMC4-USB
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  GoHome        |  go_home
//  SetZero       |  set_zero
//  MoveAbsolute  |  move_absolute
//  MoveRelative  |  move_relative
//  PowerOff      |  power_off
//  MoveLeft      |  move_left
//  MoveRight     |  move_right
//  Stop          |  stop
//  Reset         |  reset
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  Position         |  Tango::DevDouble	Scalar
//  Velocity         |  Tango::DevDouble	Scalar
//  Temperature      |  Tango::DevFloat	Scalar
//  Acceleration     |  Tango::DevDouble	Scalar
//  USBvoltage       |  Tango::DevFloat	Scalar
//  USBcurrent       |  Tango::DevLong	Scalar
//  PwrVoltage       |  Tango::DevFloat	Scalar
//  PwrCurrent       |  Tango::DevLong	Scalar
//  FirmwareVersion  |  Tango::DevString	Scalar
//  PowerState       |  Tango::DevEnum	Scalar
//  Referenced       |  Tango::DevBoolean	Scalar
//================================================================

namespace XIMCSrv_ns
{
/*----- PROTECTED REGION ID(XIMCSrv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	XIMCSrv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::XIMCSrv()
 *	Description : Constructors for a Tango device
 *                implementing the classXIMCSrv
 */
//--------------------------------------------------------
XIMCSrv::XIMCSrv(Tango::DeviceClass *cl, std::string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(XIMCSrv::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::constructor_1
}
//--------------------------------------------------------
XIMCSrv::XIMCSrv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(XIMCSrv::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::constructor_2
}
//--------------------------------------------------------
XIMCSrv::XIMCSrv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(XIMCSrv::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void XIMCSrv::delete_device()
{
	DEBUG_STREAM << "XIMCSrv::delete_device() " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if(dev) {
		dev->terminate();
		int *retval;
		dev->join((void**)&retval);
		dev = NULL;
	}

	if(attr_FirmwareVersion_read[0]) {
		CORBA::string_free(attr_FirmwareVersion_read[0]);
		attr_FirmwareVersion_read[0] = NULL;
	}

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::delete_device
	delete[] attr_Position_read;
	delete[] attr_Velocity_read;
	delete[] attr_Temperature_read;
	delete[] attr_Acceleration_read;
	delete[] attr_USBvoltage_read;
	delete[] attr_USBcurrent_read;
	delete[] attr_PwrVoltage_read;
	delete[] attr_PwrCurrent_read;
	delete[] attr_FirmwareVersion_read;
	delete[] attr_PowerState_read;
	delete[] attr_Referenced_read;
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void XIMCSrv::init_device()
{
	DEBUG_STREAM << "XIMCSrv::init_device() create device " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::init_device_before


	//	Get the device properties from database
	get_device_property();

	attr_Position_read = new Tango::DevDouble[1];
	attr_Velocity_read = new Tango::DevDouble[1];
	attr_Temperature_read = new Tango::DevFloat[1];
	attr_Acceleration_read = new Tango::DevDouble[1];
	attr_USBvoltage_read = new Tango::DevFloat[1];
	attr_USBcurrent_read = new Tango::DevLong[1];
	attr_PwrVoltage_read = new Tango::DevFloat[1];
	attr_PwrCurrent_read = new Tango::DevLong[1];
	attr_FirmwareVersion_read = new Tango::DevString[1];
	attr_PowerState_read = new PowerStateEnum[1];
	attr_Referenced_read = new Tango::DevBoolean[1];
	//	No longer if mandatory property not set.
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(XIMCSrv::init_device) ENABLED START -----*/

	// Default string for firmware version
	attr_FirmwareVersion_read[0] = CORBA::string_dup("");

	// Update position, velocity and acceleration units
	// Position
	Tango::Attribute &att_p = get_device_attr()->get_attr_by_name("Position");
	Tango::MultiAttrProp<Tango::DevDouble> att_prop;
	att_p.get_properties(att_prop);
	att_prop.unit = units.c_str();
	att_prop.standard_unit = units.c_str();
	att_prop.display_unit = units.c_str();
	att_prop.format = positionFormat.c_str();
	att_p.set_properties(att_prop);

	// Velocity
	Tango::Attribute &att_v = get_device_attr()->get_attr_by_name("Velocity");
	att_v.get_properties(att_prop);
	std::string vunits = units + "/s";
	att_prop.unit = vunits.c_str();
	att_prop.standard_unit = vunits.c_str();
	att_prop.display_unit = vunits.c_str();
	att_prop.format = "%.3f";
	att_v.set_properties(att_prop);

	// Acceleration
	Tango::Attribute &att_a = get_device_attr()->get_attr_by_name("Acceleration");
	att_a.get_properties(att_prop);
	std::string aunits = units + "/s^2";
	att_prop.unit = aunits.c_str();
	att_prop.standard_unit = aunits.c_str();
	att_prop.display_unit = aunits.c_str();
	att_prop.format = "%.3f";
	att_a.set_properties(att_prop);

	//	Initialize device
	dev = new XIMCThread(serialNumber, this);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void XIMCSrv::get_device_property()
{
	/*----- PROTECTED REGION ID(XIMCSrv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("SerialNumber"));
	dev_prop.push_back(Tango::DbDatum("Referenced"));
	dev_prop.push_back(Tango::DbDatum("Polling"));
	dev_prop.push_back(Tango::DbDatum("Conversion"));
	dev_prop.push_back(Tango::DbDatum("ConversionEnc"));
	dev_prop.push_back(Tango::DbDatum("UseEncoder"));
	dev_prop.push_back(Tango::DbDatum("Units"));
	dev_prop.push_back(Tango::DbDatum("PositionFormat"));
	dev_prop.push_back(Tango::DbDatum("FirstHomingSpeed"));
	dev_prop.push_back(Tango::DbDatum("SecondHomingSpeed"));
	dev_prop.push_back(Tango::DbDatum("UseFastAlgorithm"));
	dev_prop.push_back(Tango::DbDatum("HomingDirection"));
	dev_prop.push_back(Tango::DbDatum("BlindMoveBeforeHoming"));
	dev_prop.push_back(Tango::DbDatum("HomingDelta"));
	dev_prop.push_back(Tango::DbDatum("PositionAtHome"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on XIMCSrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		XIMCSrvClass	*ds_class =
			(static_cast<XIMCSrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize SerialNumber from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  serialNumber;
		else {
			//	Try to initialize SerialNumber from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  serialNumber;
		}
		//	And try to extract SerialNumber value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  serialNumber;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize Referenced from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  referenced;
		else {
			//	Try to initialize Referenced from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  referenced;
		}
		//	And try to extract Referenced value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  referenced;

		//	Try to initialize Polling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  polling;
		else {
			//	Try to initialize Polling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  polling;
		}
		//	And try to extract Polling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  polling;

		//	Try to initialize Conversion from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  conversion;
		else {
			//	Try to initialize Conversion from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  conversion;
		}
		//	And try to extract Conversion value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  conversion;

		//	Try to initialize ConversionEnc from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  conversionEnc;
		else {
			//	Try to initialize ConversionEnc from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  conversionEnc;
		}
		//	And try to extract ConversionEnc value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  conversionEnc;

		//	Try to initialize UseEncoder from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useEncoder;
		else {
			//	Try to initialize UseEncoder from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useEncoder;
		}
		//	And try to extract UseEncoder value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useEncoder;

		//	Try to initialize Units from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  units;
		else {
			//	Try to initialize Units from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  units;
		}
		//	And try to extract Units value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  units;

		//	Try to initialize PositionFormat from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  positionFormat;
		else {
			//	Try to initialize PositionFormat from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  positionFormat;
		}
		//	And try to extract PositionFormat value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  positionFormat;

		//	Try to initialize FirstHomingSpeed from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  firstHomingSpeed;
		else {
			//	Try to initialize FirstHomingSpeed from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  firstHomingSpeed;
		}
		//	And try to extract FirstHomingSpeed value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  firstHomingSpeed;

		//	Try to initialize SecondHomingSpeed from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  secondHomingSpeed;
		else {
			//	Try to initialize SecondHomingSpeed from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  secondHomingSpeed;
		}
		//	And try to extract SecondHomingSpeed value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  secondHomingSpeed;

		//	Try to initialize UseFastAlgorithm from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useFastAlgorithm;
		else {
			//	Try to initialize UseFastAlgorithm from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useFastAlgorithm;
		}
		//	And try to extract UseFastAlgorithm value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useFastAlgorithm;

		//	Try to initialize HomingDirection from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  homingDirection;
		else {
			//	Try to initialize HomingDirection from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  homingDirection;
		}
		//	And try to extract HomingDirection value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  homingDirection;

		//	Try to initialize BlindMoveBeforeHoming from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  blindMoveBeforeHoming;
		else {
			//	Try to initialize BlindMoveBeforeHoming from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  blindMoveBeforeHoming;
		}
		//	And try to extract BlindMoveBeforeHoming value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  blindMoveBeforeHoming;

		//	Try to initialize HomingDelta from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  homingDelta;
		else {
			//	Try to initialize HomingDelta from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  homingDelta;
		}
		//	And try to extract HomingDelta value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  homingDelta;

		//	Try to initialize PositionAtHome from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  positionAtHome;
		else {
			//	Try to initialize PositionAtHome from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  positionAtHome;
		}
		//	And try to extract PositionAtHome value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  positionAtHome;

	}

	/*----- PROTECTED REGION ID(XIMCSrv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void XIMCSrv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << std::endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(XIMCSrv::check_mandatory_property) ENABLED START -----*/
		std::cerr << tms.str() << " for " << device_name << std::endl;

		/*----- PROTECTED REGION END -----*/	//	XIMCSrv::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void XIMCSrv::always_executed_hook()
{
	DEBUG_STREAM << "XIMCSrv::always_executed_hook()  " << device_name << std::endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"XIMCSrv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(XIMCSrv::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void XIMCSrv::read_attr_hardware(TANGO_UNUSED(std::vector<long> &attr_list))
{
	DEBUG_STREAM << "XIMCSrv::read_attr_hardware(std::vector<long> &attr_list) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void XIMCSrv::write_attr_hardware(TANGO_UNUSED(std::vector<long> &attr_list))
{
	DEBUG_STREAM << "XIMCSrv::write_attr_hardware(std::vector<long> &attr_list) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::write_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute Position related method
 *	Description: Position in steps
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Position(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Position(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Position) ENABLED START -----*/
	//	Set the attribute value
	*attr_Position_read = dev->getPosition();
	attr.set_value(attr_Position_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Position
}
//--------------------------------------------------------
/**
 *	Write attribute Position related method
 *	Description: Position in steps
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::write_Position(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::write_Position(Tango::WAttribute &attr) entering... " << std::endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XIMCSrv::write_Position) ENABLED START -----*/

	this->move_absolute(w_val);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_Position
}
//--------------------------------------------------------
/**
 *	Read attribute Velocity related method
 *	Description: Velocity in steps/s
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Velocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Velocity(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Velocity) ENABLED START -----*/

	*attr_Velocity_read = dev->getVelocity();
	//	Set the attribute value
	attr.set_value(attr_Velocity_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Velocity
}
//--------------------------------------------------------
/**
 *	Write attribute Velocity related method
 *	Description: Velocity in steps/s
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::write_Velocity(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::write_Velocity(Tango::WAttribute &attr) entering... " << std::endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XIMCSrv::write_Velocity) ENABLED START -----*/

	if(w_val < 0)
		Tango::Except::throw_exception(
			(const char *)"Value error",
			(const char *)"Velocity must be a positive value",
			(const char *)"XIMCSrv::write_Velocity()");

	// Set velocity
	dev->setVelocity(w_val);
	*attr_Velocity_read = dev->getVelocity();
	push_change_event("Velocity", attr_Velocity_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_Velocity
}
//--------------------------------------------------------
/**
 *	Read attribute Temperature related method
 *	Description: Controller temperature
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Temperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Temperature(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Temperature) ENABLED START -----*/

	*attr_Temperature_read = dev->getTemperature();
	//	Set the attribute value
	attr.set_value(attr_Temperature_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Temperature
}
//--------------------------------------------------------
/**
 *	Read attribute Acceleration related method
 *	Description: Acceleration and deceleration
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Acceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Acceleration(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Acceleration) ENABLED START -----*/

	*attr_Acceleration_read = dev->getAcceleration();
	//	Set the attribute value
	attr.set_value(attr_Acceleration_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Acceleration
}
//--------------------------------------------------------
/**
 *	Write attribute Acceleration related method
 *	Description: Acceleration and deceleration
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::write_Acceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::write_Acceleration(Tango::WAttribute &attr) entering... " << std::endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XIMCSrv::write_Acceleration) ENABLED START -----*/

	dev->setAcceleration(w_val);
	*attr_Acceleration_read = dev->getAcceleration();
	push_change_event("Acceleration", attr_Acceleration_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_Acceleration
}
//--------------------------------------------------------
/**
 *	Read attribute USBvoltage related method
 *	Description: USB voltage
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_USBvoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_USBvoltage(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_USBvoltage) ENABLED START -----*/

	*attr_USBvoltage_read = dev->getUSB_V();
	//	Set the attribute value
	attr.set_value(attr_USBvoltage_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_USBvoltage
}
//--------------------------------------------------------
/**
 *	Read attribute USBcurrent related method
 *	Description: USB current
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_USBcurrent(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_USBcurrent(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_USBcurrent) ENABLED START -----*/

	*attr_USBcurrent_read = dev->getUSB_I();
	//	Set the attribute value
	attr.set_value(attr_USBcurrent_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_USBcurrent
}
//--------------------------------------------------------
/**
 *	Read attribute PwrVoltage related method
 *	Description: Motor power supply voltage
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_PwrVoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_PwrVoltage(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_PwrVoltage) ENABLED START -----*/

	*attr_PwrVoltage_read = dev->getPWR_V();
	//	Set the attribute value
	attr.set_value(attr_PwrVoltage_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_PwrVoltage
}
//--------------------------------------------------------
/**
 *	Read attribute PwrCurrent related method
 *	Description: Motor supply current consumption
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_PwrCurrent(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_PwrCurrent(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_PwrCurrent) ENABLED START -----*/

	*attr_PwrCurrent_read = dev->getPWR_I();
	//	Set the attribute value
	attr.set_value(attr_PwrCurrent_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_PwrCurrent
}
//--------------------------------------------------------
/**
 *	Read attribute FirmwareVersion related method
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_FirmwareVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_FirmwareVersion(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_FirmwareVersion) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_FirmwareVersion_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_FirmwareVersion
}
//--------------------------------------------------------
/**
 *	Read attribute PowerState related method
 *	Description:
 *
 *	Data type:	Tango::DevEnum (PowerStateEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_PowerState(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_PowerState(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_PowerState) ENABLED START -----*/
	*attr_PowerState_read = static_cast<PowerStateEnum>(dev->getPowerState());
	//	Set the attribute value
	attr.set_value(attr_PowerState_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_PowerState
}
//--------------------------------------------------------
/**
 *	Read attribute Referenced related method
 *	Description:
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Referenced(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Referenced(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Referenced) ENABLED START -----*/
	*attr_Referenced_read = dev->isReferenced();
	//	Set the attribute value
	attr.set_value(attr_Referenced_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Referenced
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void XIMCSrv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(XIMCSrv::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command GoHome related method
 *	Description: Search home position
 *
 */
//--------------------------------------------------------
void XIMCSrv::go_home()
{
	DEBUG_STREAM << "XIMCSrv::GoHome()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::go_home) ENABLED START -----*/

	dev->goHome();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::go_home
}
//--------------------------------------------------------
/**
 *	Command SetZero related method
 *	Description: Set current position as zero
 *
 */
//--------------------------------------------------------
void XIMCSrv::set_zero()
{
	DEBUG_STREAM << "XIMCSrv::SetZero()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::set_zero) ENABLED START -----*/

	dev->zero();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::set_zero
}
//--------------------------------------------------------
/**
 *	Command MoveAbsolute related method
 *	Description: Move to an absolute position
 *
 *	@param argin Position
 */
//--------------------------------------------------------
void XIMCSrv::move_absolute(Tango::DevDouble argin)
{
	DEBUG_STREAM << "XIMCSrv::MoveAbsolute()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_absolute) ENABLED START -----*/

	dev->moveAbs(argin);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_absolute
}
//--------------------------------------------------------
/**
 *	Command MoveRelative related method
 *	Description: Move to an relative position
 *
 *	@param argin Position
 */
//--------------------------------------------------------
void XIMCSrv::move_relative(Tango::DevDouble argin)
{
	DEBUG_STREAM << "XIMCSrv::MoveRelative()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_relative) ENABLED START -----*/

	dev->moveRel(argin);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_relative
}
//--------------------------------------------------------
/**
 *	Command PowerOff related method
 *	Description: Power off motor
 *
 */
//--------------------------------------------------------
void XIMCSrv::power_off()
{
	DEBUG_STREAM << "XIMCSrv::PowerOff()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::power_off) ENABLED START -----*/

	dev->powerOff();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::power_off
}
//--------------------------------------------------------
/**
 *	Command MoveLeft related method
 *	Description: Start continuous move to the left
 *
 */
//--------------------------------------------------------
void XIMCSrv::move_left()
{
	DEBUG_STREAM << "XIMCSrv::MoveLeft()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_left) ENABLED START -----*/

	dev->moveLeft();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_left
}
//--------------------------------------------------------
/**
 *	Command MoveRight related method
 *	Description: Start continuous move to the right
 *
 */
//--------------------------------------------------------
void XIMCSrv::move_right()
{
	DEBUG_STREAM << "XIMCSrv::MoveRight()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_right) ENABLED START -----*/

	dev->moveRight();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_right
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stop motion
 *
 */
//--------------------------------------------------------
void XIMCSrv::stop()
{
	DEBUG_STREAM << "XIMCSrv::Stop()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::stop) ENABLED START -----*/

	dev->softStop();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::stop
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset the controller sending a hard stop command
 *
 */
//--------------------------------------------------------
void XIMCSrv::reset()
{
	DEBUG_STREAM << "XIMCSrv::Reset()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(XIMCSrv::reset) ENABLED START -----*/

	dev->stop();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::reset
}
//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void XIMCSrv::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(XIMCSrv::add_dynamic_commands) ENABLED START -----*/

	//	Add your own code to create and add dynamic commands if any

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::add_dynamic_commands
}

/*----- PROTECTED REGION ID(XIMCSrv::namespace_ending) ENABLED START -----*/

//	Additional Methods

// Constructor
XIMCThread::XIMCThread(const std::string &serial, XIMCSrv *parent) :
		_dev(device_undefined),
		_parent(parent),
		_terminate(false),
		_home_search(false),
		_enc_enabled(false),
		_curr_pos(0),
		_curr_upos(0),
		_st_enc(0),
		_st_usb_v(0.0),
		_st_usb_i(0),
		_st_pwr_v(0.0),
		_st_pwr_i(0),
		_st_temp(0.0),
		_power_state(0),
		_is_homed(false)
{
	// Format device URI
	std::string sn(serial);
	std::transform(sn.begin(), sn.end(), sn.begin(), ::toupper);
	std::stringstream device_name;
	device_name << "xi-com:/dev/ximc/";
	for(size_t i = sn.length(); i < 8; i++)
		device_name << "0";
	device_name << sn;
	_device_uri = device_name.str();

	// Setup libximc logging callback
	::set_logging_callback(XIMCThread::logging_callback, _parent);

	// Read properties
	_referenced = _parent->referenced;
	_encoder = _parent->useEncoder;
	_conv_steps = _parent->conversion;
	_conv_enc = _parent->conversionEnc;

	// Start thread
	start_undetached();
}


// Destructor
XIMCThread::~XIMCThread() {
	delete_device();
}


// libximc logging callback
void XIMC_CALLCONV XIMCThread::logging_callback(int loglevel, const wchar_t* message, void* user_data) {
	XIMCSrv* _parent = static_cast<XIMCSrv*>(user_data);
	// Convert message to ASCII
	using convert_str = std::codecvt_utf8<wchar_t>;
	std::wstring_convert<convert_str, wchar_t> converter;

	switch(loglevel) {
		case LOGLEVEL_ERROR:
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "[libximc] " << converter.to_bytes(message) << endl;
			break;

		case LOGLEVEL_WARNING:
			_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "[libximc] " << converter.to_bytes(message) << endl;
			break;

		case LOGLEVEL_INFO:
			_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "[libximc] " << converter.to_bytes(message) << endl;
			break;

		default:
		case LOGLEVEL_DEBUG:
			if(_parent->get_logger()->is_debug_enabled()) {
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "[libximc] " << converter.to_bytes(message) << endl;
			}
			break;
	}
}


// Check that a device is connected
void XIMCThread::check_device() {
	// Check if device is good, otherwise throw exception
	if(_dev == device_undefined) {
		Tango::Except::throw_exception(
					(const char *)"Bad device",
					(const char *)"Device not available",
					(const char *)"XIMCThread::check_device()");
	}
}


// Close device
void XIMCThread::delete_device() {
	if(_dev != device_undefined) {
		::close_device(&_dev);
		_dev = device_undefined;
	}
	if(_parent) {
		_parent->set_state(Tango::FAULT);
	}
}


// Common error checking for error codes returned by a libximc call
void XIMCThread::check_error_code(result_t code, const char* operation, const char* function) {
	if(code == result_ok)
		return;

	stringstream msg;
	msg << "Failed to " << operation;
	switch(code) {
		default:
		case result_error:
			msg << " (Error: generic error)";
			break;

		case result_not_implemented:
			msg << " (Error: not implemented)";
			delete_device();
			break;

		case result_value_error:
			msg << " (Error: value error)";
			break;

		case result_nodevice:
			msg << " (Error: device offline)";
			delete_device();
			break;
	}
	_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << msg.str() << endl;
	Tango::Except::throw_exception(
					(const char *)"XIMC device error",
					msg.str(),
					function);
}


// Functions to convert between steps and physical units
void XIMCThread::convert_steps2phys(int32_t steps, int32_t usteps, double &phys)const {
	phys = (double(steps) + double(usteps) / double(_microsteps)) / _conv_steps;
}

void XIMCThread::convert_steps2phys(uint32_t steps, uint32_t usteps, double &phys)const {
	phys = (double(steps) + double(usteps) / double(_microsteps)) / _conv_steps;
}

void XIMCThread::convert_phys2steps(double phys, int32_t &steps, int32_t &usteps)const {
	double stp = phys * _conv_steps;
	steps = int32_t(stp);
	usteps = int32_t((stp - steps) * _microsteps);
}

void XIMCThread::convert_phys2steps(double phys, uint32_t &steps, uint32_t &usteps)const {
	double stp = phys * _conv_steps;
	steps = uint32_t(stp);
	usteps = uint32_t((stp - steps) * _microsteps);
}


// Connect to and initialize a device
void XIMCThread::init_device() {
	// Open device
	_dev = ::open_device(_device_uri.c_str());
	if(_dev == device_undefined) {
		// Failed to open device
		stringstream msg;
		msg << "Failed to open device " << _device_uri;
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << msg.str() << endl;
		Tango::Except::throw_exception(
					(const char *)"Open device error",
					msg.str(),
					(const char *)"XIMCThread::init_device()");
	}

	// Reset all errors
	::command_stop(_dev);

	// Get velocity and acceleration from DB
	double vel = 0.0, acc = 0.0;
	if (Tango::Util::instance()->_UseDb==true) {
		Tango::DbData dev_prop;
		dev_prop.push_back(Tango::DbDatum("Velocity"));
		dev_prop.push_back(Tango::DbDatum("Acceleration"));
		_parent->get_db_device()->get_attribute_property(dev_prop);

		size_t i = 0;
		while(i < dev_prop.size()) {
			std::string pname = dev_prop[i].name;
			Tango::DevULong n = 0;
			dev_prop[i++] >> n;
			if(n > 0) {
				for(size_t k = 0; k < n; k++, i++) {
					if(pname == "Velocity" && dev_prop[i].name == "__value") {
						dev_prop[i] >> vel;
					} else if(pname == "Acceleration" && dev_prop[i].name == "__value") {
						dev_prop[i] >> acc;
					}
				}
			}
		}
	}

	// Get microstepping mode
	result_t r = result_ok;
	engine_settings_t engine;
	r = ::get_engine_settings(_dev, &engine);
	check_error_code(r, "read microstepping mode", "XIMCThread::init_device()");
	switch(engine.MicrostepMode) {
		default:
		case MICROSTEP_MODE_FULL:
			_microsteps = 1;
			break;
		case MICROSTEP_MODE_FRAC_2:
			_microsteps = 2;
			break;
		case MICROSTEP_MODE_FRAC_4:
			_microsteps = 4;
			break;
		case MICROSTEP_MODE_FRAC_8:
			_microsteps = 8;
			break;
		case MICROSTEP_MODE_FRAC_16:
			_microsteps = 16;
			break;
		case MICROSTEP_MODE_FRAC_32:
			_microsteps = 32;
			break;
		case MICROSTEP_MODE_FRAC_64:
			_microsteps = 64;
			break;
		case MICROSTEP_MODE_FRAC_128:
			_microsteps = 128;
			break;
		case MICROSTEP_MODE_FRAC_256:
			_microsteps = 256;
			break;
	}

	// Get motion settings
	r = ::get_move_settings(_dev, &_motion);
	check_error_code(r, "read motion settings", "XIMCThread::init_device()");

	uint32_t old_vel_s = _motion.Speed;
	uint32_t old_vel_us = _motion.uSpeed;
	uint32_t accel = _motion.Accel;
	uint32_t decel = _motion.Decel;

	// Restore velocity and acceleration
	bool updated = false;
	uint32_t v_steps, v_usteps;
	if(vel != 0.0) {
		convert_phys2steps(vel, v_steps, v_usteps);
		if(v_steps != _motion.Speed || v_usteps != _motion.uSpeed) {
			_motion.Speed = v_steps;
			_motion.uSpeed = v_usteps;
			updated = true;
		}
	}
	if(acc != 0.0) {
		uint32_t acc_us = 0;
		convert_phys2steps(acc, v_steps, v_usteps);
		if(v_steps != _motion.Accel) {
			_motion.Accel = v_steps;
			_motion.Decel = _motion.Accel;
			updated = true;
		}
	}

	// Update motion settings
	if(updated) {
		r = ::set_move_settings(_dev, &_motion);
		if(r != result_ok) {
			if(r == result_value_error) {
				// Bad saved velocity or acceleration
				_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Restore of velocity and acceleration failed for a bad value" << endl;
				// Restore old values
				_motion.Speed = old_vel_s;
				_motion.uSpeed = old_vel_us;
				_motion.Accel = accel;
				_motion.Decel = decel;
			} else {
				check_error_code(r, "restore motion settings", "XIMCThread::init_device()");
			}
		}
	}

	// Reference stage if needed
	status_t status;
	r = ::get_status(_dev, &status);
	check_error_code(r, "read status", "XIMCThread::init_device()");

	// Get feedback settings
	feedback_settings_t feedback;
	r = ::get_feedback_settings(_dev, &feedback);
	check_error_code(r, "read feedback settings", "XIMCThread::init_device()");

	if(_encoder) {
		if(feedback.FeedbackType != FEEDBACK_ENCODER) {
			// Enable encoder
			feedback.FeedbackType = FEEDBACK_ENCODER;
			r = ::set_feedback_settings(_dev, &feedback);
			check_error_code(r, "write feedback settings", "XIMCThread::init_device()");
		}
		_enc_enabled = true;
	} else {
		if(feedback.FeedbackType == FEEDBACK_ENCODER) {
			// Disable encoder
			feedback.FeedbackType = FEEDBACK_NONE;
			r = ::set_feedback_settings(_dev, &feedback);
			check_error_code(r, "write feedback settings", "XIMCThread::init_device()");
		}
		_enc_enabled = false;
	}

	if(_referenced) {
		if(!(status.Flags & STATE_IS_HOMED)) {
			// We need to search home to calibrate the stage
			_home_search = true;
		}
	}

	// Update firmware version
	unsigned int f_major, f_minor, f_release;
	r = get_firmware_version(_dev, &f_major, &f_minor, &f_release);
	if(r == result_ok) {
		stringstream firmware;
		firmware << f_major << "." << f_minor << "." << f_release;
		if(_parent->attr_FirmwareVersion_read[0]) {
			CORBA::string_free(_parent->attr_FirmwareVersion_read[0]);
		}
		_parent->attr_FirmwareVersion_read[0] = CORBA::string_dup(firmware.str().c_str());
	}
}


// Command STOP: stop all movements immediately
void XIMCThread::stop() {
	check_device();
	::command_stop(_dev);
}


// Command PWOF: turn off motor power
void XIMCThread::powerOff() {
	check_device();
	result_t r = ::command_power_off(_dev);
	check_error_code(r, "send power off command", "XIMCThread::powerOff()");
}


// Command MOVE: absolute move
void XIMCThread::moveAbs(double fpos) {
	// Convert position to steps
	int32_t pos = 0, upos = 0;
	if(_encoder) {
		pos = int32_t(fpos * _conv_enc);
	} else {
		convert_phys2steps(fpos, pos, upos);
	}
	// Move
	result_t r = command_move(_dev, pos, upos);
	check_error_code(r, "to move stage", "XIMCThread::moveAbs()");
}


// Command MOVR: relative move
void XIMCThread::moveRel(double fpos) {
	// Convert position to steps
	int32_t pos = 0, upos = 0;
	if(_encoder) {
		pos = int32_t(fpos * _conv_enc);
	} else {
		convert_phys2steps(fpos, pos, upos);
	}
	// Move
	result_t r = command_movr(_dev, pos, upos);
	check_error_code(r, "to move stage", "XIMCThread::moveRel()");
}


// Command HOME: go home
void XIMCThread::goHome() {
	_home_search = true;
}


// Wait for a move to finish
void XIMCThread::waitForMove(int timeout=10000) {
	result_t r = result_ok;
	status_t status;
	struct timeval begin, end;

	// Get start time
	gettimeofday(&begin, NULL);

	// Wait for the move to start
	msec_sleep(500);

	int last_pos = 0;
	do {
		// Sleep
		msec_sleep(200);
		// Get status
		r = ::get_status(_dev, &status);
		check_error_code(r, "to get status", "XIMCThread::waitForMove()");

		// Check that the stage is indeed moving
		if(status.CurPosition != last_pos) {
			// Stage moved, reset timeout
			gettimeofday(&begin, NULL);
			last_pos = status.CurPosition;
		}

		// If the position hasn't changed in the last 10 seconds, stop
		// NOTE: this is needed when encoder is enabled and no stage is connected. In this case the driver will try indefinitely to move the stage.
		gettimeofday(&end, NULL);
		int elapsed = ELAPSED_TIME_MS(begin, end);

		if(_parent->get_logger()->is_debug_enabled()) {
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Waiting for move (Move state: 0x" << std::hex << status.MoveSts << std::dec << ", Position: " << status.CurPosition << ", Elapsed: " << elapsed << " ms)" << endl;
		}

		if(elapsed > timeout) {
			r == ::command_stop(_dev);
			check_error_code(r, "to stop move", "XIMCThread::searchHome()");
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Move failed (timed out after " << double(timeout) / 1000.0 << " seconds)" << endl;
			Tango::Except::throw_exception(
					(const char *)"Move failed",
					(const char *)"Move timed out before completion (No device connected?)",
					(const char *)"XIMCThread::waitForMove()");
		}
	} while(status.MoveSts & MOVE_STATE_MOVING);
}


// Background search for home
void XIMCThread::searchHome() {

	result_t r = result_ok;
	status_t status;
	struct timeval begin, end;

	try {
		// NOTE: Configuration values from parent device
		// firstHomingSpeed -> speed for the first move (in steps/s)
		// secondHomingSpeed -> speed for the second move (in steps/s). This speed is used as first speed if fast homing is enabled.
		// useFastAlgorithm -> use fast algorithm
		// homingDirection -> False, move to the left (negative). True, move to the right (positive)
		// blindMoveBeforeHoming -> blind move to be done before starting home search procedure
		// homingDelta -> move to be done after reference to reach home position

		// Set parent status to INIT
		_parent->set_state(Tango::INIT);
		_is_homed = false;

		// Read old homing configuration
		home_settings_t old_hs;
		r = ::get_home_settings(_dev, &old_hs);
		check_error_code(r, "to get home configuration", "XIMCThread::searchHome()");

		// If a blind move before homing is needed
		if(_parent->blindMoveBeforeHoming != 0.0) {
			if(_parent->get_logger()->is_debug_enabled()) {
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Doing a blind move of " << _parent->blindMoveBeforeHoming << endl;
			}
			// Move
			this->moveRel(_parent->blindMoveBeforeHoming);
			waitForMove();
		}

		// Get status
		r = ::get_status(_dev, &status);
		check_error_code(r, "to get status", "XIMCThread::searchHome()");

		int move_delta = 0;
		if(_enc_enabled) {
			// Need to convert the steps to encoder counts (approx.)
			move_delta = _parent->firstHomingSpeed * _conv_enc / _conv_steps;
		} else {
			move_delta = _parent->firstHomingSpeed;
		}

		// Check if we are already on a limit switch (or otherwise the homing will fail)
		if( (_parent->homingDirection) && (status.GPIOFlags & STATE_RIGHT_EDGE) ) {
			// We are on the right edge with a right home movement (we must move a little bit to the left, negative move)
			if(_parent->get_logger()->is_debug_enabled())
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "On the RIGHT edge. Moving away before home search." << endl;
			gettimeofday(&begin, NULL);
			while(status.GPIOFlags & STATE_RIGHT_EDGE) {
				r = ::command_movr(_dev, -move_delta, 0);
				check_error_code(r, "to move stage", "XIMCThread::searchHome()");
				waitForMove();

				// Update status
				r = ::get_status(_dev, &status);
				check_error_code(r, "to get status", "XIMCThread::searchHome()");

				// Check for timeout (if no stage is connected, the search home will hang here forever)
				gettimeofday(&end, NULL);
				int elapsed = ELAPSED_TIME_MS(begin, end);
				if(elapsed > 10000) {
					_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to move away from RIGHT edge" << endl;
					Tango::Except::throw_exception(
						(const char *)"Move failed",
						(const char *)"Timed out while trying to move away from RIGHT edge (no device connected?)",
						(const char *)"XIMCThread::searchHome()");
				}
			}
		}
		if( !(_parent->homingDirection) && (status.GPIOFlags & STATE_LEFT_EDGE) ) {
			// We are on the left edge with a left home movement (we must move back a little bit to the right, positive move)
			if(_parent->get_logger()->is_debug_enabled())
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "On the LEFT edge. Moving away before home search." << endl;
			gettimeofday(&begin, NULL);
			while(status.GPIOFlags & STATE_LEFT_EDGE) {
				r = ::command_movr(_dev, move_delta, 0);
				check_error_code(r, "to move stage", "XIMCThread::searchHome()");
				waitForMove();

				// Update status
				r = ::get_status(_dev, &status);
				check_error_code(r, "to get status", "XIMCThread::searchHome()");

				// Check for timeout (if no stage is connected, the search home will hang here forever)
				gettimeofday(&end, NULL);
				int elapsed = ELAPSED_TIME_MS(begin, end);
				if(elapsed > 10000) {
					_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to move away from LEFT edge" << endl;
					Tango::Except::throw_exception(
						(const char *)"Move failed",
						(const char *)"Timed out while trying to move away from LEFT edge (no device connected?)",
						(const char *)"XIMCThread::searchHome()");
				}
			}
		}

		// Get current homing configuration
		home_settings_t hs;
		memset(&hs, 0, sizeof(home_settings_t));
		// Set stop on limit swith and direction
		hs.HomeFlags = HOME_STOP_FIRST_LIM | (_parent->homingDirection ? HOME_DIR_FIRST : 0);

		if(_enc_enabled) {
			// Homing settings with encoder (values must be converted to encoder steps and rpm)
			if(_parent->useFastAlgorithm) {
				// Fast algorithm enabled
				hs.HomeFlags |= HOME_USE_FAST;
				hs.FastHome = int(double(_parent->secondHomingSpeed) * double(_conv_enc) / double(_conv_steps) / 60.0);
				// We set home delta in the first move only if using the fast algorithm
				hs.HomeDelta = int(double(_parent->homingDelta) * double(_conv_enc) / double(_conv_steps));
			} else {
				// Standard algorithm
				hs.FastHome = int(double(_parent->firstHomingSpeed) * double(_conv_enc) / double(_conv_steps) / 60.0);
			}

		} else {
			// Homing settings without encoder
			if(_parent->useFastAlgorithm) {
				hs.HomeFlags |= HOME_USE_FAST;
				hs.FastHome = _parent->secondHomingSpeed;
				// We set home delta in the first move only if using the fast algorithm
				hs.HomeDelta = _parent->homingDelta;
			} else {
				hs.FastHome = _parent->firstHomingSpeed;
			}
		}

		if(_parent->get_logger()->is_debug_enabled()) {
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Homing parameters: speed(" << hs.FastHome << "), delta(" << hs.HomeDelta << "), flags(0x" << hex << hs.HomeFlags << ")" << endl;
		}

		// Setup settings for first move (or only move if fast algorithm is enabled)
		r = ::set_home_settings(_dev, &hs);
		check_error_code(r, "to store home settings", "XIMCThread::searchHome()");

		// Start first homing
		r = ::command_home(_dev);
		check_error_code(r, "to send home command", "XIMCThread::searchHome()");
		waitForMove();

		// Check if we need to do a second move
		if(!_parent->useFastAlgorithm) {
			// Move back a little to go away from the reference
			if(_enc_enabled) {
				// Need to convert the steps to encoder counts (approx.)
				move_delta = _parent->secondHomingSpeed * _conv_enc / _conv_steps * 10;
			} else {
				move_delta = _parent->secondHomingSpeed * 10;
			}

			if(_parent->get_logger()->is_debug_enabled()) {
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Moving back by " << move_delta << endl;
			}

			if(_parent->homingDirection) {
				r = ::command_movr(_dev, -move_delta, 0);
				check_error_code(r, "to move stage", "XIMCThread::searchHome()");
			} else {
				r = ::command_movr(_dev, move_delta, 0);
				check_error_code(r, "to move stage", "XIMCThread::searchHome()");
			}
			waitForMove();

			// Reset home configuration
			memset(&hs, 0, sizeof(home_settings_t));
			// Set stop on limit swith and direction
			hs.HomeFlags = HOME_STOP_FIRST_LIM | (_parent->homingDirection ? HOME_DIR_FIRST : 0);

			if(_enc_enabled) {
				// Homing settings with encoder (values must be converted to encoder steps and rpm)
				hs.FastHome = int(double(_parent->secondHomingSpeed) * double(_conv_enc) / double(_conv_steps) / 60.0);
				hs.HomeDelta = int(double(_parent->homingDelta) * double(_conv_enc) / double(_conv_steps));

			} else {
				// Homing settings without encoder
				hs.FastHome = _parent->secondHomingSpeed;
				hs.HomeDelta = _parent->homingDelta;
			}

			if(_parent->get_logger()->is_debug_enabled()) {
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Homing parameters: speed(" << hs.FastHome << "), delta(" << hs.HomeDelta << "), flags(0x" << hex << hs.HomeFlags << ")" << endl;
			}

			// Setup settings for second move
			r = ::set_home_settings(_dev, &hs);
			check_error_code(r, "to store home settings", "XIMCThread::searchHome()");

			// Start second homing
			r = ::command_home(_dev);
			check_error_code(r, "to send home command", "XIMCThread::searchHome()");
			waitForMove();
		}
		_home_search = false;
		_parent->set_state(Tango::STANDBY);

		// Set home position
		if(_parent->positionAtHome != 0) {
			set_position_t pos;
			if(_enc_enabled) {
				pos.Position = int32_t(_parent->positionAtHome * _conv_enc);
				pos.EncPosition = pos.Position;
			} else {
				pos.PosFlags = SETPOS_IGNORE_ENCODER;
				convert_phys2steps(_parent->positionAtHome, pos.Position, pos.uPosition);
			}
			r = ::set_position(_dev, &pos);
			check_error_code(r, "to set home position", "XIMCThread::searchHome()");

		} else {
			r = ::command_zero(_dev);
			check_error_code(r, "to set zero at home position", "XIMCThread::searchHome()");
		}

		// Restore old configuration
		r = ::set_home_settings(_dev, &old_hs);
		check_error_code(r, "to restore home settings", "XIMCThread::searchHome()");

	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Home search failed with error: " << e.errors[0].desc << endl;
		_parent->set_state(Tango::FAULT);
		delete_device();
		_home_search = false;
		Tango::Except::re_throw_exception(e,
				(const char *)"Home failed",
				(const char *)"Search for home failed",
				(const char *)"XIMCThread::searchHome()");
	}
}


// Command LEFT: start a continuous move to the left
void XIMCThread::moveLeft() {
	check_device();
	result_t r = ::command_left(_dev);
	check_error_code(r, "send move left command", "XIMCThread::moveLeft()");
}


// Command RIGT: start a continuous move to the right
void XIMCThread::moveRight() {
	check_device();
	result_t r = ::command_right(_dev);
	check_error_code(r, "send move right command", "XIMCThread::moveRight()");
}


// Command SSTP: soft stop (with deceleration)
void XIMCThread::softStop() {
	check_device();
	result_t r = ::command_sstp(_dev);
	check_error_code(r, "send soft stop command", "XIMCThread::softStop()");
}


// Command ZERO: set current position as zero
void XIMCThread::zero() {
	check_device();
	result_t r = ::command_zero(_dev);
	check_error_code(r, "send zero command", "XIMCThread::zero()");
}


// Get position
double XIMCThread::getPosition()const {
	double pos = 0.0;
	if(_encoder) {
		pos = double(_st_enc) / _conv_enc;
	} else {
		convert_steps2phys(_curr_pos, _curr_upos, pos);
	}
	return pos;
}


// Get current velocity
double XIMCThread::getVelocity()const {
	double vel;
	convert_steps2phys(_motion.Speed, _motion.uSpeed, vel);
	return vel;
}


// Set current velocity
void XIMCThread::setVelocity(double vel) {
	// Check device
	check_device();

	// Convert to steps
	uint32_t steps, usteps;
	convert_phys2steps(vel, steps, usteps);

	if(steps != _motion.Speed || usteps != _motion.uSpeed) {
		// Modified!
		uint32_t old_steps = _motion.Speed;
		uint32_t old_usteps = _motion.uSpeed;
		_motion.Speed = steps;
		_motion.uSpeed = usteps;
		// Write move settings
		result_t r = ::set_move_settings(_dev, &_motion);
		if(r != result_ok) {
			_motion.Speed = old_steps;
			_motion.uSpeed = old_usteps;
			check_error_code(r, "to set velocity", "XIMCThread::setVelocity()");
		}
	}
}


// Get current velocity
double XIMCThread::getAcceleration()const {
	double acc;
	convert_steps2phys(_motion.Accel, 0U, acc);
	return acc;
}


// Set current acceleration and deceleration
void XIMCThread::setAcceleration(double acc) {
	// Check device
	check_device();

	// Convert to steps
	uint32_t steps, usteps;
	convert_phys2steps(acc, steps, usteps);

	if(steps != _motion.Accel || steps != _motion.Decel) {
		// Modified!
		uint32_t old_accel = _motion.Accel;
		uint32_t old_decel = _motion.Decel;
		_motion.Accel = steps;
		_motion.Decel = steps;
		// Write move settings
		result_t r = ::set_move_settings(_dev, &_motion);
		if(r != result_ok) {
			_motion.Accel = old_accel;
			_motion.Decel = old_decel;
			check_error_code(r, "to set acceleration", "XIMCThread::setAcceleration()");
		}
	}
}


// Thread entry point
void* XIMCThread::run_undetached(void *arg) {

	struct timespec st = {0, 50000000};
	struct timeval begin, end;
	int fault_count = 0;

	// First run. Try to init device.
	try {
		init_device();
		_parent->set_state(Tango::STANDBY);
	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize device" << endl;
		_parent->set_state(Tango::FAULT);
	}

	// NOTE: variables to keep track of disabled alarms to log them only once
	unsigned int last_dis_alarm = 0;

	while(!_terminate) {

		// Get current time
		gettimeofday(&begin, NULL);

		if(_parent->get_state() != Tango::FAULT) {

			try {

				// Check if a home search is requested
				if(_home_search)
					searchHome();

				// Get device status
				status_t status;
				result_t r = ::get_status(_dev, &status);
				if(r != result_ok) {
					throw r;
				}

				if(_parent->get_logger()->is_debug_enabled()) {
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got stage status: ";
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Position: " << status.CurPosition;
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "USB: V(" << status.Uusb << ") I(" << status.Iusb << ")";
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Power: V(" << status.Upwr << ") I(" << status.Ipwr << ")";
				}

				// Update position
				bool pos_changed = false;
				if(_enc_enabled) {
					if(_st_enc != status.EncPosition) {
						_st_enc = status.EncPosition;
						pos_changed = true;
					}
				} else {
					if(_curr_pos != status.CurPosition || _curr_upos != status.uCurPosition) {
						_curr_pos = status.CurPosition;
						_curr_upos = status.uCurPosition;
						pos_changed = true;
					}
				}

				if(pos_changed) {
					_st_pos = getPosition();
					_parent->push_change_event("Position", &_st_pos);
				}

				bool curr_homed = (status.Flags & STATE_IS_HOMED) != 0;
				if(curr_homed != _is_homed) {
					_is_homed = curr_homed;
					_parent->push_change_event("Referenced", &_is_homed);
				}

				// Update variables and push change events
				float t_usb_v = float(status.Uusb) / 100.0;
				int t_usb_i = status.Iusb;
				float t_pwr_v = float(status.Upwr) / 100.0;
				int t_pwr_i = status.Ipwr;
				float t_temp = float(status.CurT) / 10.0;

				if(t_usb_v != _st_usb_v) {
					_st_usb_v = t_usb_v;
					_parent->push_change_event("USBvoltage", &_st_usb_v);
				}

				if(t_usb_i != _st_usb_i) {
					_st_usb_i = t_usb_i;
					_parent->push_change_event("USBcurrent", &_st_usb_i);
				}

				if(t_pwr_v != _st_pwr_v) {
					_st_pwr_v = t_pwr_v;
					_parent->push_change_event("PwrVoltage", &_st_pwr_v);
				}

				if(t_pwr_i != _st_pwr_i) {
					_st_pwr_i = t_pwr_i;
					_parent->push_change_event("PwrCurrent", &_st_pwr_i);
				}

				if(t_temp != _st_temp) {
					_st_temp = t_temp;
					_parent->push_change_event("Temperature", &_st_temp);
				}

				// Mask of alarm flags disabled because of spurious triggering
				unsigned int disabled_alarms = STATE_WINDING_RES_MISMATCH;  // NOTE: add here in OR other disabled alarms

				// Log disabled alarms
				unsigned int current_dis_alarm = status.Flags & disabled_alarms;
				if(current_dis_alarm) {
					if(current_dis_alarm != last_dis_alarm) {
						if(current_dis_alarm & STATE_WINDING_RES_MISMATCH) {
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Found resistance mismatch in motor windings." << endl;
						}
						// NOTE: add here logging of other disabled alarms
						last_dis_alarm = current_dis_alarm;
					}
				} else {
					last_dis_alarm = 0;
				}

				std::string msg = "";
				// Check alarm flags (we remove disabled alarms)
				if(status.Flags & (STATE_SECUR & ~disabled_alarms)) {
					// Check which flag is set
					msg += "Alarms found: ";
					if(status.Flags & STATE_ALARM) {
						msg += "generic, ";
					}
					if(status.Flags & STATE_CTP_ERROR) {
						msg += "position control error, ";
					}
					if(status.Flags & STATE_POWER_OVERHEAT) {
						msg += "power driver overheat, ";
					}
					if(status.Flags & STATE_CONTROLLER_OVERHEAT) {
						msg += "controller overheat, ";
					}
					if(status.Flags & STATE_OVERLOAD_POWER_VOLTAGE) {
						msg += "power driver overvoltage, ";
					}
					if(status.Flags & STATE_OVERLOAD_POWER_CURRENT) {
						msg += "power driver overcurrent, ";
					}
					if(status.Flags & STATE_OVERLOAD_USB_VOLTAGE) {
						msg += "USB overvoltage, ";
					}
					if(status.Flags & STATE_LOW_USB_VOLTAGE) {
						msg += "USB undervoltage, ";
					}
					if(status.Flags & STATE_OVERLOAD_USB_CURRENT) {
						msg += "USB overcurrent, ";
					}
					if(status.Flags & STATE_BORDERS_SWAP_MISSET) {
						msg += "engine stuck at the wrong edge, ";
					}
					if(status.Flags & STATE_LOW_POWER_VOLTAGE) {
						msg += "power driver undervoltage, ";
					}
					if(status.Flags & STATE_H_BRIDGE_FAULT) {
						msg += "power driver fault, ";
					}
					if(status.Flags & STATE_WINDING_RES_MISMATCH) {
						msg += "winding resistance mismatch, ";
					}
					if(status.Flags & STATE_ENCODER_FAULT) {
						msg += "encoder fault, ";
					}
					if(status.Flags & STATE_ENGINE_RESPONSE_ERROR) {
						msg += "engine response error, ";
					}
					if(status.Flags & STATE_EXTIO_ALARM) {
						msg += "external alarm signal, ";
					}
					msg = msg.substr(0, msg.size()-2) + ". ";
				}

				// Check motor power status
				if(_power_state != Tango::DevShort(status.PWRSts)) {
					_power_state = Tango::DevShort(status.PWRSts);
					_parent->push_change_event("PowerState", &_power_state);
				}

				if(msg != "") {
					_parent->set_state(Tango::ALARM);
					_parent->set_status(msg);

				} else {
					// If moving...
					if(status.MoveSts != 0) {
						_parent->set_state(Tango::MOVING);
					} else {
						_parent->set_state(Tango::STANDBY);
					}

					// Check limit switches
					if(status.GPIOFlags & STATE_RIGHT_EDGE) {
						_parent->set_status("Reached right edge");
					} else if(status.GPIOFlags & STATE_LEFT_EDGE) {
						_parent->set_status("Reached left edge");
					} else {
						_parent->set_status("");
					}
				}

			} catch(Tango::DevFailed &e) {
				// Error
				fault_count++;
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got error while updating status (Error was: " << e.errors[0].desc << ")" << endl;

			} catch(int &e) {
				// Libximc return error
				switch(e) {
					default:
					case result_error:
						// Generic error
						fault_count++;
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got libximc generic error while updating status" << endl;
						break;

					case result_not_implemented:
						// Function is not implemented
						fault_count++;
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got libximc not implemented error while updating status" << endl;
						break;

					case result_value_error:
						// Value error
						fault_count++;
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got libximc value error while updating status" << endl;
						break;

					case result_nodevice:
						// Device lost
						fault_count = 5;
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got libximc device lost error while updating status" << endl;
						break;
				}
			}
			if(fault_count > 4) {
				// Close device and set server state to fault
				delete_device();
				_parent->set_state(Tango::FAULT);
			}

		} else {
			// Device was not available... let's try to reconnect
			try {
				init_device();
				// Init was successful
				_parent->set_state(Tango::STANDBY);
				continue;

			} catch(Tango::DevFailed &e) {
				// Init failed. Sleep for 5 seconds before trying again
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize device" << endl;
				msec_sleep(5000);
			}
		}

		// Polling sleep
		gettimeofday(&end, NULL);
		int elapsed = ELAPSED_TIME_MS(begin, end);

		if(elapsed < (int)_parent->polling) {
			::msec_sleep((int)_parent->polling - elapsed);
		}
	}

	int *retval = NULL;
	return retval;
}


/*----- PROTECTED REGION END -----*/	//	XIMCSrv::namespace_ending
} //	namespace
