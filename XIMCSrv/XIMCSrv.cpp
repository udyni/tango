/*----- PROTECTED REGION ID(XIMCSrv.cpp) ENABLED START -----*/
// kate: replace-tabs off; indent-width 4; indent-mode cstyle; remove-trailing-spaces all; tab-indents on; tab-width 4; indent-width 4
//=============================================================================
//
// file :        XIMCSrv.cpp
//
// description : C++ source for the XIMCSrv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               XIMCSrv are implemented in this file.
//
// project :     Device server for XIMC controller
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <XIMCSrv.h>
#include <XIMCSrvClass.h>

/*----- PROTECTED REGION END -----*/	//	XIMCSrv.cpp

/**
 *  XIMCSrv class description:
 *    Device server for XIMC controllers like Standa 8SMC4-USB
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  GoHome        |  go_home
//  SetZero       |  set_zero
//  MoveAbsolute  |  move_absolute
//  MoveRelative  |  move_relative
//  PowerOff      |  power_off
//  MoveLeft      |  move_left
//  MoveRight     |  move_right
//  Stop          |  stop
//  Reset         |  reset
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  Position      |  Tango::DevFloat	Scalar
//  Velocity      |  Tango::DevFloat	Scalar
//  Temperature   |  Tango::DevFloat	Scalar
//  Acceleration  |  Tango::DevUShort	Scalar
//  USBvoltage    |  Tango::DevFloat	Scalar
//  USBcurrent    |  Tango::DevLong	Scalar
//  PwrVoltage    |  Tango::DevFloat	Scalar
//  PwrCurrent    |  Tango::DevLong	Scalar
//  PositionEnc   |  Tango::DevLong64	Scalar
//================================================================

namespace XIMCSrv_ns
{
/*----- PROTECTED REGION ID(XIMCSrv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	XIMCSrv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::XIMCSrv()
 *	Description : Constructors for a Tango device
 *                implementing the classXIMCSrv
 */
//--------------------------------------------------------
XIMCSrv::XIMCSrv(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(XIMCSrv::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::constructor_1
}
//--------------------------------------------------------
XIMCSrv::XIMCSrv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(XIMCSrv::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::constructor_2
}
//--------------------------------------------------------
XIMCSrv::XIMCSrv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(XIMCSrv::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void XIMCSrv::delete_device()
{
	DEBUG_STREAM << "XIMCSrv::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if(dev) {
		dev->terminate();
		int *retval;
		dev->join((void**)&retval);
		dev = NULL;
	}

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::delete_device
	delete[] attr_Position_read;
	delete[] attr_Velocity_read;
	delete[] attr_Temperature_read;
	delete[] attr_Acceleration_read;
	delete[] attr_USBvoltage_read;
	delete[] attr_USBcurrent_read;
	delete[] attr_PwrVoltage_read;
	delete[] attr_PwrCurrent_read;
	delete[] attr_PositionEnc_read;
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void XIMCSrv::init_device()
{
	DEBUG_STREAM << "XIMCSrv::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	struct timespec st = {0, 5000000};

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::init_device_before


	//	Get the device properties from database
	get_device_property();

	attr_Position_read = new Tango::DevFloat[1];
	attr_Velocity_read = new Tango::DevFloat[1];
	attr_Temperature_read = new Tango::DevFloat[1];
	attr_Acceleration_read = new Tango::DevUShort[1];
	attr_USBvoltage_read = new Tango::DevFloat[1];
	attr_USBcurrent_read = new Tango::DevLong[1];
	attr_PwrVoltage_read = new Tango::DevFloat[1];
	attr_PwrCurrent_read = new Tango::DevLong[1];
	attr_PositionEnc_read = new Tango::DevLong64[1];
	//	No longer if mandatory property not set.
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(XIMCSrv::init_device) ENABLED START -----*/

	//	Initialize device
	dev = new XIMCThread(proxy.c_str(), this);

	// Set device state
	set_state(Tango::STANDBY);

	// Get database instance
	Tango::DbDevice* db = NULL;
	if(Tango::Util::instance()->_UseDb==true) {
		db = get_db_device();
	}

	// Retrieve position value
	float pos = 0;
	if(db) {
		Tango::DbData dev_prop;
		dev_prop.push_back(Tango::DbDatum("Position"));
		db->get_attribute_property(dev_prop);
		if(dev_prop.size() > 1 && !dev_prop[0].is_empty()) {
			for(size_t i = 1; i < dev_prop.size(); i++) {
				if(dev_prop[i].name == "__value") {
					if(!(dev_prop[i] >> pos))
						pos = 0;
					break;
				}
			}
		}
	}

	// Restore velocity
	if(db) {
		Tango::DbData dev_prop;
		dev_prop.push_back(Tango::DbDatum("Velocity"));
		db->get_attribute_property(dev_prop);
		if(dev_prop.size() > 1 && !dev_prop[0].is_empty()) {
			for(size_t i = 1; i < dev_prop.size(); i++) {
				if(dev_prop[i].name == "__value") {
					float vel;
					if(dev_prop[i] >> vel)
						dev->setVelocity(vel);
					break;
				}
			}
		}
	}

	// Restore acceleration
	if(db) {
		Tango::DbData dev_prop;
		dev_prop.push_back(Tango::DbDatum("Acceleration"));
		db->get_attribute_property(dev_prop);
		if(dev_prop.size() > 1 && !dev_prop[0].is_empty()) {
			for(size_t i = 1; i < dev_prop.size(); i++) {
				if(dev_prop[i].name == "__value") {
					float acc;
					if(dev_prop[i] >> acc)
						dev->setAcceleration(acc);
					break;
				}
			}
		}
	}

	// If referenced, search for zero
	if(referenced) {
		// Search home position
		dev->goHome();

		// Wait 500ms
		st.tv_nsec = 500000000;
		nanosleep(&st, NULL);

		// Wait for the home search to finish
		while(get_state() == Tango::INIT)
			nanosleep(&st, NULL);

		// Set position to zero
		dev->zero();

		// Move to last known position
		this->move_absolute(pos);
	}

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void XIMCSrv::get_device_property()
{
	/*----- PROTECTED REGION ID(XIMCSrv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Proxy"));
	dev_prop.push_back(Tango::DbDatum("Referenced"));
	dev_prop.push_back(Tango::DbDatum("FirstHomingSpeed"));
	dev_prop.push_back(Tango::DbDatum("SecondHomingSpeed"));
	dev_prop.push_back(Tango::DbDatum("Polling"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on XIMCSrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		XIMCSrvClass	*ds_class =
			(static_cast<XIMCSrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Proxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxy;
		else {
			//	Try to initialize Proxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxy;
		}
		//	And try to extract Proxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxy;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize Referenced from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  referenced;
		else {
			//	Try to initialize Referenced from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  referenced;
		}
		//	And try to extract Referenced value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  referenced;

		//	Try to initialize FirstHomingSpeed from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  firstHomingSpeed;
		else {
			//	Try to initialize FirstHomingSpeed from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  firstHomingSpeed;
		}
		//	And try to extract FirstHomingSpeed value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  firstHomingSpeed;

		//	Try to initialize SecondHomingSpeed from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  secondHomingSpeed;
		else {
			//	Try to initialize SecondHomingSpeed from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  secondHomingSpeed;
		}
		//	And try to extract SecondHomingSpeed value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  secondHomingSpeed;

		//	Try to initialize Polling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  polling;
		else {
			//	Try to initialize Polling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  polling;
		}
		//	And try to extract Polling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  polling;

	}

	/*----- PROTECTED REGION ID(XIMCSrv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void XIMCSrv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		std::stringstream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(XIMCSrv::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	XIMCSrv::check_mandatory_property
	}
}


// //--------------------------------------------------------
/**
 *	Method      : XIMCSrv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void XIMCSrv::always_executed_hook()
{
// 	DEBUG_STREAM << "XIMCSrv::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"XIMCSrv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(XIMCSrv::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void XIMCSrv::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "XIMCSrv::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void XIMCSrv::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "XIMCSrv::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::write_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute Position related method
 *	Description: Position in steps
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Position(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Position(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Position) ENABLED START -----*/
	//	Set the attribute value
	*attr_Position_read = dev->getStatusPos();
	attr.set_value(attr_Position_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Position
}
//--------------------------------------------------------
/**
 *	Write attribute Position related method
 *	Description: Position in steps
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::write_Position(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::write_Position(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XIMCSrv::write_Position) ENABLED START -----*/

	this->move_absolute(w_val);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_Position
}
//--------------------------------------------------------
/**
 *	Read attribute Velocity related method
 *	Description: Velocity in steps/s
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Velocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Velocity(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Velocity) ENABLED START -----*/

	*attr_Velocity_read = dev->getVelocity();
	//	Set the attribute value
	attr.set_value(attr_Velocity_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Velocity
}
//--------------------------------------------------------
/**
 *	Write attribute Velocity related method
 *	Description: Velocity in steps/s
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::write_Velocity(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::write_Velocity(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XIMCSrv::write_Velocity) ENABLED START -----*/

	if(w_val < 0)
		Tango::Except::throw_exception(
			(const char *)"Value error",
			(const char *)"Velocity must be a positive value",
			(const char *)"XIMCSrv::write_Velocity()");

	// Set velocity
	dev->setVelocity(w_val);
	*attr_Velocity_read = dev->getVelocity();
	push_change_event("Velocity", attr_Velocity_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_Velocity
}
//--------------------------------------------------------
/**
 *	Read attribute Temperature related method
 *	Description: Controller temperature
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Temperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Temperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Temperature) ENABLED START -----*/

	*attr_Temperature_read = dev->getTemperature();
	//	Set the attribute value
	attr.set_value(attr_Temperature_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Temperature
}
//--------------------------------------------------------
/**
 *	Read attribute Acceleration related method
 *	Description: Acceleration and deceleration
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_Acceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_Acceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_Acceleration) ENABLED START -----*/

	*attr_Acceleration_read = dev->getAcceleration();
	//	Set the attribute value
	attr.set_value(attr_Acceleration_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_Acceleration
}
//--------------------------------------------------------
/**
 *	Write attribute Acceleration related method
 *	Description: Acceleration and deceleration
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::write_Acceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::write_Acceleration(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevUShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XIMCSrv::write_Acceleration) ENABLED START -----*/

	dev->setAcceleration(w_val);
	*attr_Acceleration_read = dev->getAcceleration();
	push_change_event("Acceleration", attr_Acceleration_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::write_Acceleration
}
//--------------------------------------------------------
/**
 *	Read attribute USBvoltage related method
 *	Description: USB voltage
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_USBvoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_USBvoltage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_USBvoltage) ENABLED START -----*/

	*attr_USBvoltage_read = dev->getUSB_V();
	//	Set the attribute value
	attr.set_value(attr_USBvoltage_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_USBvoltage
}
//--------------------------------------------------------
/**
 *	Read attribute USBcurrent related method
 *	Description: USB current
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_USBcurrent(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_USBcurrent(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_USBcurrent) ENABLED START -----*/

	*attr_USBcurrent_read = dev->getUSB_I();
	//	Set the attribute value
	attr.set_value(attr_USBcurrent_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_USBcurrent
}
//--------------------------------------------------------
/**
 *	Read attribute PwrVoltage related method
 *	Description: Motor power supply voltage
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_PwrVoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_PwrVoltage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_PwrVoltage) ENABLED START -----*/

	*attr_PwrVoltage_read = dev->getPWR_V();
	//	Set the attribute value
	attr.set_value(attr_PwrVoltage_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_PwrVoltage
}
//--------------------------------------------------------
/**
 *	Read attribute PwrCurrent related method
 *	Description: Motor supply current consumption
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_PwrCurrent(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_PwrCurrent(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_PwrCurrent) ENABLED START -----*/

	*attr_PwrCurrent_read = dev->getPWR_I();
	//	Set the attribute value
	attr.set_value(attr_PwrCurrent_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_PwrCurrent
}
//--------------------------------------------------------
/**
 *	Read attribute PositionEnc related method
 *	Description: Encoder position
 *
 *	Data type:	Tango::DevLong64
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XIMCSrv::read_PositionEnc(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XIMCSrv::read_PositionEnc(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::read_PositionEnc) ENABLED START -----*/

	*attr_PositionEnc_read = dev->getStatusPosEnc();
	//	Set the attribute value
	attr.set_value(attr_PositionEnc_read);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::read_PositionEnc
}

//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void XIMCSrv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(XIMCSrv::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command GoHome related method
 *	Description: Search home position
 *
 */
//--------------------------------------------------------
void XIMCSrv::go_home()
{
	DEBUG_STREAM << "XIMCSrv::GoHome()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::go_home) ENABLED START -----*/

	dev->goHome();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::go_home
}
//--------------------------------------------------------
/**
 *	Command SetZero related method
 *	Description: Set current position as zero
 *
 */
//--------------------------------------------------------
void XIMCSrv::set_zero()
{
	DEBUG_STREAM << "XIMCSrv::SetZero()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::set_zero) ENABLED START -----*/

	dev->zero();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::set_zero
}
//--------------------------------------------------------
/**
 *	Command MoveAbsolute related method
 *	Description: Move to an absolute position
 *
 *	@param argin Position (steps)
 */
//--------------------------------------------------------
void XIMCSrv::move_absolute(Tango::DevFloat argin)
{
	DEBUG_STREAM << "XIMCSrv::MoveAbsolute()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_absolute) ENABLED START -----*/

	dev->moveAbs(argin);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_absolute
}
//--------------------------------------------------------
/**
 *	Command MoveRelative related method
 *	Description: Move to an relative position
 *
 *	@param argin Position (steps)
 */
//--------------------------------------------------------
void XIMCSrv::move_relative(Tango::DevFloat argin)
{
	DEBUG_STREAM << "XIMCSrv::MoveRelative()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_relative) ENABLED START -----*/

	dev->moveRel(argin);

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_relative
}
//--------------------------------------------------------
/**
 *	Command PowerOff related method
 *	Description: Power off motor
 *
 */
//--------------------------------------------------------
void XIMCSrv::power_off()
{
	DEBUG_STREAM << "XIMCSrv::PowerOff()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::power_off) ENABLED START -----*/

	dev->powerOff();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::power_off
}
//--------------------------------------------------------
/**
 *	Command MoveLeft related method
 *	Description: Start continuous move to the left
 *
 */
//--------------------------------------------------------
void XIMCSrv::move_left()
{
	DEBUG_STREAM << "XIMCSrv::MoveLeft()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_left) ENABLED START -----*/

	dev->moveLeft();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_left
}
//--------------------------------------------------------
/**
 *	Command MoveRight related method
 *	Description: Start continuous move to the right
 *
 */
//--------------------------------------------------------
void XIMCSrv::move_right()
{
	DEBUG_STREAM << "XIMCSrv::MoveRight()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::move_right) ENABLED START -----*/

	dev->moveRight();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::move_right
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stop motion
 *
 */
//--------------------------------------------------------
void XIMCSrv::stop()
{
	DEBUG_STREAM << "XIMCSrv::Stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::stop) ENABLED START -----*/

	dev->softStop();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::stop
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset the controller sending a hard stop command
 *
 */
//--------------------------------------------------------
void XIMCSrv::reset()
{
	DEBUG_STREAM << "XIMCSrv::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XIMCSrv::reset) ENABLED START -----*/

	dev->stop();

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::reset
}
//--------------------------------------------------------
/**
 *	Method      : XIMCSrv::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void XIMCSrv::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(XIMCSrv::add_dynamic_commands) ENABLED START -----*/

	//	Add your own code to create and add dynamic commands if any

	/*----- PROTECTED REGION END -----*/	//	XIMCSrv::add_dynamic_commands
}

/*----- PROTECTED REGION ID(XIMCSrv::namespace_ending) ENABLED START -----*/

//	Additional Methods

// Constructor
XIMCThread::XIMCThread(const char* device, XIMCSrv *parent) :
		_parent(parent),
		_terminate(false),
		_home_search(false)
{
	struct timespec st = {0, 100*1000*1000};

	// Connect to proxy
	commdev = new Tango::DeviceProxy(device);
	commdev->command_inout("Flush");

	// Resync communication
	resync();

	// Reset all errors
	stop();
	nanosleep(&st, NULL);

	// Restore settings to default from flash
	restoreSettings();
	nanosleep(&st, NULL);

	// Update configuration structures
	updateConfig();
	nanosleep(&st, NULL);

	// Start status polling thread
	start_undetached();
}


// Convert command to string
const char* XIMCThread::cmd2string(uint32_t cmd) {
	static char buffer[5];
	for(size_t i = 0; i < 4; i++) {
		buffer[i] = uint8_t( (cmd & (0xFF << (8 * i))) >> (8 * i) );
	}
	buffer[4] = 0x00;
	return buffer;
}

// Send command to device
void XIMCThread::sendCommand(uint32_t cmd, const uint8_t* payload, size_t payload_len, uint8_t *rsp_payload, size_t& rsp_len) {

	// Allocate command buffer
	Tango::DevVarCharArray* argin = new Tango::DevVarCharArray();

	// Set buffer size
	if(payload && payload_len > 0)
		argin->length(4 + payload_len);
	else
		argin->length(4);

	// Get pointer
	uint8_t *ptr = argin->get_buffer();
	// Set command
	*((uint32_t*)ptr) = cmd;

	if(payload && payload_len > 0) {
		// If needed copy payload
		memcpy(ptr + 4, payload, payload_len);
	}

	// Debug messages
	if(_parent->get_logger()->is_debug_enabled()) {
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Sending command '" << cmd2string(cmd) << "' (" << std::hex << cmd << ") with " << std::dec << payload_len << " bytes of payload" << endl;
	}

	// Send raw command
	uint32_t rsp_cmd;
	try {
		// Lock Tango device
		omni_mutex_lock(this->_lock);

		{
			Tango::DeviceData din;
			din << argin;
			commdev->command_inout("Send", din);
		}

		// Read response code
		{
			Tango::DeviceData din;
			din << (Tango::DevLong)4;
			Tango::DeviceData dout = commdev->command_inout("Recv", din);

			// Extract response
			const Tango::DevVarCharArray* argout;
			if(dout >> argout) {
				rsp_cmd = *((uint32_t*)argout->get_buffer());
			} else {
				Tango::Except::throw_exception(
					(const char *)"Communication error",
					(const char *)"Failed to parse response",
					(const char *)"XIMCThread::sendCommand()");
			}
		}

	} catch(Tango::DevFailed &e) {
		resync();
		Tango::Except::re_throw_exception(e,
			(const char *)"Communication error",
			(const char *)"Failed to send command to device",
			(const char *)"XIMCThread::sendCommand()");
	}

	if(_parent->get_logger()->is_debug_enabled()) {
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got response code '" << cmd2string(rsp_cmd) << "' (" << std::hex << rsp_cmd << ") for command '" << cmd2string(cmd) << "' (" << cmd << ")" << endl;
	}

	if(rsp_cmd != cmd) {
		resync();
		// Check error code
		std::stringstream msg;
		msg << "Device failed to execute command: ";

		switch(rsp_cmd) {
			case XIMC_ERRC:
				msg << "command not recognized";
				break;
			case XIMC_ERRD:
				msg << "crc16 mismatch";
				break;
			case XIMC_ERRV:
				msg << "value error";
				break;
			default:
				msg << "unexpected response code (" << cmd2string(rsp_cmd) << ") for command (" << cmd2string(cmd) << ")";
				break;
		}
		Tango::Except::throw_exception(
			(const char *)"Device error",
			(const char *)msg.str().c_str(),
			(const char *)"XIMCThread::sendCommand()");
	}

	// If a payload is expected we should read it out
	if(rsp_len > 0 && rsp_payload) {
		try {
			// Lock Tango device
			omni_mutex_lock(this->_lock);

			Tango::DeviceData din;
			din << (Tango::DevLong)rsp_len;
			Tango::DeviceData dout = commdev->command_inout("Recv", din);

			// Read payload
			const Tango::DevVarCharArray* argout;
			if(dout >> argout) {
				// Check response length
				if(argout->length() <= 2 || argout->length() > rsp_len) {
					// Bad response!
					Tango::Except::throw_exception(
						(const char *)"Communication error",
						(const char *)"Response from device has wrong length",
						(const char *)"XIMCThread::sendCommand()");
				}

				// Copy response to output buffer
				memcpy(rsp_payload, argout->get_buffer(), argout->length());
				rsp_len = argout->length();
			} else {
				Tango::Except::throw_exception(
					(const char *)"Communication error",
					(const char *)"Failed to parse response",
					(const char *)"XIMCThread::sendCommand()");
			}

		} catch(Tango::DevFailed &e) {
			resync();
			Tango::Except::re_throw_exception(e,
				(const char *)"Communication error",
				(const char *)"Failed to get response payload",
				(const char *)"XIMCThread::sendCommand()");
		}
	}
}


// Resynchronize communication
bool XIMCThread::resync() {
	bool sync_done = false;
	try {
		for(size_t i = 0; i < 4; i++) {
			// Send 64 \0 bytes
			Tango::DevVarCharArray* argin = new Tango::DevVarCharArray(64);
			argin->length(64);
			memset(argin->get_buffer(), 0, 64);
			Tango::DeviceData din;
			din << argin;
			commdev->command_inout("Send", din);

			while(true) {
				// Get all the response bytes, searching for a \0
				try {
					Tango::DeviceData din;
					din << (Tango::DevLong)1;
					Tango::DeviceData dout = commdev->command_inout("Recv", din);
					const Tango::DevVarCharArray* argout;
					if(dout >> argout) {
						if(argout->length() > 0 && (*argout)[0] == '\0') {
							sync_done = true;
						}
					}
				} catch(Tango::DevFailed &e) {
					if(sync_done) {
						return true;
					}
					break;
				}
			}
		}
	} catch(Tango::DevFailed &e) {}
	return false;
}


// Command STOP: stop all movements immediately
void XIMCThread::stop() {
	size_t rsp_len = 0;
	sendCommand(XIMC_STOP, NULL, 0, NULL, rsp_len);
}


// Command PWOF: turn off motor power
void XIMCThread::powerOff() {
	size_t rsp_len = 0;
	sendCommand(XIMC_PWOF, NULL, 0, NULL, rsp_len);
}


// Command MOVE: absolute move
void XIMCThread::moveAbs(float fpos) {
	// Convert position
	position_t pos;
	pos.position = int32_t(fpos);
	pos.uposition = int16_t((fpos - float(pos.position)) * 256);
	moveAbs(pos);
}

void XIMCThread::moveAbs(const position_t& pos) {
	// Buffer
	uint8_t buffer[POSITION_T_LEN];

	// Serialize position struct
	serialize(&pos, buffer, POSITION_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_MOVE, buffer, POSITION_T_LEN, NULL, rsp_len);
}


// Command MOVR: relative move
void XIMCThread::moveRel(float fpos) {
	// Convert position
	position_t pos;
	pos.position = int32_t(fpos);
	pos.uposition = int16_t((fpos - float(pos.position)) * 256);
	moveRel(pos);
}

void XIMCThread::moveRel(const position_t& pos) {
	// Buffer
	uint8_t buffer[POSITION_T_LEN];

	// Serialize position struct
	serialize(&pos, buffer, POSITION_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_MOVR, buffer, POSITION_T_LEN, NULL, rsp_len);
}


// Command HOME: go home
void XIMCThread::goHome() {
	_home_search = true;
}


// Background search for home
void XIMCThread::searchHome() {
	struct timespec st = {0, 5000000};

	try {
		// Set parent status to INIT
		_parent->set_state(Tango::INIT);

		// Get current configuration
		home_settings_t hs = _home;

		// Set first moving speed
		hs.fast_home = _parent->firstHomingSpeed;
		hs.ufast_home = 0;
		hs.slow_home = 0;
		hs.uslow_home = 0;
		hs.flags &= ~HOME_MV_SEC_EN;

		// Update settings
		setHomeSettings(hs);
		nanosleep(&st, NULL);

		// Get status
		readStatus(_status);

		// Check if we are already on a limit switch
		if( (hs.flags & HOME_DIR_FIRST) && (_status.gpio_flags & STATE_RIGHT_EDGE) ) {
			// We are on the right edge with a right home movement (we must move a little bit to the left, positive move)
			position_t pos;
			memset(&pos, 0, sizeof(pos));
			pos.position = -100;
			while(_status.gpio_flags & STATE_RIGHT_EDGE) {
				moveRel(pos);
				// Wait for the move to start up to 500ms
				for(size_t i = 0; i < 100; i++) {
					readStatus(_status);
					if(_status.mcmd_sts & MVCMD_RUNNING)
						break;
					nanosleep(&st, NULL);
				}
				// Wait for the move to finish
				do {
					readStatus(_status);
					nanosleep(&st, NULL);
				} while(_status.mcmd_sts & MVCMD_RUNNING);
			}
		}
		if( !(hs.flags & HOME_DIR_FIRST) && (_status.gpio_flags & STATE_LEFT_EDGE) ) {
			position_t pos;
			memset(&pos, 0, sizeof(pos));
			pos.position = 100;
			// We are on the left edge with a left home movement (we must move back a little bit to the right, negative move)
			while(_status.gpio_flags & STATE_LEFT_EDGE) {
				moveRel(pos);
				// Wait for the move to start up to 500ms
				for(size_t i = 0; i < 100; i++) {
					readStatus(_status);
					if(_status.mcmd_sts & MVCMD_RUNNING)
						break;
					nanosleep(&st, NULL);
				}
				// Wait for the move to finish
				do {
					readStatus(_status);
					nanosleep(&st, NULL);
				} while(_status.mcmd_sts & MVCMD_RUNNING);
			}
		}

		// Start first home movement
		size_t rsp_len = 0;
		sendCommand(XIMC_HOME, NULL, 0, NULL, rsp_len);

		// Wait for the move to start up to 500ms
		for(size_t i = 0; i < 100; i++) {
			readStatus(_status);
			if(_status.mcmd_sts & MVCMD_RUNNING)
				break;
			nanosleep(&st, NULL);
		}
		// Wait for the move to finish
		do {
			readStatus(_status);
			nanosleep(&st, NULL);
		} while(_status.mcmd_sts & MVCMD_RUNNING);

		// In case we need a second home movement
		if(_parent->secondHomingSpeed != 0) {
			// Set second moving speed
			hs.fast_home = _parent->secondHomingSpeed;

			// Move for the 80% of delta in the right direction
			{
				position_t pos;
				memset(&pos, 0, sizeof(pos));
				if(hs.flags & HOME_DIR_FIRST) {
					pos.position = -int32_t(float(hs.home_delta) * 0.7);
				} else {
					pos.position = int32_t(float(hs.home_delta) * 0.7);
				}
				moveRel(pos);
				// Wait for the move to start up to 500ms
				for(size_t i = 0; i < 100; i++) {
					readStatus(_status);
					if(_status.mcmd_sts & MVCMD_RUNNING)
						break;
					nanosleep(&st, NULL);
				}
				// Wait for the move to finish
				do {
					readStatus(_status);
					nanosleep(&st, NULL);
				} while(_status.mcmd_sts & MVCMD_RUNNING);
			}

			// Update settings
			setHomeSettings(hs);
			nanosleep(&st, NULL);

			// Start second move
			rsp_len = 0;
			sendCommand(XIMC_HOME, NULL, 0, NULL, rsp_len);

			// Wait for the move to start up to 500ms
			for(size_t i = 0; i < 100; i++) {
				readStatus(_status);
				if(_status.mcmd_sts & MVCMD_RUNNING)
					break;
				nanosleep(&st, NULL);
			}
			// Wait for the move to finish
			do {
				readStatus(_status);
				nanosleep(&st, NULL);
			} while(_status.mcmd_sts & MVCMD_RUNNING);
		}

		_home_search = false;
		_parent->set_state(Tango::STANDBY);

	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Home search failed with error: " << e.errors[0].desc << endl;
		_parent->set_state(Tango::FAULT);
		_home_search = false;
	}
}


// Command LEFT: start a continuous move to the left
void XIMCThread::moveLeft() {
	size_t rsp_len = 0;
	sendCommand(XIMC_LEFT, NULL, 0, NULL, rsp_len);
}


// Command RIGT: start a continuous move to the right
void XIMCThread::moveRight() {
	size_t rsp_len = 0;
	sendCommand(XIMC_RIGT, NULL, 0, NULL, rsp_len);
}


// Command SSTP: soft stop (with deceleration)
void XIMCThread::softStop() {
	size_t rsp_len = 0;
	sendCommand(XIMC_SSTP, NULL, 0, NULL, rsp_len);
}


// Command GPOS: get position
void XIMCThread::getPosition(gposition_t& pos) {
	// Buffer
	uint8_t buffer[GPOSITION_T_LEN];

	// Send command
	size_t rsp_len = GPOSITION_T_LEN;
	sendCommand(XIMC_GPOS, NULL, 0, buffer, rsp_len);

	// Serialize position struct
	if(unserialize(&pos, buffer, GPOSITION_T_LEN) == -1) {
		Tango::Except::throw_exception(
			(const char *)"Communication error",
			(const char *)"CRC16 checksum mismatch",
			(const char *)"XIMCThread::getPosition()");
	}
}


// Command SPOS: set position
void XIMCThread::setPosition(const sposition_t& pos) {
	// Buffer
	uint8_t buffer[SPOSITION_T_LEN];

	// Serialize position struct
	serialize(&pos, buffer, SPOSITION_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_SPOS, buffer, SPOSITION_T_LEN, NULL, rsp_len);
}


// Command ZERO: set current position as zero
void XIMCThread::zero() {
	size_t rsp_len = 0;
	sendCommand(XIMC_ZERO, NULL, 0, NULL, rsp_len);
}


// Command READ: read settings from flash
void XIMCThread::restoreSettings() {
	size_t rsp_len = 0;
	sendCommand(XIMC_READ, NULL, 0, NULL, rsp_len);
}


// Command GETS: get controller status
void XIMCThread::readStatus(status_t& s) {
	// Buffer
	uint8_t buffer[STATUS_T_LEN];

	// Send command
	size_t rsp_len = STATUS_T_LEN;
	sendCommand(XIMC_GETS, NULL, 0, buffer, rsp_len);

	// Serialize position struct
	if(unserialize(&s, buffer, STATUS_T_LEN) == -1) {
		Tango::Except::throw_exception(
			(const char *)"Communication error",
			(const char *)"CRC16 checksum mismatch",
			(const char *)"XIMCThread::status()");
	}
}


// Command GFBS: get feedback settings
void XIMCThread::readFeedback(feedback_settings_t& fb) {
	// Buffer
	uint8_t buffer[FEEDBACK_SETTINGS_T_LEN];

	// Send command
	size_t rsp_len = FEEDBACK_SETTINGS_T_LEN;
	sendCommand(XIMC_GFBS, NULL, 0, buffer, rsp_len);

	// Serialize position struct
	if(unserialize(&fb, buffer, FEEDBACK_SETTINGS_T_LEN) == -1) {
		Tango::Except::throw_exception(
			(const char *)"Communication error",
			(const char *)"CRC16 checksum mismatch",
			(const char *)"XIMCThread::getFeedback()");
	}
}


// Command SFBS: set feedback settings
void XIMCThread::setFeedback(const feedback_settings_t& fb) {
	// Buffer
	uint8_t buffer[FEEDBACK_SETTINGS_T_LEN];

	// Serialize position struct
	serialize(&fb, buffer, FEEDBACK_SETTINGS_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_SFBS, buffer, FEEDBACK_SETTINGS_T_LEN, NULL, rsp_len);

	struct timespec st = {0, 5000000};
	nanosleep(&st, NULL);
	readFeedback(_feedback);
}


// Command GMOV: read setup movement (speed, acceleration, threshold and etc)
void XIMCThread::readMotionSettings(move_settings_t& mov) {
	// Buffer
	uint8_t buffer[MOVE_SETTINGS_T_LEN];

	// Send command
	size_t rsp_len = MOVE_SETTINGS_T_LEN;
	sendCommand(XIMC_GMOV, NULL, 0, buffer, rsp_len);

	// Serialize position struct
	if(unserialize(&mov, buffer, MOVE_SETTINGS_T_LEN) == -1) {
		Tango::Except::throw_exception(
			(const char *)"Communication error",
			(const char *)"CRC16 checksum mismatch",
			(const char *)"XIMCThread::getMotionSettings()");
	}
}


// Command SMOV: configure setup movement (speed, acceleration, threshold and etc)
void XIMCThread::setMotionSettings(const move_settings_t& mov) {
	// Buffer
	uint8_t buffer[MOVE_SETTINGS_T_LEN];

	// Serialize position struct
	serialize(&mov, buffer, MOVE_SETTINGS_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_SMOV, buffer, MOVE_SETTINGS_T_LEN, NULL, rsp_len);

	struct timespec st = {0, 5000000};
	nanosleep(&st, NULL);
	readMotionSettings(_motion);
}


// Command GENG: read engine settings
void XIMCThread::readEngineSettings(engine_settings_t& eng) {
	// Buffer
	uint8_t buffer[ENGINE_SETTINGS_T_LEN];

	// Send command
	size_t rsp_len = ENGINE_SETTINGS_T_LEN;
	sendCommand(XIMC_GENG, NULL, 0, buffer, rsp_len);

	// Serialize position struct
	if(unserialize(&eng, buffer, ENGINE_SETTINGS_T_LEN) == -1) {
		Tango::Except::throw_exception(
			(const char *)"Communication error",
			(const char *)"CRC16 checksum mismatch",
			(const char *)"XIMCThread::getEngineSettings()");
	}
}


// Command SENG: set engine settings
void XIMCThread::setEngineSettings(const engine_settings_t& eng) {
	// Buffer
	uint8_t buffer[ENGINE_SETTINGS_T_LEN];

	// Serialize position struct
	serialize(&eng, buffer, ENGINE_SETTINGS_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_SENG, buffer, ENGINE_SETTINGS_T_LEN, NULL, rsp_len);

	struct timespec st = {0, 5000000};
	nanosleep(&st, NULL);
	readEngineSettings(_engine);
}


// Command GHOM: read home settings
void XIMCThread::readHomeSettings(home_settings_t& home) {
	// Buffer
	uint8_t buffer[HOME_SETTINGS_T_LEN];

	// Send command
	size_t rsp_len = HOME_SETTINGS_T_LEN;
	sendCommand(XIMC_GHOM, NULL, 0, buffer, rsp_len);

	// Serialize position struct
	if(unserialize(&home, buffer, HOME_SETTINGS_T_LEN) == -1) {
		Tango::Except::throw_exception(
			(const char *)"Communication error",
			(const char *)"CRC16 checksum mismatch",
			(const char *)"XIMCThread::getHomeSettings()");
	}
}


// Command SHOM: set home settings
void XIMCThread::setHomeSettings(const home_settings_t& home) {
	// Buffer
	uint8_t buffer[HOME_SETTINGS_T_LEN];

	// Serialize position struct
	serialize(&home, buffer, HOME_SETTINGS_T_LEN);

	size_t rsp_len = 0;
	sendCommand(XIMC_SHOM, buffer, HOME_SETTINGS_T_LEN, NULL, rsp_len);

	struct timespec st = {0, 5000000};
	nanosleep(&st, NULL);
	readHomeSettings(_home);
}


// Update configuration structures
void XIMCThread::updateConfig() {
	try {
		// Get motion settings
		readMotionSettings(_motion);
		// Update engine settings
		readEngineSettings(_engine);
		// Get feedback settings
		readFeedback(_feedback);
		// Get homing settings
		readHomeSettings(_home);

	} catch(Tango::DevFailed &e) {
		Tango::Except::re_throw_exception(e,
			(const char *)"Update error",
			(const char *)"Update of configuration settings failed",
			(const char *)"XIMCThread::updateConfig()");
	}
}


// Set current velocity
void XIMCThread::setVelocity(float vel) {
	// Get current motion settings
	move_settings_t mov = getMotionSettings();

	// Modify velocity
	mov.speed = uint32_t(vel);
	mov.uspeed = uint16_t( (vel - float(mov.speed)) * 256 );

	// Write new settings
	setMotionSettings(mov);
}


// Set current acceleration and deceleration
void XIMCThread::setAcceleration(uint16_t acc) {

	// Get current motion settings
	move_settings_t mov = getMotionSettings();

	// Modify velocity
	mov.accel = acc;
	mov.decel = acc;

	// Write new settings
	setMotionSettings(mov);
}


// Thread entry point
void* XIMCThread::run_undetached(void *arg) {

	struct timespec st = {0, 50000000};
	struct timeval begin, end;
	int fault_count = 0;

	while(!_terminate) {
		try {
			// Get current time
			gettimeofday(&begin, NULL);

			// Check if a home search is requested
			if(_home_search)
				searchHome();

			// Read status from controller
			this->readStatus(_status);
			fault_count = 0;

			// Check if status was fault (connection lost)
			if(_parent->get_state() == Tango::FAULT) {
				// Update all the configuration structures
				this->updateConfig();
			}

			// Update variables and push change events
			float t_pos = float(_status.position) + float(_status.uposition) / 256.0;
			int64_t t_enc = _status.enc_position;
			float t_usb_v = float(_status.v_usb) / 100.0;
			int t_usb_i = _status.i_usb;
			float t_pwr_v = float(_status.v_pwr) / 100.0;
			int t_pwr_i = _status.i_pwr;
			float t_temp = float(_status.temp) / 10.0;

			if(t_pos != _st_pos) {
				_st_pos = t_pos;
				_parent->push_change_event("Position", &_st_pos);
			}

			if(t_enc != _st_enc) {
				_st_enc = t_enc;
				_parent->push_change_event("PositionEnc", &_st_enc);
			}

			if(t_usb_v != _st_usb_v) {
				_st_usb_v = t_usb_v;
				_parent->push_change_event("USBvoltage", &_st_usb_v);
			}

			if(t_usb_i != _st_usb_i) {
				_st_usb_i = t_usb_i;
				_parent->push_change_event("USBcurrent", &_st_usb_i);
			}

			if(t_pwr_v != _st_pwr_v) {
				_st_pwr_v = t_pwr_v;
				_parent->push_change_event("PwrVoltage", &_st_pwr_v);
			}

			if(t_pwr_i != _st_pwr_i) {
				_st_pwr_i = t_pwr_i;
				_parent->push_change_event("PwrCurrent", &_st_pwr_i);
			}

			if(t_temp != _st_temp) {
				_st_temp = t_temp;
				_parent->push_change_event("Temperature", &_st_temp);
			}

			std::string msg = "";
			// Check safety flags
			if(_status.flags & STATE_SECUR) {
				// Check which flag is set
				msg += "Alarms found: ";
				if(_status.flags & STATE_ALARM) {
					msg += "generic, ";
				}
				if(_status.flags & STATE_CTP_ERROR) {
					msg += "position control error, ";
				}
				if(_status.flags & STATE_POWER_OVERHEAT) {
					msg += "power driver overheat, ";
				}
				if(_status.flags & STATE_CONTROLLER_OVERHEAT) {
					msg += "controller overheat, ";
				}
				if(_status.flags & STATE_OVERLOAD_POWER_VOLTAGE) {
					msg += "power driver overvoltage, ";
				}
				if(_status.flags & STATE_OVERLOAD_POWER_CURRENT) {
					msg += "power driver overcurrent, ";
				}
				if(_status.flags & STATE_OVERLOAD_USB_VOLTAGE) {
					msg += "USB overvoltage, ";
				}
				if(_status.flags & STATE_LOW_USB_VOLTAGE) {
					msg += "USB undervoltage, ";
				}
				if(_status.flags & STATE_OVERLOAD_USB_CURRENT) {
					msg += "USB overcurrent, ";
				}
				if(_status.flags & STATE_BORDERS_SWAP_MISSET) {
					msg += "engine stuck at the wrong edge, ";
				}
				if(_status.flags & STATE_LOW_POWER_VOLTAGE) {
					msg += "power driver undervoltage, ";
				}
				if(_status.flags & STATE_H_BRIDGE_FAULT) {
					msg += "power driver fault, ";
				}
				msg = msg.substr(0, msg.size()-2) + ". ";
			}

			// Check encoder status
			if(_status.enc_sts == ENC_STATE_UNKNOWN) {
				msg += "Encoder in an unknown state. ";
			} else if(_status.enc_sts == ENC_STATE_MALFUNC) {
				msg += "Encoder is malfunctioning. ";
			}

			// Check motor windings
			/* !!! NOT IMPLEMENTED IN CONTROLLER !!!
			if((_status.wind_sts & 0x0F) != WIND_A_STATE_OK || (_status.wind_sts & 0xF0) != WIND_B_STATE_OK) {
				msg += "Detected winding fault: ";
				uint8_t wind_a = _status.wind_sts & 0x0F;
				uint8_t wind_b = _status.wind_sts & 0xF0;
				switch(wind_a) {
					case WIND_A_STATE_ABSENT:
						msg += "winding A absent, ";
						break;
					case WIND_A_STATE_UNKNOWN:
						msg += "winding A in an unknown state, ";
						break;
					case WIND_A_STATE_MALFUNC:
						msg += "winding A malfunction, ";
						break;
					default:
						break;
				}
				switch(wind_b) {
					case WIND_B_STATE_ABSENT:
						msg += "winding B absent, ";
						break;
					case WIND_B_STATE_UNKNOWN:
						msg += "winding B in an unknown state, ";
						break;
					case WIND_B_STATE_MALFUNC:
						msg += "winding B malfunction, ";
						break;
					default:
						break;
				}
				msg = msg.substr(0, msg.size()-2)) + ". ";
			}
			*/

			if(msg != "") {
				_parent->set_state(Tango::ALARM);
				_parent->set_status(msg);

			} else {
				// If moving...
				if(_status.move_sts != 0) {
					_parent->set_state(Tango::MOVING);
				} else {
					_parent->set_state(Tango::STANDBY);
				}

				// Check limit switches
				if(_status.gpio_flags & STATE_RIGHT_EDGE) {
					_parent->set_status("Reached right edge");
				} else if(_status.gpio_flags & STATE_LEFT_EDGE) {
					_parent->set_status("Reached left edge");
				} else {
					_parent->set_status("");
				}
			}

		} catch(Tango::DevFailed &e) {
			// Error
			fault_count++;
			if(fault_count < 4) {
				// Log error only for the first failures...
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Got error while updating status (Error was: " << e.errors[0].desc << ")" << endl;
			} else {
				_parent->set_state(Tango::FAULT);
				_parent->set_status("Communication with proxy device failed");
			}
		}

		// Polling sleep
		gettimeofday(&end, NULL);
		int elapsed = ELAPSED_TIME_MS(begin, end);

		if(elapsed < (int)_parent->polling) {
			int slp = (int)_parent->polling - elapsed;
			st.tv_sec = slp / 1000;
			st.tv_nsec = (slp % 1000) * 1000000;
			nanosleep(&st, NULL);
		}
	}

	int *retval = NULL;
	return retval;
}


/*----- PROTECTED REGION END -----*/	//	XIMCSrv::namespace_ending
} //	namespace
