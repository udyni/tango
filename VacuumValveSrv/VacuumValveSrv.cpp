/*----- PROTECTED REGION ID(VacuumValveSrv.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        VacuumValveSrv.cpp
//
// description : C++ source for the VacuumValveSrv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               VacuumValveSrv are implemented in this file.
//
// project :     Valve control server
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <VacuumValveSrv.h>
#include <VacuumValveSrvClass.h>

/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv.cpp

/**
 *  VacuumValveSrv class description:
 *    
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  Open          |  open
//  Close         |  close
//  Reset         |  reset
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  RawVoltage  |  Tango::DevDouble	Scalar
//  Pressure    |  Tango::DevDouble	Scalar
//================================================================

namespace VacuumValveSrv_ns
{
/*----- PROTECTED REGION ID(VacuumValveSrv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::VacuumValveSrv()
 *	Description : Constructors for a Tango device
 *                implementing the classVacuumValveSrv
 */
//--------------------------------------------------------
VacuumValveSrv::VacuumValveSrv(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(VacuumValveSrv::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::constructor_1
}
//--------------------------------------------------------
VacuumValveSrv::VacuumValveSrv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(VacuumValveSrv::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::constructor_2
}
//--------------------------------------------------------
VacuumValveSrv::VacuumValveSrv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(VacuumValveSrv::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void VacuumValveSrv::delete_device()
{
	DEBUG_STREAM << "VacuumValveSrv::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if(dev) {
		delete dev;
	}

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::delete_device
	delete[] attr_RawVoltage_read;
	delete[] attr_Pressure_read;
}

//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void VacuumValveSrv::init_device()
{
	DEBUG_STREAM << "VacuumValveSrv::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	dev = NULL;

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_RawVoltage_read = new Tango::DevDouble[1];
	attr_Pressure_read = new Tango::DevDouble[1];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(VacuumValveSrv::init_device) ENABLED START -----*/
	
	// Convert attribute names to lowercase
	::transform(analogIN.begin(), analogIN.end(), analogIN.begin(), ::tolower);
	::transform(gPIO_Device.begin(), gPIO_Device.end(), gPIO_Device.begin(), ::tolower);

	// Check that HardDisable flag is not set
	if(!hardDisable) {
		// Start monitoring thread
		dev = new ValveCallback(this);
	}

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void VacuumValveSrv::get_device_property()
{
	/*----- PROTECTED REGION ID(VacuumValveSrv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AnalogIN"));
	dev_prop.push_back(Tango::DbDatum("GPIO_Device"));
	dev_prop.push_back(Tango::DbDatum("GPIO_Check"));
	dev_prop.push_back(Tango::DbDatum("GPIO_Close"));
	dev_prop.push_back(Tango::DbDatum("GPIO_Command"));
	dev_prop.push_back(Tango::DbDatum("GPIO_Open"));
	dev_prop.push_back(Tango::DbDatum("ValveDelay"));
	dev_prop.push_back(Tango::DbDatum("HardDisable"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on VacuumValveSrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		VacuumValveSrvClass	*ds_class =
			(static_cast<VacuumValveSrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize AnalogIN from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  analogIN;
		else {
			//	Try to initialize AnalogIN from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  analogIN;
		}
		//	And try to extract AnalogIN value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  analogIN;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize GPIO_Device from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gPIO_Device;
		else {
			//	Try to initialize GPIO_Device from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gPIO_Device;
		}
		//	And try to extract GPIO_Device value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gPIO_Device;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize GPIO_Check from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gPIO_Check;
		else {
			//	Try to initialize GPIO_Check from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gPIO_Check;
		}
		//	And try to extract GPIO_Check value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gPIO_Check;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize GPIO_Close from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gPIO_Close;
		else {
			//	Try to initialize GPIO_Close from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gPIO_Close;
		}
		//	And try to extract GPIO_Close value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gPIO_Close;

		//	Try to initialize GPIO_Command from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gPIO_Command;
		else {
			//	Try to initialize GPIO_Command from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gPIO_Command;
		}
		//	And try to extract GPIO_Command value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gPIO_Command;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize GPIO_Open from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gPIO_Open;
		else {
			//	Try to initialize GPIO_Open from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gPIO_Open;
		}
		//	And try to extract GPIO_Open value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gPIO_Open;

		//	Try to initialize ValveDelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  valveDelay;
		else {
			//	Try to initialize ValveDelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  valveDelay;
		}
		//	And try to extract ValveDelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  valveDelay;

		//	Try to initialize HardDisable from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  hardDisable;
		else {
			//	Try to initialize HardDisable from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  hardDisable;
		}
		//	And try to extract HardDisable value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  hardDisable;

	}

	/*----- PROTECTED REGION ID(VacuumValveSrv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void VacuumValveSrv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(VacuumValveSrv::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void VacuumValveSrv::always_executed_hook()
{
// 	DEBUG_STREAM << "VacuumValveSrv::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"VacuumValveSrv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(VacuumValveSrv::always_executed_hook) ENABLED START -----*/

	if(hardDisable) {
		// The valve is disabled. Throw an exception.
		Tango::Except::throw_exception(
					(const char *)"Valve disabled",
					(const char *)"This valve is hard disabled and cannot be operated.",
					(const char *)"VacuumValveSrv::always_executed_hook()");
	}

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void VacuumValveSrv::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "VacuumValveSrv::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::read_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute RawVoltage related method
 *	Description: Raw analog reading
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void VacuumValveSrv::read_RawVoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "VacuumValveSrv::read_RawVoltage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::read_RawVoltage) ENABLED START -----*/

	// Get raw value
	if(dev)
		*attr_RawVoltage_read = dev->getAnalogRead();
	else
		*attr_RawVoltage_read = ::nan("");

	//	Set the attribute value
	attr.set_value(attr_RawVoltage_read);

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::read_RawVoltage
}
//--------------------------------------------------------
/**
 *	Read attribute Pressure related method
 *	Description: Pressure
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void VacuumValveSrv::read_Pressure(Tango::Attribute &attr)
{
	DEBUG_STREAM << "VacuumValveSrv::read_Pressure(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::read_Pressure) ENABLED START -----*/

	// Get raw value
	double val = ::nan("");
	if(dev)
		*attr_Pressure_read = dev->getPressure();

	//	Set the attribute value
	attr.set_value(attr_Pressure_read);

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::read_Pressure
}

//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void VacuumValveSrv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(VacuumValveSrv::add_dynamic_attributes) ENABLED START -----*/


	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Open related method
 *	Description: Open the valve
 *
 */
//--------------------------------------------------------
void VacuumValveSrv::open()
{
	DEBUG_STREAM << "VacuumValveSrv::Open()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::open) ENABLED START -----*/

	if(!dev)
		Tango::Except::throw_exception(
			(const char*)"No device",
			(const char*)"Cannot access valve low level device",
			(const char*)"VacuumValveSrv::Open()");
	dev->openValve();

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::open
}
//--------------------------------------------------------
/**
 *	Command Close related method
 *	Description: Close the valve
 *
 */
//--------------------------------------------------------
void VacuumValveSrv::close()
{
	DEBUG_STREAM << "VacuumValveSrv::Close()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::close) ENABLED START -----*/

	if(!dev)
		Tango::Except::throw_exception(
			(const char*)"No device",
			(const char*)"Cannot access valve low level device",
			(const char*)"VacuumValveSrv::Close()");
	dev->closeValve();

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::close
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset a fault condition
 *
 */
//--------------------------------------------------------
void VacuumValveSrv::reset()
{
	DEBUG_STREAM << "VacuumValveSrv::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(VacuumValveSrv::reset) ENABLED START -----*/

	if(!dev)
		Tango::Except::throw_exception(
			(const char*)"No device",
			(const char*)"Cannot access valve low level device",
			(const char*)"VacuumValveSrv::Reset()");
	dev->reset();

	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::reset
}
//--------------------------------------------------------
/**
 *	Method      : VacuumValveSrv::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void VacuumValveSrv::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(VacuumValveSrv::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::add_dynamic_commands
}

/*----- PROTECTED REGION ID(VacuumValveSrv::namespace_ending) ENABLED START -----*/

// Thread safe set_state
void VacuumValveSrv::safe_set_state(Tango::DevState state) {
	omni_mutex_lock(this->_state_lock);
	set_state(state);
}
// Thread safe set_status
void VacuumValveSrv::safe_set_status(const string &new_status) {
	omni_mutex_lock(this->_state_lock);
	set_status(new_status);
}

// Constructor
ValveCallback::ValveCallback(VacuumValveSrv* parent) :
	_parent(parent),
	_gpio_cmd(NULL),
	_gpio_chk(NULL),
	_gpio_opn(NULL),
	_gpio_cls(NULL),
	_analogin(NULL),
	_evid_cmd(-1),
	_evid_chk(-1),
	_evid_opn(-1),
	_evid_cls(-1),
	_evid_an(-1),
	_moving(false),
	_to_terminate(false),
	_to_th(NULL),
	_to_se(0),
	_analog_event(NULL),
	_analog_event_raw(NULL)
{
	// Lock the callback to be sure to end initialization before handling any event
	omni_mutex_lock(this->_ev_lock);

	_analog_read = ::nan("");
	char buffer[256];
	buffer[255] = '\0';

	// Allocate variable to propagate events
	_analog_event = new double(0.0);
	_analog_event_raw = new double(0.0);

	// Setup command GPIO
	setupGPIO(_parent->gPIO_Command, GPIO_OUTPUT, GPIO_NORMAL);
	setupGPIO(_parent->gPIO_Check, GPIO_INPUT, GPIO_NORMAL);
	setupGPIO(_parent->gPIO_Open, GPIO_INPUT, GPIO_INVERTED);
	setupGPIO(_parent->gPIO_Close, GPIO_INPUT, GPIO_INVERTED);

	// Command GPIO proxy
	snprintf(buffer, 255, "%s/b%02d", _parent->gPIO_Device.c_str(), _parent->gPIO_Command);
	_gpio_cmd = new Tango::AttributeProxy(buffer);
	_val_cmd = readGPIOAttr(_gpio_cmd);
	_val_cmd_w = _val_cmd.load();
	_evid_cmd = _gpio_cmd->subscribe_event(Tango::CHANGE_EVENT, this);

	// Relay check GPIO proxy
	snprintf(buffer, 255, "%s/b%02d", _parent->gPIO_Device.c_str(), _parent->gPIO_Check);
	_gpio_chk = new Tango::AttributeProxy(buffer);
	_val_chk = readGPIOAttr(_gpio_chk);
	_evid_chk = _gpio_chk->subscribe_event(Tango::CHANGE_EVENT, this);

	// Valve open status GPIO proxy
	snprintf(buffer, 255, "%s/b%02d", _parent->gPIO_Device.c_str(), _parent->gPIO_Open);
	_gpio_opn = new Tango::AttributeProxy(buffer);
	_val_opn = readGPIOAttr(_gpio_opn);
	_evid_opn = _gpio_opn->subscribe_event(Tango::CHANGE_EVENT, this);

	// Valve close status GPIO proxy
	snprintf(buffer, 255, "%s/b%02d", _parent->gPIO_Device.c_str(), _parent->gPIO_Close);
	_gpio_cls = new Tango::AttributeProxy(buffer);
	_val_cls = readGPIOAttr(_gpio_cls);
	_evid_cls = _gpio_cls->subscribe_event(Tango::CHANGE_EVENT, this);

	// Analog reading proxy
	_analogin = new Tango::AttributeProxy(_parent->analogIN);
	_evid_an = _analogin->subscribe_event(Tango::CHANGE_EVENT, this);

	if(_val_cmd && !_val_chk && _val_opn && !_val_cls) {
		_parent->safe_set_state(Tango::OPEN);
		_parent->safe_set_status("Valve is open");
	} else if (!_val_cmd && _val_chk && !_val_opn && _val_cls) {
		_parent->safe_set_state(Tango::CLOSE);
		_parent->safe_set_status("Valve is close");
	} else {
		_parent->safe_set_state(Tango::FAULT);
		TangoSys_OMemStream msg;
		msg << "Valve in fault state at init. (cmd=" << int(_val_cmd.load()) << ", chk=" << int(_val_chk.load()) << ", opn=" << int(_val_opn.load()) << ", cls=" << int(_val_cls.load()) << ")";
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << msg.str() << endl;
		_parent->safe_set_status(msg.str());
	}

	// Start timeout thread
	_to_th = new omni_thread(ValveCallback::checkTimeout, static_cast<void*>(this));
	_to_th->start();
}


// Destructor
ValveCallback::~ValveCallback() {
	// Unsubscribe from events
	if(_gpio_cmd)
		_gpio_cmd->unsubscribe_event(_evid_cmd);
	if(_gpio_chk)
		_gpio_chk->unsubscribe_event(_evid_chk);
	if(_gpio_opn)
		_gpio_opn->unsubscribe_event(_evid_opn);
	if(_gpio_cls)
		_gpio_cls->unsubscribe_event(_evid_cls);
	if(_analogin)
		_analogin->unsubscribe_event(_evid_an);

	// Terminate timeout thread
	_to_terminate = true;
	_to_se.post();
	int *retval;
	_to_th->join((void**)&retval);

	// Delete AttributeProxy
	if(_gpio_cmd)
		delete _gpio_cmd;
	if(_gpio_chk)
		delete _gpio_chk;
	if(_gpio_opn)
		delete _gpio_opn;
	if(_gpio_cls)
		delete _gpio_cls;
	if(_analogin)
		delete _analogin;
	if(_analog_event)
		delete _analog_event;
	if(_analog_event_raw)
		delete _analog_event_raw;
}


// Setup a GPIO pin
void ValveCallback::setupGPIO(int num, Tango::DevBoolean direction, Tango::DevBoolean polarity) {

	char buffer[32];
	buffer[31] = '\0';

	// Open GPIO device
	Tango::DeviceProxy* dev = new Tango::DeviceProxy(_parent->gPIO_Device);

	// Set direction
	{
		snprintf(buffer, 31, "d%02d", num);
		Tango::DeviceAttribute attr_in(buffer, direction);
		dev->write_attribute(attr_in);
	}

	// Set polarity
	{
		snprintf(buffer, 31, "p%02d", num);
		Tango::DeviceAttribute attr_in(buffer, polarity);
		dev->write_attribute(attr_in);
	}
}


// Read GPIO value
Tango::DevBoolean ValveCallback::readGPIOAttr(Tango::AttributeProxy* attr) {
	if(!attr)
		Tango::Except::throw_exception(
			(const char*)"Invalid object",
			(const char*)"Invalid AttributeProxy object",
			(const char*)"ValveCallback::readGPIOAttr()");

	Tango::DeviceAttribute attr_out = attr->read();
	Tango::DevBoolean val;
	if(attr_out >> val)
		return val;
	else
		Tango::Except::throw_exception(
			(const char*)"Read error",
			(const char*)"Cannot convert attribute value",
			(const char*)"ValveCallback::readGPIOAttr()");
}


// Open valve
void ValveCallback::openValve() {
	if(_parent->get_state() == Tango::FAULT) {
		Tango::Except::throw_exception(
			(const char*)"Cannot operate",
			(const char*)"Cannot operate valve when in fault state",
			(const char*)"ValveCallback::openValve()");
	}

	if(_moving.load()) {
		Tango::Except::throw_exception(
			(const char*)"Valve is opening",
			(const char*)"Cannot operate valve that is in a moving state",
			(const char*)"ValveCallback::openValve()");
	}

	// Check if the valve is closed
	if(_parent->get_state() == Tango::CLOSE) {
		if(_val_chk.load()) {
			// Relays are fine, open valve
			Tango::DeviceAttribute attr_in;
			attr_in << (Tango::DevBoolean)true;
			_gpio_cmd->write(attr_in);
			_val_cmd_w = true;
			start_timeout_thread();

		} else {
			// Relays are broken
			_parent->safe_set_state(Tango::FAULT);
			Tango::Except::throw_exception(
				(const char*)"Relays fault",
				(const char*)"Relays check failed",
				(const char*)"ValveCallback::openValve()");
		}
	} else {
		Tango::Except::throw_exception(
				(const char*)"Not closed",
				(const char*)"Cannot open a valve that is not closed",
				(const char*)"ValveCallback::openValve()");
	}
}


// Close valve
void ValveCallback::closeValve() {
	// Just in case, always write '0' when calling close.
	// Even if the valve is already closed or in falult, as it does not harm
	Tango::DeviceAttribute attr_in;
	attr_in << (Tango::DevBoolean)false;
	_gpio_cmd->write(attr_in);
	_val_cmd_w = false;

	if(_parent->get_state() == Tango::OPEN) {
		start_timeout_thread();
	}
}


// Reset fault
void ValveCallback::reset() {

	// Reconfigure GPIO to be sure that everything is fine...
	setupGPIO(_parent->gPIO_Command, GPIO_OUTPUT, GPIO_NORMAL);
	setupGPIO(_parent->gPIO_Check, GPIO_INPUT, GPIO_NORMAL);
	setupGPIO(_parent->gPIO_Open, GPIO_INPUT, GPIO_INVERTED);
	setupGPIO(_parent->gPIO_Close, GPIO_INPUT, GPIO_INVERTED);

	// Then re-read all the values
	_val_chk = readGPIOAttr(_gpio_chk);
	_val_opn = readGPIOAttr(_gpio_opn);
	_val_cls = readGPIOAttr(_gpio_cls);
	_val_cmd = readGPIOAttr(_gpio_cmd);

	if(!_val_cmd.load() && _val_cls.load() && _val_chk.load() && !_val_opn.load()) {
		_parent->safe_set_state(Tango::CLOSE);
		_parent->safe_set_status("Valve is close");
	} else if(_val_cmd.load() && !_val_cls.load() && !_val_chk.load() && _val_opn.load()) {
		_parent->safe_set_state(Tango::OPEN);
		_parent->safe_set_status("Valve is open");
	} else {
		_parent->safe_set_state(Tango::FAULT);
		TangoSys_OMemStream msg;
		msg << "Cannot reset fault as fault condition is not resolved (cmd=" << int(_val_cmd) << ", chk=" << int(_val_chk) << ", open=" << int(_val_opn) << ", close=" << int(_val_cls) << ")";
		_parent->safe_set_status(msg.str());
		_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << msg.str() << endl;
		Tango::Except::throw_exception(
			(const char*)"Reset failed",
			msg.str().c_str(),
			(const char*)"ValveCallback::reset()");
	}

	if(_parent->get_logger()->is_debug_enabled()) {
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Successfully reset valve status (cmd=" << int(_val_cmd.load()) << ", chk=" << int(_val_chk.load()) << ", opn=" << int(_val_opn.load()) << ", cls=" << int(_val_cls.load()) << ")" << endl;
	}
}


// Start the timeout thread
void ValveCallback::start_timeout_thread() {
	_moving = true;
	_parent->safe_set_state(Tango::MOVING);
	gettimeofday(&_timestamp, NULL);
	_to_se.post();
}


// Event callback
void ValveCallback::push_event(Tango::EventData* event) {
	try {
		// Lock
		omni_mutex_lock(this->_ev_lock);

		// Check for errors
		if(!event->err) {

			// Check if the event is empty
			if(event->attr_value->is_empty()) {
				if(_parent->get_logger()->is_debug_enabled()) {
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got an empty event from: " << event->attr_name << endl;
				}
				// Do nothing...
				return;
			}

			// Extract normalized Tango attribute name
			size_t pos = event->attr_name.find_last_of('/');
			string attr_name;
			if(pos != string::npos)
				attr_name = event->attr_name.substr(pos+1);
			else
				attr_name = event->attr_name;

			// Debug message to log events...
			if(_parent->get_logger()->is_debug_enabled()) {
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got event from: " << event->attr_name << "(" << attr_name << "), Type: " << event->event << endl;
			}

			// Check the source of the event
			if(_gpio_cmd && attr_name == _gpio_cmd->name()) {
				// Command GPIO
				Tango::DevBoolean val;
				if(*(event->attr_value) >> val) {

					// Debug...
					if(_parent->get_logger()->is_debug_enabled()) {
						_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got command GPIO event. Value: " << int(val) << endl;
					}

					// Valve command bit changed
					if(val != _val_cmd.load()) {
						// Store GPIO value
						_val_cmd = val;
						// Call status check function
						checkStatus();

					} else {
						// Spurious event (it will happen once when the device is started)
						_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Got a spurious command GPIO event (val: " << int(val) << ")" << endl;
					}
				} else {
					// Failed to parse value
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to convert value of event from: " << event->attr_name << endl;
				}

			} else if(_gpio_chk && attr_name == _gpio_chk->name()) {
				// Relay check GPIO
				Tango::DevBoolean val;
				if(*(event->attr_value) >> val) {

					// Debug...
					if(_parent->get_logger()->is_debug_enabled()) {
						_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got relay check GPIO event. Value: " << int(val) << endl;
					}

					if(val != _val_chk.load()) {
						if(_moving.load()) {
							// Valve operation in progress
							_val_chk = val;
							// Call status check function
							checkStatus();

						} else {
							// Unexpected event
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Got an unexpected change of relay check GPIO." << endl;
							// Check status anyway
							checkStatus();
						}
					} else {
						// Spurious event (it will happen once when the device is started)
						_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Got a spurious check GPIO event (val: " << int(val) << ")" << endl;
					}

				} else {
					// Failed to parse value
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to convert value of event from: " << event->attr_name << endl;
				}

			} else if(_gpio_opn && attr_name == _gpio_opn->name()) {
				// Open status GPIO
				Tango::DevBoolean val;
				if(*(event->attr_value) >> val) {

					// Debug...
					if(_parent->get_logger()->is_debug_enabled()) {
						_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got open status GPIO event. Value: " << int(val) << endl;
					}

					if(val != _val_opn.load()) {
						if(_moving.load()) {
							// Valve operation in progress
							_val_opn = val;
							// Call status check function
							checkStatus();

						} else {
							// Unexpected event
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Got an unexpected change of open status GPIO." << endl;
							// Check status anyway
							checkStatus();
						}

					} else {
						// Spurious event (it will happen once when the device is started)
						_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Got a spurious open status GPIO event (val: " << int(val) << ")" << endl;
					}

				} else {
					// Failed to parse value
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to convert value of event from: " << event->attr_name << endl;
				}

			} else if(_gpio_cls && attr_name == _gpio_cls->name()) {
				// Close status GPIO
				Tango::DevBoolean val;
				if(*(event->attr_value) >> val) {

					// Debug...
					if(_parent->get_logger()->is_debug_enabled()) {
						_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got close status GPIO event. Value: " << int(val) << endl;
					}

					if(val != _val_cls.load()) {
						if(_moving.load()) {
							// Valve operation in progress
							_val_cls = val;
							// Call status check function
							checkStatus();

						} else {
							// Unexpected event
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Got an unexpected change of close status GPIO." << endl;
							// Check status anyway
							checkStatus();
						}

					} else {
						// Spurious event (it will happen one when the device is started
						_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Got a spurious close status GPIO event (val: " << int(val) << ")" << endl;
					}

				} else {
					// Failed to parse value
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to convert value of event from: " << event->attr_name << endl;
				}

			} else if(_analogin && attr_name == _analogin->name()) {
				// Analog value
				Tango::DevDouble val = ::nan("");
				if(!(*(event->attr_value) >> val)) {
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to convert value of event from: " << event->attr_name << endl;
				}
				// Update value
				_analog_read = val;
				// Propagate change event
				*_analog_event = getPressure();
				_parent->push_change_event("Pressure", _analog_event);
				*_analog_event_raw = getAnalogRead();
				_parent->push_change_event("RawVoltage", _analog_event_raw);

			} else {
				// Unexpected event
				_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Unexpected event from attribute: " << event->attr_name << " (" << attr_name << "), type: " << event->event << endl;
				return;
			}

		} else {
			// Event with errors
			error_log_errorlist(_parent, "Got event with errors: ", event->errors);
		}
	} catch(Tango::DevFailed &e) {
		// Exception in event handler
		error_log_exception(_parent, "Exception while handling event: ", e);
	}
}


// Check valve status
void ValveCallback::checkStatus() {
	if(_moving.load()) {
		// Operation in progress
		if(_val_cmd.load() == _val_cmd_w.load()) {
			if(_val_cmd.load()) {
				// Open command confirmed
				if(!_val_chk.load() && _val_opn.load() && !_val_cls.load()) {
					// Done!
					_moving = false;
					_parent->safe_set_state(Tango::OPEN);
					_parent->safe_set_status("Valve is open");
				}

			} else {
				// Close command confirmed
				if(_val_chk.load() && !_val_opn.load() && _val_cls.load()) {
					// Done!
					_moving = false;
					_parent->safe_set_state(Tango::CLOSE);
					_parent->safe_set_status("Valve is close");
				}
			}

		} else {
			// Command still not confirmed. Check status based on what we have written
			if(_val_cmd_w.load()) {
				// Open command confirmed
				if(!_val_chk.load() && _val_opn.load() && !_val_cls.load()) {
					// Done!
					_moving = false;
					_parent->safe_set_state(Tango::OPEN);
					_parent->safe_set_status("Valve is open");
				}

			} else {
				// Close command confirmed
				if(_val_chk.load() && !_val_opn.load() && _val_cls.load()) {
					// Done!
					_moving = false;
					_parent->safe_set_state(Tango::CLOSE);
					_parent->safe_set_status("Valve is close");
				}
			}
		}

	} else {
		// Operation not in prograss. Something went wrong.
		// Check if the status is consistent with the reset function
		try {
			reset();
		} catch(Tango::DevFailed &e) {
			stringstream msg;
			msg << "Valve fault triggered by an unexpected event (CMD=" << int(_val_cmd.load()) << ", CHK=" << int(_val_chk.load());
			msg << ", OPN=" << int(_val_opn.load()) << ", CLS=" << int(_val_cmd.load()) << ")";
			_parent->safe_set_status(msg.str());
		}
	}
}


// Timeout check
void* ValveCallback::checkTimeout(void* arg) {

	// Cast parent object
	ValveCallback* parent = static_cast<ValveCallback*>(arg);

	if(parent->_parent->get_logger()->is_debug_enabled()) {
		parent->_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Started timeout thread" << endl;
	}

	struct timeval now;
	int elapsed = 0;

	while(true) {

		// Wait on the semaphore
		parent->_to_se.wait();

		// Check termination flag
		if(parent->_to_terminate.load()) {
			int *retval = new int(0);
			return (void*)retval;
		}

		// Check timeout
		while(parent->_moving.load()) {
			// Check time
			gettimeofday(&now, NULL);
			elapsed = ELAPSED_TIME_MS(parent->_timestamp, now);
			if(elapsed > parent->_parent->valveDelay) {
				// Timeout
				parent->_moving = false;
				parent->_parent->safe_set_state(Tango::FAULT);
				stringstream status;
				status << "Last valve operation timed out (State: CMD=" << int(parent->_val_cmd.load()) << ", CHK=" << int(parent->_val_chk.load());
				status << ", OPN=" << int(parent->_val_opn.load()) << ", CLS=" << int(parent->_val_cmd.load()) << ")";
				parent->_parent->safe_set_status(status.str());

			} else {
				msleep(parent->_parent->valveDelay / 10);
			}
		}

		if(parent->_parent->get_logger()->is_debug_enabled()) {
			gettimeofday(&now, NULL);
			parent->_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Timeout wait: " << (ELAPSED_TIME_MS(parent->_timestamp, now)) << " ms" << endl;
		}
	}
}


// Millisecond sleep
void ValveCallback::msleep(uint32_t msec) {
	if(msec <= 0)
		return;
	struct timespec st;
	struct timeval start, stop;
	gettimeofday(&start, NULL);
	// Setup delay
	st.tv_sec = msec / 1000;
	st.tv_nsec = (msec % 1000) * 1000000;

	while(1) {
		int ans = nanosleep(&st, NULL);
		if(ans == -1 && errno == EINTR) {
			// Nanosleep was interrupted by a signal
			gettimeofday(&stop, NULL);
			uint32_t rem = msec - ELAPSED_TIME_MS(start, stop);
			if(rem > 0) {
				st.tv_sec = rem / 1000;
				st.tv_nsec = (rem % 1000) * 1000000;
			} else {
				break;
			}
		} else {
			break;
		}
	}
}


	/*----- PROTECTED REGION END -----*/	//	VacuumValveSrv::namespace_ending
} //	namespace
