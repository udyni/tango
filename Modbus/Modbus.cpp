/*----- PROTECTED REGION ID(Modbus.cpp) ENABLED START -----*/
// kate: replace-tabs off; indent-width 4; indent-mode cstyle; remove-trailing-spaces all; tab-indents on; tab-width 4; indent-width 4
//=============================================================================
//
// file :        Modbus.cpp
//
// description : C++ source for the Modbus class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Modbus are implemented in this file.
//
// project :     Modbus
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author: pascal_verdier $
//
// $Revision: 1.5 $
// $Date: 2012-11-07 08:56:13 $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include <Modbus.h>
#include <ModbusClass.h>

/*----- PROTECTED REGION END -----*/	//	Modbus.cpp

/**
 *  Modbus class description:
 *    A Class to handle the modbus protocol over TCP/IP or Serial (RTU).
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name                   |  Method name
//================================================================
//  State                          |  Inherited (no method)
//  Status                         |  Inherited (no method)
//  ForceSingleCoil                |  force_single_coil
//  ReadCoilStatus                 |  read_coil_status
//  ReadInputStatus                |  read_input_status
//  ReadHoldingRegisters           |  read_holding_registers
//  ReadInputRegisters             |  read_input_registers
//  PresetSingleRegister           |  preset_single_register
//  ReadExceptionStatus            |  read_exception_status
//  FetchCommEventCtr              |  fetch_comm_event_ctr
//  ForceMultipleCoils             |  force_multiple_coils
//  ReadMultipleCoilsStatus        |  read_multiple_coils_status
//  PresetMultipleRegisters        |  preset_multiple_registers
//  MaskWriteRegister              |  mask_write_register
//  ReadWriteRegister              |  read_write_register
//  PresetSingleRegisterBroadcast  |  preset_single_register_broadcast
//  ReadInputRegistersUNS40        |  read_input_registers_uns40
//  ReadHoldingRegistersUNS40      |  read_holding_registers_uns40
//  PresetSingleRegisterUNS40      |  preset_single_register_uns40
//  ReadInputRegistersUNS32        |  read_input_registers_uns32
//  ReadHoldingRegistersUNS32      |  read_holding_registers_uns32
//  PresetSingleRegisterUNS32      |  preset_single_register_uns32
//  ReadInputString                |  read_input_string
//  ReadHoldingString              |  read_holding_string
//  PresetStringRegister           |  preset_string_register
//  ReadInputRegistersSIG16        |  read_input_registers_sig16
//  ReadInputRegistersFloat        |  read_input_registers_float
//  ForceSingleCoilAmplitude       |  force_single_coil_amplitude
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace Modbus_ns
{
/*----- PROTECTED REGION ID(Modbus::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	Modbus::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Modbus::Modbus()
 *	Description : Constructors for a Tango device
 *                implementing the classModbus
 */
//--------------------------------------------------------
Modbus::Modbus(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Modbus::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	Modbus::constructor_1
}
//--------------------------------------------------------
Modbus::Modbus(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(Modbus::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	Modbus::constructor_2
}
//--------------------------------------------------------
Modbus::Modbus(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(Modbus::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	Modbus::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Modbus::delete_device()
{
	DEBUG_STREAM << "Modbus::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::delete_device) ENABLED START -----*/

	//	Delete device's allocated object

	if (theThread != NULL)
	{
		{
			omni_mutex_lock sync(thCmdMutex);
			thCmd = SUICIDE;
		}

		void *ptr;
		theThread->join(&ptr);
	}

	for (size_t loop = 0;loop < cacheDef.size();loop++)
	{
		delete cacheDef[loop].data_block_mutex;
		if (cacheDef[loop].char_data_cache_ptr != NULL)
			delete cacheDef[loop].char_data_cache_ptr;
		if (cacheDef[loop].short_data_cache_ptr != NULL)
			delete cacheDef[loop].short_data_cache_ptr;
	}
	cacheDef.clear();

	if (modbusCore)
		delete modbusCore;

	/*----- PROTECTED REGION END -----*/	//	Modbus::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Modbus::init_device()
{
	DEBUG_STREAM << "Modbus::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	modbusCore = NULL;
	theThread = NULL;
	thId = -1;

	/*----- PROTECTED REGION END -----*/	//	Modbus::init_device_before


	//	Get the device properties from database
	get_device_property();


	/*----- PROTECTED REGION ID(Modbus::init_device) ENABLED START -----*/

	//	Initialize device

	// Check configuration
	if( get_protocol_number()==MBUS_TCP ) {
		if(iphost.length()==0) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_init",
					(const char *)"Iphost property must be defined for TCP protocol.",
					(const char *)"Modbus::init_device");
		}

	} else {

		if(serialline.length()==0) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_init",
					(const char *)"Serialline property must be defined for RTU protocol.",
					(const char *)"Modbus::init_device");
		}
	}

	// Create the modbus core object
	try {
		modbusCore = new ModbusCore(
							(char *)serialline.c_str(),
							get_protocol_number(),
							address,
							(char *)iphost.c_str(),
							socketConnectionSleep,
							tCPTimeout);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_init",
				(const char *)e.what(),
				(const char *)"Modbus::init_device");
	}

	set_status(modbusCore->Status());

	//
	// If the CacheConfig property is defined, check its validity
	//
	if (cacheConfig.empty() == false) {
		if ((cacheConfig.size() % 3) != 0) {
     		Tango::Except::throw_exception(
					(const char *)"Modbus_WrongProperty",
					(const char *)"The device CacheConfig property does not have a correct number of element. Must be a 3 multiple",
					(const char *)"Modbus::init_device");
		}

		long cached_block_nb = cacheConfig.size() / 3;
		for (long i = 0;i < cached_block_nb;i++) {
			string cmd = cacheConfig[i * 3];
			transform(cmd.begin(),cmd.end(),cmd.begin(),::tolower);
			if ((cmd != "readholdingregisters") &&
				(cmd != "readinputstatus") &&
				(cmd != "readinutregisters") &&
				(cmd != "readmultiplecoilsstatus"))
			{
				char tmp[256];
				sprintf(tmp,"The command %s is not supported to cache data",cacheConfig[i * 3].c_str());

				Tango::Except::throw_exception(
						(const char *)"Modbus_WrongProperty",
						(const char *)tmp,
						(const char *)"Modbus::init_device");
			}

			//
			// Check address definition
			//

			for (unsigned int j = 0;j < cacheConfig[(i * 3) + 1].size();j++) {
				if (isdigit(cacheConfig[(i * 3) + 1][j]) == 0) {
					char tmp[256];
					sprintf(tmp,"The string %s is not a valid address specification",cacheConfig[(i * 3) + 1].c_str());

					Tango::Except::throw_exception(
							(const char *)"Modbus_WrongProperty",
							(const char *)tmp,
							(const char *)"Modbus::init_device");
				}
			}
			short adr = (short)atoi(cacheConfig[(i * 3) + 1].c_str());

			//
			// Check data_nb definition
			//

			for (unsigned int j = 0;j < cacheConfig[(i * 3) + 2].size();j++) {
				if (isdigit(cacheConfig[(i * 3) + 2][j]) == 0) {
					char tmp[256];
					sprintf(tmp,"The string %s is not a valid data number specification",cacheConfig[(i * 3) + 2].c_str());

					Tango::Except::throw_exception(
							(const char *)"Modbus_WrongProperty",
							(const char *)tmp,
							(const char *)"Modbus::init_device");
				}
			}
			short nb_data = (short)atoi(cacheConfig[(i * 3) + 2].c_str());

			CacheDataBlock cdb;
			cdb.cmd_name = cmd;
			cdb.in_args.length(2);
			cdb.in_args[0] = adr;
			cdb.in_args[1] = nb_data;
			cdb.err = false;
			cdb.nb_sec = 0;
			cdb.data_block_mutex = new omni_mutex;

			if (cmd == "readinputstatus") {
				cdb.char_data_cache_ptr = new char [nb_data];
				cdb.short_data_cache_ptr = NULL;
			} else {
				cdb.short_data_cache_ptr = new short [nb_data];
				cdb.char_data_cache_ptr = NULL;
			}

			cacheDef.push_back(cdb);
		}

		//
		// Compute threshold to decide that the acquisition thread is dead
		// The (3 * 2) comes from the TCP connection algorithum which sometimes
		// wait 2 times for 2 sec
		//

		Tango::DevLong cacheSleep_sec = cacheSleep / 1000;
		if (cacheSleep_sec < 1)
			cacheSleep_sec = 1;
		maxDeltaTh = (3 * 2) + cacheSleep_sec * 3 + cacheDef.size() * tCPTimeout;

		//
		// Start thread
		//
		thCmd = RUN;
		theThread = new CacheThread(cacheDef,thCmdMutex,&thCmd,cacheSleep,this);
		theThread->start();
		thId = theThread->id();
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Modbus::get_device_property()
{
	/*----- PROTECTED REGION ID(Modbus::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members
	protocol = "RTU";
	address = 1;
	serialline = "";
	iphost = "";

	/*----- PROTECTED REGION END -----*/	//	Modbus::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Protocol"));
	dev_prop.push_back(Tango::DbDatum("Iphost"));
	dev_prop.push_back(Tango::DbDatum("Serialline"));
	dev_prop.push_back(Tango::DbDatum("Address"));
	dev_prop.push_back(Tango::DbDatum("CacheConfig"));
	dev_prop.push_back(Tango::DbDatum("CacheSleep"));
	dev_prop.push_back(Tango::DbDatum("SocketConnectionSleep"));
	dev_prop.push_back(Tango::DbDatum("TCPTimeout"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on ModbusClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		ModbusClass	*ds_class =
			(static_cast<ModbusClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Protocol from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  protocol;
		else {
			//	Try to initialize Protocol from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  protocol;
		}
		//	And try to extract Protocol value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  protocol;

		//	Try to initialize Iphost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  iphost;
		else {
			//	Try to initialize Iphost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  iphost;
		}
		//	And try to extract Iphost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  iphost;

		//	Try to initialize Serialline from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  serialline;
		else {
			//	Try to initialize Serialline from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  serialline;
		}
		//	And try to extract Serialline value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  serialline;

		//	Try to initialize Address from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  address;
		else {
			//	Try to initialize Address from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  address;
		}
		//	And try to extract Address value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  address;

		//	Try to initialize CacheConfig from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  cacheConfig;
		else {
			//	Try to initialize CacheConfig from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  cacheConfig;
		}
		//	And try to extract CacheConfig value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  cacheConfig;

		//	Try to initialize CacheSleep from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  cacheSleep;
		else {
			//	Try to initialize CacheSleep from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  cacheSleep;
		}
		//	And try to extract CacheSleep value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  cacheSleep;

		//	Try to initialize SocketConnectionSleep from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  socketConnectionSleep;
		else {
			//	Try to initialize SocketConnectionSleep from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  socketConnectionSleep;
		}
		//	And try to extract SocketConnectionSleep value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  socketConnectionSleep;

		//	Try to initialize TCPTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  tCPTimeout;
		else {
			//	Try to initialize TCPTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  tCPTimeout;
		}
		//	And try to extract TCPTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  tCPTimeout;

	}

	/*----- PROTECTED REGION ID(Modbus::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	Modbus::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Modbus::always_executed_hook()
{
// 	INFO_STREAM << "Modbus::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::always_executed_hook) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Modbus::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Modbus::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "Modbus::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Modbus::read_attr_hardware) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : Modbus::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Modbus::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Modbus::add_dynamic_attributes) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Modbus::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command ForceSingleCoil related method
 *	Description: Write single coil (digital I/O) state.
 *
 *	@param argin coil address, 0/1
 */
//--------------------------------------------------------
void Modbus::force_single_coil(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::ForceSingleCoil()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::force_single_coil) ENABLED START -----*/

	int error;
	short coil_address, coil_value;
	uint8_t query[5], response[5];

	check_argin(argin,2,"Modbus::force_single_coil");
	coil_address = (*argin)[0];
	coil_value = (*argin)[1];

	query[0] = FORCE_SINGLE_COIL;
	query[1] = coil_address >> 8;
	query[2] = coil_address & 0xff;
	if(coil_value) {
		query[3] = 0xff;
		query[4] = 0x00;
	} else {
		query[3] = 0x00;
		query[4] = 0x00;
	}

	try {
		modbusCore->SendGet(query, 5, response, 5);

	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::force_single_coil");
	}

	for (int i=0; i<5; i++) {
		if (query[i] != response[i]) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_write",
					(const char *)"Failed to force single coil (response not equal to query).",
					(const char *)"Modbus::force_single_coil");
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::force_single_coil
}
//--------------------------------------------------------
/**
 *	Command ReadCoilStatus related method
 *	Description: Read coil (digital I/O) status.
 *
 *	@param argin coil address
 *	@returns Coil status
 */
//--------------------------------------------------------
Tango::DevShort Modbus::read_coil_status(Tango::DevShort argin)
{
	Tango::DevShort argout;
	DEBUG_STREAM << "Modbus::ReadCoilStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_coil_status) ENABLED START -----*/

	int error;
	uint8_t query[5], response[1024];

	query[0] = READ_COIL_STATUS;
	query[1] = argin >> 8;
	query[2] = argin & 0xff;
	query[3] = 0;  // Read only one bit
	query[4] = 1;

	try {
		modbusCore->SendGet(query, 5, response, 3);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_read",
				(const char *)e.what(),
				(const char *)"Modbus::read_coil_status");
	}

	argout = (response[2] != 0) ? 1 : 0;

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_coil_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadInputStatus related method
 *	Description: Read discrete input status. Return one boolean per array element.
 *
 *	@param argin input address, no. of inputs
 *	@returns Input status.
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Modbus::read_input_status(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_status) ENABLED START -----*/

	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	argout  = new Tango::DevVarCharArray();

	int error;
	short input_address, no_inputs, byteidx;
	uint8_t bitmask, query[5], response[1024];

	check_argin(argin, 2, "Modbus::read_input_status");
	input_address = (*argin)[0];
	no_inputs = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if(th != 0) {
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readinputstatus",input_address,no_inputs);
	}

	if (data_block == -1) {
		omni_mutex_lock sync(this->ris_mutex);

		query[0] = READ_INPUT_STATUS;
		query[1] = input_address >> 8;
		query[2] = input_address & 0xff;
		query[3] = no_inputs >> 8;
		query[4] = no_inputs & 0xff;

		uint16_t no_bytes = (no_inputs+7)/8;
		try {
			modbusCore->SendGet(query, 5, response, no_bytes+2);
		} catch(ModbusException &e) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_read",
					(const char *)e.what(),
					(const char *)"Modbus::read_input_status");
		}

		argout->length(no_inputs);
		for(int i=0;i<no_inputs;i++) {
			bitmask = (1 << (i%8));
			byteidx = i/8 + 2;
			(*argout)[i] = (response[byteidx] & bitmask)?1:0;
		}

	} else {
		long start = input_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

			//
			// Check that the thread is still running
			//

			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh) {
				throw_ex = true;
			} else {
				// Get data or error code
				if (cacheDef[data_block].err == false) {
					argout->length(no_inputs);
					for (int i = 0;i < no_inputs;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				} else {
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true) {
			if (errs.length() == 0) {
				Tango::Except::throw_exception((const char *)"Modbus_ThNotRunning",
											   (const char *)"The thread acquiring data is not running any more",
											   (const char *)"Modbus::read_input_status");
			} else {
				throw Tango::DevFailed(errs);
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadHoldingRegisters related method
 *	Description: Read multiple 16bits registers.
 *
 *	@param argin register address, no. of registers
 *	@returns Holding 16bits register.
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_holding_registers(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadHoldingRegisters()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_holding_registers) ENABLED START -----*/

	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	argout  = new Tango::DevVarShortArray();

	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::read_holding_registers");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0) {
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readholdingregisters",register_address,no_registers);
	}

	if (data_block == -1) {
		omni_mutex_lock sync(this->rhr_mutex);

		query[0] = READ_HOLDING_REGISTERS;
		query[1] = register_address >> 8;
		query[2] = register_address & 0xff;
		query[3] = no_registers >> 8;
		query[4] = no_registers & 0xff;

		uint16_t no_bytes = no_registers * 2;
		try {
			modbusCore->SendGet(query, 5, response, no_bytes+2);
		} catch(ModbusException &e) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_read",
					(const char *)e.what(),
					(const char *)"Modbus::read_holding_registers");
		}
		argout->length(no_registers);
		for(int i=0; i < no_registers; i++)
			(*argout)[i] = (response[i*2+2] << 8) + response[i*2+3];

	} else {
		long start = register_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

			// Check that the thread is still running
			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh) {
				throw_ex = true;
			} else {
				// Get data or error code
				if (cacheDef[data_block].err == false) {
					argout->length(no_registers);
					for (int i = 0;i < no_registers;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				} else {
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true) {
			if (errs.length() == 0) {
				Tango::Except::throw_exception(
						(const char *)"Modbus_ThNotRunning",
						(const char *)"The thread acquiring data is not running any more",
						(const char *)"Modbus::read_holding_registers");
			} else {
				throw Tango::DevFailed(errs);
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_holding_registers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadInputRegisters related method
 *	Description: Read Multiple 16bits input registers.
 *
 *	@param argin register address, no. of registers
 *	@returns Input 16bits registers
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_input_registers(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputRegisters()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_registers) ENABLED START -----*/

	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------

	argout  = new Tango::DevVarShortArray();
	argout->length(1);
	(*argout)[0] = 0;

	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::read_input_registers");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0) {
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readinputregisters",register_address,no_registers);
	}

	if (data_block == -1) {
		omni_mutex_lock sync(this->rir_mutex);

		argout->length(no_registers);

		//---------------------------------------
		// A modbus response frame is limited to
		// 250 bytes.
		// Limiting the number of registers to
		// be read at 120 per call seems OK.
		#define MAX_NB_REG 120

    	int index = 0;

    	do {  // Do as many readouts as required.

			int nb_reg_to_get;  // The number of registers to be read at next call.

			if(no_registers > MAX_NB_REG)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG;
			else
				nb_reg_to_get = no_registers;

#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif

			query[0] = READ_INPUT_REGISTERS;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get >> 8;
			query[4] = nb_reg_to_get & 0xff;

			uint16_t no_bytes = nb_reg_to_get * 2;

			try {
				modbusCore->SendGet(query, 5, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadInputRegisters()");
			}

			for (int i=0; i < nb_reg_to_get; i++, index++)  // Copy received data to argout
				(*argout)[index] = (response[i*2+2] << 8) + response[i*2+3];

			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.

		} while(no_registers > 0);  // Still some registers to be read?

	} else {
		long start = register_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

			// Check that the thread is still running
			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh) {
				throw_ex = true;
			} else {
				// Get data or error code
				if (cacheDef[data_block].err == false) {
					argout->length(no_registers);
					for (int i = 0;i < no_registers;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				} else {
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true) {
			delete argout; // Avoid memory leak !
			if (errs.length() == 0) {
				Tango::Except::throw_exception(
						(const char *)"Modbus_ThNotRunning",
						(const char *)"The thread acquiring data is not running any more",
						(const char *)"Modbus::ReadInputRegisters()");
			} else {
				throw Tango::DevFailed(errs);
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_registers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetSingleRegister related method
 *	Description: Write single 16bits register.
 *
 *	@param argin Register address, register value.
 */
//--------------------------------------------------------
void Modbus::preset_single_register(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetSingleRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_single_register) ENABLED START -----*/

	int error;
	short register_address, value;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::preset_single_register");
	register_address = (*argin)[0];
	value = (*argin)[1];

	query[0] = PRESET_SINGLE_REGISTER;
	query[1] = register_address >> 8;
	query[2] = register_address & 0xff;
	query[3] = value >> 8;
	query[4] = value & 0xff;

	try {
		modbusCore->SendGet(query, 5, response, 5);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::preset_single_register");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_single_register
}
//--------------------------------------------------------
/**
 *	Command ReadExceptionStatus related method
 *	Description: Read exception status (usually a predefined range of 8 bits
 *
 *	@returns exception status
 */
//--------------------------------------------------------
Tango::DevShort Modbus::read_exception_status()
{
	Tango::DevShort argout;
	DEBUG_STREAM << "Modbus::ReadExceptionStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_exception_status) ENABLED START -----*/

	int error;
	uint8_t query[5], response[1024];

	query[0] = READ_EXCEPTION_STATUS;

	try {
		modbusCore->SendGet(query, 1, response, 2);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_read",
				(const char *)e.what(),
				(const char *)"Modbus::read_exception_status");
	}

	argout = (short)response[0];

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_exception_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command FetchCommEventCtr related method
 *	Description: Fetch communications event counter.
 *
 *	@returns status, event count
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::fetch_comm_event_ctr()
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::FetchCommEventCtr()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::fetch_comm_event_ctr) ENABLED START -----*/

	//	Add your own code
	//	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
	argout  = new Tango::DevVarShortArray();
	int error;
	uint8_t query[5], response[1024];

	query[0] = FETCH_COMM_EVENT_CTR;

	try {
		modbusCore->SendGet(query, 1, response, 5);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_read",
				(const char *)e.what(),
				(const char *)"Modbus::fetch_comm_event_ctr");
	}

	argout->length(2);
	(*argout)[0] = (response[0] << 8) + response[1];
	(*argout)[1] = (response[2] << 8) + response[3];

	/*----- PROTECTED REGION END -----*/	//	Modbus::fetch_comm_event_ctr
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ForceMultipleCoils related method
 *	Description: Write multiple coils (digital I/O) state.
 *               argin[0] = coil_address
 *               argin[1] = number of coils
 *               argin[2] = 1st coil state
 *               argin[3] = 2nd coil state
 *               ...
 *
 *	@param argin coil address, nb of coils, coil states
 */
//--------------------------------------------------------
void Modbus::force_multiple_coils(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::ForceMultipleCoils()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::force_multiple_coils) ENABLED START -----*/

	//	Add your own code
	int error;
	short coil_address, no_coils, byteidx;
	uint8_t bitmask, query[1024], response[1024];

	if(argin->length()<3) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)"At least 3 input arguments expected.",
				(const char *)"Modbus::force_multiple_coils");
	}

	coil_address = (*argin)[0];
	no_coils = (*argin)[1];

	check_argin(argin,2+no_coils,"Modbus::force_multiple_coils");

	memset(query,0,1024);
	query[0] = FORCE_MULTIPLE_COILS;
	query[1] = coil_address >> 8;
	query[2] = coil_address & 0xff;
	query[3] = no_coils >> 8;
	query[4] = no_coils & 0xff;
	query[5] = (no_coils+7)/8;
	for (int i=0; i<no_coils; i++) {
		bitmask = (1 << (i%8));
		byteidx = i/8 + 6;
		if((*argin)[2+i])
			query[byteidx] |= bitmask;
	}
	uint16_t no_bytes = 6+(no_coils+7)/8;

	try {
		modbusCore->SendGet(query, no_bytes, response, 5);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::force_multiple_coils");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::force_multiple_coils
}
//--------------------------------------------------------
/**
 *	Command ReadMultipleCoilsStatus related method
 *	Description: Read multiple coil (digital I/O) status.
 *               argin[0] = register address
 *               argin[1] = number of registers
 *
 *	@param argin coil address, nb of coils
 *	@returns Status of coils
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_multiple_coils_status(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadMultipleCoilsStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_multiple_coils_status) ENABLED START -----*/

	int error;
	short coil_address, no_coils;
	uint8_t query[1024], response[1024];

	if ( argin->length() != 2 ) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)"2 input arguments required.",
				(const char *)"Modbus::read_multiple_coils_status");
	}

	argout  = new Tango::DevVarShortArray();
	coil_address = (*argin)[0];
	no_coils     = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0) {
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readmultiplecoilsstatus",coil_address,no_coils);
	}

	if (data_block == -1) {
		omni_mutex_lock sync(this->rmcs_mutex);

		query[0] = READ_COIL_STATUS;
		query[1] = coil_address >> 8;
		query[2] = coil_address & 0xff;
		query[3] = no_coils >> 8;
		query[4] = no_coils & 0xff;

		uint16_t no_bytes = (no_coils+7)/8;
		DEBUG_STREAM << "no of bytes = " << no_bytes << endl;

		try {
			modbusCore->SendGet(query, 5, response, (no_bytes + 2));
		} catch(ModbusException &e) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_read",
					(const char *)e.what(),
					(const char *)"Modbus::read_multiple_coils_status");
		}

		argout->length(no_coils);

		for (size_t seq=0, idx=0 ; seq < no_bytes ; seq++) {
			uint8_t word = response[seq + 2];
			for (size_t i=0 ; (i < 8) && (idx < size_t(no_coils)); i++) {
				//DEBUG_STREAM << idx << ": " << word << " & " << (1<<i) << " = " << (word & 1<<i) << endl;
				uint8_t bit_value = (word & (1<<i)) >> i;

				(*argout)[idx] = (bit_value != 0) ? 1:0;
				idx++;
			}
		}
	} else {
		long start = coil_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

			// Check that the thread is still running
			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh) {
				throw_ex = true;
			} else {
				// Get data or error code
				if (cacheDef[data_block].err == false) {
					argout->length(no_coils);
					for (int i = 0;i < no_coils;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				} else {
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true) {
			if (errs.length() == 0) {
				Tango::Except::throw_exception(
						(const char *)"Modbus_ThNotRunning",
						(const char *)"The thread acquiring data is not running any more",
						(const char *)"Modbus::read_multiple_coils_status");
			} else {
				throw Tango::DevFailed(errs);
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_multiple_coils_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetMultipleRegisters related method
 *	Description: Write multiple 16bits registers.
 *               argin[0] = register address
 *               argin[1] = number of registers
 *               argin[2] = 1st register
 *               argin[3] = 2nd register
 *               ...
 *
 *	@param argin register address, nb of registers, register data
 */
//--------------------------------------------------------
void Modbus::preset_multiple_registers(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetMultipleRegisters()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_multiple_registers) ENABLED START -----*/

	int error;
	short register_address, no_registers;
	uint8_t query[1024], response[1024];

	if(argin->length()<3) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)"At least 3 input arguments expected.",
				(const char *)"Modbus::preset_multiple_registers");
	}

	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	check_argin(argin,2+no_registers,"Modbus::preset_multiple_registers");

	query[0] = PRESET_MULTIPLE_REGISTERS;
	query[1] = register_address >> 8;
	query[2] = register_address & 0xff;
	query[3] = no_registers >> 8;
	query[4] = no_registers & 0xff;
	query[5] = no_registers * 2;
	uint16_t no_bytes = 6;
	for (int i=0; i<no_registers; i++) {
		query[6+(i*2)]   = ((*argin)[2+i]) >> 8;
		no_bytes++;
		query[6+(i*2)+1] = ((*argin)[2+i]) & 0xff;
		no_bytes++;
	}

	try {
		modbusCore->SendGet(query, no_bytes, response, 5);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::preset_multiple_registers");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_multiple_registers
}
//--------------------------------------------------------
/**
 *	Command MaskWriteRegister related method
 *	Description: Mask write a 16bits register.
 *
 *	@param argin register address, AND mask, OR mask
 */
//--------------------------------------------------------
void Modbus::mask_write_register(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::MaskWriteRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::mask_write_register) ENABLED START -----*/

	int error;
	short register_address, and_mask, or_mask;
	uint8_t query[1024], response[1024];

	check_argin(argin,3,"Modbus::mask_write_register");
	register_address = (*argin)[0];
	and_mask = (*argin)[1];
	or_mask = (*argin)[2];

	query[0] = MASK_WRITE_REGISTER;
	query[1] = (*argin)[0] >> 8;
	query[2] = (*argin)[0] & 0xff;
	query[3] = (*argin)[1] >> 8;
	query[4] = (*argin)[1] & 0xff;
	query[5] = (*argin)[2] >> 8;
	query[6] = (*argin)[2] & 0xff;

	try {
		modbusCore->SendGet(query, 7, response, 6);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::mask_write_register");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::mask_write_register
}
//--------------------------------------------------------
/**
 *	Command ReadWriteRegister related method
 *	Description: Read and Write multiple 16bits registers.
 *               argin[0] = read address
 *               argin[1] = nb of registers to read
 *               argin[2] = write address,
 *               argin[3] = nb of registers to write,
 *               argin[4] = 1st register value to write
 *               argin[5] = 2nd register value to write
 *               ...
 *
 *	@param argin read address, no. to read, write address, nb.of write, write data
 *	@returns read registers
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_write_register(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadWriteRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_write_register) ENABLED START -----*/

	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	argout  = new Tango::DevVarShortArray();
	int error;
	uint16_t no_bytes, no_read_registers, no_write_registers;
	uint8_t query[1024], response[1024];

	if(argin->length()<5) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)"At least 5 input arguments expected.",
				(const char *)"Modbus::read_write_register");
	}

	no_read_registers = (*argin)[1];
	no_write_registers = (*argin)[3];
	no_bytes = 0;
	check_argin(argin,4+no_write_registers,"Modbus::read_write_register");

	query[no_bytes++] = READ_WRITE_REGISTERS;
	query[no_bytes++] = (*argin)[0] >> 8;           // Read address MSB
	query[no_bytes++] = (*argin)[0] & 0xff;         // Read address LSB
	query[no_bytes++] = no_read_registers >> 8;     // Word count for read MSB
	query[no_bytes++] = no_read_registers & 0xff;   // Word count for read LSB
	query[no_bytes++] = (*argin)[2] >> 8;           // Write address MSB
	query[no_bytes++] = (*argin)[2] & 0xff;         // Write address LSB
	query[no_bytes++] = no_write_registers >> 8;    // Word count for write MSB
	query[no_bytes++] = no_write_registers & 0xff;  // Word count for write LSB
	query[no_bytes++] = no_write_registers*2;       // Byte count
	for (size_t i=0; i<no_write_registers; i++) {
		query[no_bytes++] = (*argin)[i+4] >> 8;
		query[no_bytes++] = (*argin)[i+4] & 0xff;
	}

	try {
		modbusCore->SendGet(query, no_bytes, response, 2+no_read_registers*2);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::read_write_register");
	}

	if(no_read_registers != (short)(response[1]/2)) {
		char tmp[128];
		sprintf(tmp,"Wrong number of read registers. Got %d regs instead of %d", (int)(response[1]/2) , (int)(no_read_registers));
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_read",
				(const char *)tmp,
				(const char *)"Modbus::read_write_register");
	}

	argout->length(no_read_registers);
	for (size_t i=0; i<no_read_registers; i++) {
		(*argout)[i] = (response[i*2+2] << 8) + response[i*2+3];
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_write_register
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetSingleRegisterBroadcast related method
 *	Description: Write single 16bits register at address 0 (Address reserved for broadcast)
 *               Does not wait for the equipment response.
 *
 *	@param argin register value.
 */
//--------------------------------------------------------
void Modbus::preset_single_register_broadcast(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetSingleRegisterBroadcast()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_single_register_broadcast) ENABLED START -----*/

	int error;
	short register_address, value;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::preset_single_register_broadcast");
	register_address = (*argin)[0];
	value = (*argin)[1];

	query[0] = PRESET_SINGLE_REGISTER;
	query[1] = register_address >> 8;
	query[2] = register_address & 0xff;
	query[3] = value >> 8;
	query[4] = value & 0xff;

	try {
		modbusCore->Send(query, 5);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::preset_single_register_broadcast");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_single_register_broadcast
}
//--------------------------------------------------------
/**
 *	Command ReadInputRegistersUNS40 related method
 *	Description: Read unsigned 40bits input registers (Amplitude extension).
 *
 *	@param argin register address, nr. of registers
 *	@returns Input unsigned 40bits registers values
 */
//--------------------------------------------------------
Tango::DevVarULong64Array *Modbus::read_input_registers_uns40(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarULong64Array *argout;
	DEBUG_STREAM << "Modbus::ReadInputRegistersUNS40()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_registers_uns40) ENABLED START -----*/

	argout  = new Tango::DevVarULong64Array();
	argout->length(1);
	(*argout)[0] = 0;

	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::ReadInputRegistersUNS40()");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	{
		omni_mutex_lock sync(this->rir_mutex);

		argout->length(no_registers);

		//---------------------------------------
		// A modbus response frame is limited to
		// 250 bytes.
		// Limiting the number of registers to
		// be read at 50 per call seems OK.
		#define MAX_NB_REG_UNS40 50

    	int index = 0;

    	do {  // Do as many readouts as required.

			int nb_reg_to_get;  // The number of registers to be read at next call.

			if(no_registers > MAX_NB_REG_UNS40)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG_UNS40;
			else
				nb_reg_to_get = no_registers;

#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif

			query[0] = READ_INPUT_UNS40;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get & 0xff;

			uint16_t no_bytes = nb_reg_to_get * 5;

			try {
				modbusCore->SendGet(query, 4, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadInputRegistersUNS40()");
			}

			for (int i=0; i < nb_reg_to_get; i++, index++) { // Copy received data to argout
				uint64_t val = 0;
				uint8_t *val_ptr = (uint8_t*)&val;
				val_ptr[0] = response[i*5+6];
				val_ptr[1] = response[i*5+5];
				val_ptr[2] = response[i*5+4];
				val_ptr[3] = response[i*5+3];
				val_ptr[4] = response[i*5+2];
				(*argout)[index] = val;
			}

			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.

		} while(no_registers > 0);  // Still some registers to be read?

	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_registers_uns40
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadHoldingRegistersUNS40 related method
 *	Description: Read unsigned 40bits registers (Amplitude extension).
 *
 *	@param argin register address, nr. of registers
 *	@returns Holding unsigned 40bits registers values
 */
//--------------------------------------------------------
Tango::DevVarULong64Array *Modbus::read_holding_registers_uns40(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarULong64Array *argout;
	DEBUG_STREAM << "Modbus::ReadHoldingRegistersUNS40()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_holding_registers_uns40) ENABLED START -----*/

	argout  = new Tango::DevVarULong64Array();
	argout->length(1);
	(*argout)[0] = 0;

	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::ReadHoldingRegistersUNS40()");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	{
		omni_mutex_lock sync(this->rir_mutex);

		argout->length(no_registers);

    	int index = 0;

    	do {  // Do as many readouts as required.

			int nb_reg_to_get;  // The number of registers to be read at next call.

			if(no_registers > MAX_NB_REG_UNS40)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG_UNS40;
			else
				nb_reg_to_get = no_registers;

#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif

			query[0] = READ_HOLDING_UNS40;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get & 0xff;

			uint16_t no_bytes = nb_reg_to_get * 5;

			try {
				modbusCore->SendGet(query, 4, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadHoldingRegistersUNS40()");
			}

			for (int i=0; i < nb_reg_to_get; i++, index++) { // Copy received data to argout
				uint64_t val = 0;
				uint8_t *val_ptr = (uint8_t*)&val;
				val_ptr[0] = response[i*5+6];
				val_ptr[1] = response[i*5+5];
				val_ptr[2] = response[i*5+4];
				val_ptr[3] = response[i*5+3];
				val_ptr[4] = response[i*5+2];
				(*argout)[index] = val;
			}

			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.

		} while(no_registers > 0);  // Still some registers to be read?

	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_holding_registers_uns40
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetSingleRegisterUNS40 related method
 *	Description: Write single unsigned 40bits register (Amplitude extension).
 *
 *	@param argin Register address, register value.
 */
//--------------------------------------------------------
void Modbus::preset_single_register_uns40(const Tango::DevVarULong64Array *argin)
{
	DEBUG_STREAM << "Modbus::PresetSingleRegisterUNS40()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_single_register_uns40) ENABLED START -----*/

	int error;
	short register_address;
	uint64_t value;
	uint8_t query[5], response[1024];
	check_argin(argin, 2, "Modbus::PresetSingleRegisterUNS40");
	register_address = short((*argin)[0]);
	value = (*argin)[1];
	uint8_t* val_ptr = (uint8_t*)&value;

	query[0] = WRITE_HOLDING_UNS40;
	query[1] = register_address >> 8;
	query[2] = register_address & 0xff;
	query[3] = val_ptr[4];
	query[4] = val_ptr[3];
	query[5] = val_ptr[2];
	query[6] = val_ptr[1];
	query[7] = val_ptr[0];

	try {
		modbusCore->SendGet(query, 8, response, 8);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::PresetSingleRegisterUNS40");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_single_register_uns40
}
//--------------------------------------------------------
/**
 *	Command ReadInputRegistersUNS32 related method
 *	Description: Read unsigned 32bits input registers (Amplitude extension).
 *
 *	@param argin register address, nr. of registers
 *	@returns Input unsigned 32bits registers values
 */
//--------------------------------------------------------
Tango::DevVarULongArray *Modbus::read_input_registers_uns32(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarULongArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputRegistersUNS32()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_registers_uns32) ENABLED START -----*/

	argout  = new Tango::DevVarULongArray();
	argout->length(1);
	(*argout)[0] = 0;
	DEBUG_STREAM << "Modbus::ReadInputRegistersUNS32(): entering... !" << endl;
	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];
	check_argin(argin,2,"Modbus::ReadInputRegistersUNS32()");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];
	{
		omni_mutex_lock sync(this->rir_mutex);
		argout->length(no_registers);
		//---------------------------------------
		// A modbus response frame is limited to
		// 250 bytes.
		// Limiting the number of registers to
		// be read at 62 per call seems OK.
		#define MAX_NB_REG_UNS32 62
    	int index = 0;
    	do {  // Do as many readouts as required.
			int nb_reg_to_get;  // The number of registers to be read at next call.
			if(no_registers > MAX_NB_REG_UNS32)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG_UNS32;
			else
				nb_reg_to_get = no_registers;
#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif
			query[0] = READ_INPUT_UNS32;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get & 0xff;
			uint16_t no_bytes = nb_reg_to_get * 4;
			try {
				modbusCore->SendGet(query, 4, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadInputRegistersUNS32()");
			}
			for (int i=0; i < nb_reg_to_get; i++, index++) { // Copy received data to argout
				uint32_t val = 0;
				uint8_t *val_ptr = (uint8_t*)&val;
				val_ptr[0] = response[i*5+5];
				val_ptr[1] = response[i*5+4];
				val_ptr[2] = response[i*5+3];
				val_ptr[3] = response[i*5+2];
				(*argout)[index] = val;
			}
			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.
		} while(no_registers > 0);  // Still some registers to be read?
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_registers_uns32
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadHoldingRegistersUNS32 related method
 *	Description: Read unsigned 32bits registers (Amplitude extension).
 *
 *	@param argin register address, nr. of registers
 *	@returns Holding unsigned 32bits registers values
 */
//--------------------------------------------------------
Tango::DevVarULongArray *Modbus::read_holding_registers_uns32(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarULongArray *argout;
	DEBUG_STREAM << "Modbus::ReadHoldingRegistersUNS32()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_holding_registers_uns32) ENABLED START -----*/
	argout  = new Tango::DevVarULongArray();
	argout->length(1);
	(*argout)[0] = 0;
	DEBUG_STREAM << "Modbus::ReadHoldingRegistersUNS32(): entering... !" << endl;
	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];
	check_argin(argin,2,"Modbus::ReadHoldingRegistersUNS32()");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];
	{
		omni_mutex_lock sync(this->rir_mutex);
		argout->length(no_registers);
    	int index = 0;
    	do {  // Do as many readouts as required.
			int nb_reg_to_get;  // The number of registers to be read at next call.
			if(no_registers > MAX_NB_REG_UNS32)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG_UNS32;
			else
				nb_reg_to_get = no_registers;
#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif
			query[0] = READ_HOLDING_UNS32;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get & 0xff;
			uint16_t no_bytes = nb_reg_to_get * 4;
			try {
				modbusCore->SendGet(query, 4, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadHoldingRegistersUNS32()");
			}
			for (int i=0; i < nb_reg_to_get; i++, index++) { // Copy received data to argout
				uint32_t val = 0;
				uint8_t *val_ptr = (uint8_t*)&val;
				val_ptr[0] = response[i*5+5];
				val_ptr[1] = response[i*5+4];
				val_ptr[2] = response[i*5+3];
				val_ptr[3] = response[i*5+2];
				(*argout)[index] = val;
			}
			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.
		} while(no_registers > 0);  // Still some registers to be read?
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_holding_registers_uns32
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetSingleRegisterUNS32 related method
 *	Description: Write single unsigned 32bits register (Amplitude extension).
 *
 *	@param argin Register address, register value.
 */
//--------------------------------------------------------
void Modbus::preset_single_register_uns32(const Tango::DevVarULongArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetSingleRegisterUNS32()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_single_register_uns32) ENABLED START -----*/

	int error;
	short register_address;
	uint32_t value;
	uint8_t query[5], response[1024];
	check_argin(argin, 2, "Modbus::PresetSingleRegisterUNS32");
	register_address = short((*argin)[0]);
	value = (*argin)[1];
	uint8_t* val_ptr = (uint8_t*)&value;

	query[0] = WRITE_HOLDING_UNS32;
	query[1] = register_address >> 8;
	query[2] = register_address & 0xff;
	query[3] = val_ptr[3];
	query[4] = val_ptr[2];
	query[5] = val_ptr[1];
	query[6] = val_ptr[0];

	try {
		modbusCore->SendGet(query, 7, response, 7);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::PresetSingleRegisterUNS32");
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_single_register_uns32
}
//--------------------------------------------------------
/**
 *	Command ReadInputString related method
 *	Description: Read string input register (Amplitude extension).
 *
 *	@param argin register address
 *	@returns Input string register (up to 20 char ASCII)
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Modbus::read_input_string(Tango::DevShort argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputString()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_string) ENABLED START -----*/

	argout  = new Tango::DevVarCharArray();
	argout->length(20);
	for(int i = 0; i < 20; i++)
		(*argout)[i] = 0;

	int error;
	short register_address;
	uint8_t query[5], response[1024];
	register_address = argin;

	{
		omni_mutex_lock sync(this->rir_mutex);

		query[0] = READ_INPUT_STR20;
		query[1] = register_address >> 8;
		query[2] = register_address & 0xff;

		try {
			modbusCore->SendGet(query, 3, response, 20+2);
		} catch(ModbusException &e) {
			delete argout; // Avoid memory leak!
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_read",
					(const char *)e.what(),
					(const char *)"Modbus::ReadInputString()");
		}

		for (int i=0; i < 20; i++) { // Copy received data to argout
			(*argout)[i] = response[i+2];
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_string
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadHoldingString related method
 *	Description: Read string holding register (Amplitude extension).
 *
 *	@param argin register address
 *	@returns Holding string register (up to 20 char ASCII)
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Modbus::read_holding_string(Tango::DevShort argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Modbus::ReadHoldingString()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_holding_string) ENABLED START -----*/

	argout  = new Tango::DevVarCharArray();
	argout->length(20);
	for(int i = 0; i < 20; i++)
		(*argout)[i] = 0;

	int error;
	short register_address;
	uint8_t query[5], response[1024];
	register_address = argin;

	{
		omni_mutex_lock sync(this->rir_mutex);

		query[0] = READ_HOLDING_STR20;
		query[1] = register_address >> 8;
		query[2] = register_address & 0xff;

		try {
			modbusCore->SendGet(query, 3, response, 20+2);
		} catch(ModbusException &e) {
			delete argout; // Avoid memory leak!
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_read",
					(const char *)e.what(),
					(const char *)"Modbus::ReadHoldingString()");
		}

		for (int i=0; i < 20; i++) { // Copy received data to argout
			(*argout)[i] = response[i+2];
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_holding_string
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetStringRegister related method
 *	Description: Write string register (Amplitude extension).
 *
 *	@param argin Register address, register value (20 char ASCII as shorts)
 */
//--------------------------------------------------------
void Modbus::preset_string_register(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetStringRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_string_register) ENABLED START -----*/

	Tango::Except::throw_exception(
						(const char *)"Not implemented!",
						(const char *)"This function is not yet implemented",
						(const char *)"Modbus::PresetStringRegister()");

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_string_register
}
//--------------------------------------------------------
/**
 *	Command ReadInputRegistersSIG16 related method
 *	Description: Read signed 16bits input registers (Amplitude extension).
 *
 *	@param argin register address, nr. of registers
 *	@returns Input signed 16bits registers values
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_input_registers_sig16(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputRegistersSIG16()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_registers_sig16) ENABLED START -----*/

	argout  = new Tango::DevVarShortArray();
	argout->length(1);
	(*argout)[0] = 0;
	DEBUG_STREAM << "Modbus::ReadInputRegistersSIG16(): entering... !" << endl;

	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::ReadInputRegistersSIG16()");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	{
		omni_mutex_lock sync(this->rir_mutex);

		argout->length(no_registers);

		//---------------------------------------
		// A modbus response frame is limited to
		// 250 bytes.
		// Limiting the number of registers to
		// be read at 120 per call seems OK.
		#define MAX_NB_REG 120

    	int index = 0;

    	do {  // Do as many readouts as required.

			int nb_reg_to_get;  // The number of registers to be read at next call.

			if(no_registers > MAX_NB_REG)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG;
			else
				nb_reg_to_get = no_registers;

#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif

			query[0] = READ_INPUT_SIG16;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get >> 8;
			query[4] = nb_reg_to_get & 0xff;

			uint16_t no_bytes = nb_reg_to_get * 2;

			try {
				modbusCore->SendGet(query, 5, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadInputRegistersSIG16()");
			}

			for (int i=0; i < nb_reg_to_get; i++, index++) { // Copy received data to argout
				int16_t val = 0;
				uint8_t* val_ptr = (uint8_t*)&val;
				val_ptr[0] = response[i*2+3];
				val_ptr[1] = response[i*2+2];
				(*argout)[index] = val;
			}

			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.

		} while(no_registers > 0);  // Still some registers to be read?

	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_registers_sig16
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadInputRegistersFloat related method
 *	Description: Read float input registers (Amplitude extension).
 *
 *	@param argin register address, nr. of registers
 *	@returns Input float registers values
 */
//--------------------------------------------------------
Tango::DevVarFloatArray *Modbus::read_input_registers_float(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarFloatArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputRegistersFloat()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_registers_float) ENABLED START -----*/

	argout  = new Tango::DevVarFloatArray();
	argout->length(1);
	(*argout)[0] = 0;
	DEBUG_STREAM << "Modbus::ReadInputRegistersSIG16(): entering... !" << endl;

	int error;
	short register_address, no_registers;
	uint8_t query[5], response[1024];

	check_argin(argin,2,"Modbus::ReadInputRegistersSIG16()");
	register_address = (*argin)[0];
	no_registers = (*argin)[1];

	{
		omni_mutex_lock sync(this->rir_mutex);

		argout->length(no_registers);

		//---------------------------------------
		// A modbus response frame is limited to
		// 250 bytes.
		// Limiting the number of registers to
		// be read at 120 per call seems OK.
		#define MAX_NB_REG 120

    	int index = 0;

    	do {  // Do as many readouts as required.

			int nb_reg_to_get;  // The number of registers to be read at next call.

			if(no_registers > MAX_NB_REG)  // Check for limit.
				nb_reg_to_get = MAX_NB_REG;
			else
				nb_reg_to_get = no_registers;

#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif

			query[0] = READ_INPUT_FLOAT;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get >> 8;
			query[4] = nb_reg_to_get & 0xff;

			uint16_t no_bytes = nb_reg_to_get * 4;

			try {
				modbusCore->SendGet(query, 5, response, no_bytes+2);
			} catch(ModbusException &e) {
				delete argout; // Avoid memory leak !
				Tango::Except::throw_exception(
						(const char *)"Modbus::error_read",
						(const char *)e.what(),
						(const char *)"Modbus::ReadInputRegistersSIG16()");
			}

			for (int i=0; i < nb_reg_to_get; i++, index++) {  // Copy received data to argout
				float val = 0.0;
				uint8_t *val_ptr = (uint8_t*)&val;
				val_ptr[0] = response[i*5+5];
				val_ptr[1] = response[i*5+4];
				val_ptr[2] = response[i*5+3];
				val_ptr[3] = response[i*5+2];
				(*argout)[index] = val;
			}

			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.

		} while(no_registers > 0);  // Still some registers to be read?

	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_registers_float
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ForceSingleCoilAmplitude related method
 *	Description: Write single coil (digital I/O) state. Modified version to handle Amplitude broken protocol.
 *
 *	@param argin coil address, 0/1
 */
//--------------------------------------------------------
void Modbus::force_single_coil_amplitude(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::ForceSingleCoilAmplitude()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::force_single_coil_amplitude) ENABLED START -----*/
	int error;
	short coil_address, coil_value;
	uint8_t query[5], response[5];
	check_argin(argin,2,"Modbus::ForceSingleCoilAmplitude()");
	coil_address = (*argin)[0];
	coil_value = (*argin)[1];
	query[0] = FORCE_SINGLE_COIL;
	query[1] = coil_address >> 8;
	query[2] = coil_address & 0xff;
	if(coil_value) {
		query[3] = 0x00;
		query[4] = 0xff;
	} else {
		query[3] = 0x00;
		query[4] = 0x00;
	}
	try {
		modbusCore->SendGet(query, 5, response, 5);
	} catch(ModbusException &e) {
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)e.what(),
				(const char *)"Modbus::ForceSingleCoilAmplitude()");
	}
	for (int i=0; i<5; i++) {
		if (query[i] != response[i]) {
			Tango::Except::throw_exception(
					(const char *)"Modbus::error_write",
					(const char *)"Failed to force single coil (response not equal to query).",
					(const char *)"Modbus::ForceSingleCoilAmplitude()");
		}
	}
	/*----- PROTECTED REGION END -----*/	//	Modbus::force_single_coil_amplitude
}

/*----- PROTECTED REGION ID(Modbus::namespace_ending) ENABLED START -----*/

//	Additional Methods
//------------------------------------------------------------

// method: get_protocol_number
//
// Descr: Return the protocol id according to the resource string.
//------------------------------------------------------------
int Modbus::get_protocol_number() {

#ifdef WIN32
	if (_stricmp(protocol.c_str(),"rtu")   == 0)
		return MBUS_RTU;

	if (_stricmp(protocol.c_str(),"ascii") == 0)
		return MBUS_ASCII;

	if (_stricmp(protocol.c_str(),"tcp")   == 0)
		return MBUS_TCP;
#else
	if (strcasecmp(protocol.c_str(),"rtu")   == 0)
		return MBUS_RTU;

	if (strcasecmp(protocol.c_str(),"ascii") == 0)
		return MBUS_ASCII;

	if (strcasecmp(protocol.c_str(),"tcp")   == 0)
		return MBUS_TCP;
#endif
	return -1;
}

//------------------------------------------------------------
// Check if argin has the expected length and throw DevFailed
// in case of error.
//------------------------------------------------------------
void Modbus::check_argin(const Tango::DevVarShortArray *argin,int lgth,const char *where) {

	char tmp[256];

	if (argin->length() != (unsigned int)lgth) {
		sprintf(tmp,"Incorrect number of input arguments (%d expected)",lgth);
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)tmp,
				(const char *)where);
	}
}
void Modbus::check_argin(const Tango::DevVarULong64Array *argin,int lgth,const char *where) {

	char tmp[256];

	if (argin->length() != (unsigned int)lgth) {
		sprintf(tmp,"Incorrect number of input arguments (%d expected)",lgth);
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)tmp,
				(const char *)where);
	}
}
void Modbus::check_argin(const Tango::DevVarULongArray *argin, int lgth, const char *where) {

	char tmp[256];

	if (argin->length() != (unsigned int)lgth) {
		sprintf(tmp,"Incorrect number of input arguments (%d expected)",lgth);
		Tango::Except::throw_exception(
				(const char *)"Modbus::error_write",
				(const char *)tmp,
				(const char *)where);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	Modbus::data_in_cache
 *
 *	description:	Check if the command result is in the data cache
 *
 *	cmd = command name
 *	adr = address to be read
 *	nb_reg = data number to be read
 *
 *  Returns -1 is data not in cache. Otherwise, returns the index
 * in the vector describing cached data of the block containing
 * the required data
 */
//+------------------------------------------------------------------
int Modbus::data_in_cache(const char *cmd, short adr, short nb_reg)
{
	unsigned long nb_block = cacheDef.size();
	int ret = -1;

	for (unsigned long loop = 0;loop < nb_block;loop++)
	{
		if (cacheDef[loop].cmd_name != cmd)
			continue;
		else
		{
			if ((adr >= cacheDef[loop].in_args[0]) &&
				(adr < (cacheDef[loop].in_args[0] + cacheDef[loop].in_args[1])))
			{
				if ((adr + nb_reg) <= (cacheDef[loop].in_args[0] + cacheDef[loop].in_args[1]))
				{
					ret = loop;
					break;
				}
			}
			else
				continue;
		}
	}

	//
	// Check that the thread is started
	//

	if (ret != -1)
	{
		unsigned int th_sec;
		{
			omni_mutex_lock sync(*(cacheDef[ret].data_block_mutex));
			th_sec = cacheDef[ret].nb_sec;
		}

		if (th_sec == 0)
			ret = -1;
	}

	return ret;
}


/*----- PROTECTED REGION END -----*/	//	Modbus::namespace_ending
} //	namespace
