/*----- PROTECTED REGION ID(TM700Srv.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        TM700Srv.cpp
//
// description : C++ source for the TM700Srv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               TM700Srv are implemented in this file.
//
// project :
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <TM700Srv.h>
#include <TM700SrvClass.h>

/*----- PROTECTED REGION END -----*/	//	TM700Srv.cpp

/**
 *  TM700Srv class description:
 *    Device server for Pfeiffer turbopumps equipped with TM700 drive units.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  Start         |  start
//  Stop          |  stop
//  Reset         |  reset
//  getError      |  get_error
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  BearingTemperature      |  Tango::DevUShort	Scalar
//  BearingWear             |  Tango::DevUShort	Scalar
//  ConverterTemperature    |  Tango::DevUShort	Scalar
//  Current                 |  Tango::DevFloat	Scalar
//  ElecOpHours             |  Tango::DevUShort	Scalar
//  ElectronicsTemperature  |  Tango::DevUShort	Scalar
//  EnableStandby           |  Tango::DevBoolean	Scalar
//  FirmwareVersion         |  Tango::DevString	Scalar
//  Frequency               |  Tango::DevUShort	Scalar
//  GasMode                 |  Tango::DevEnum	Scalar
//  HardwareVersion         |  Tango::DevString	Scalar
//  LastError               |  Tango::DevString	Scalar
//  MotorTemperature        |  Tango::DevUShort	Scalar
//  OperatingHours          |  Tango::DevFloat	Scalar
//  Power                   |  Tango::DevFloat	Scalar
//  PumpBottomTemperature   |  Tango::DevUShort	Scalar
//  RotorImbalance          |  Tango::DevUShort	Scalar
//  StandbySpeed            |  Tango::DevFloat	Scalar
//================================================================

namespace TM700Srv_ns
{
/*----- PROTECTED REGION ID(TM700Srv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	TM700Srv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : TM700Srv::TM700Srv()
 *	Description : Constructors for a Tango device
 *                implementing the classTM700Srv
 */
//--------------------------------------------------------
TM700Srv::TM700Srv(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(TM700Srv::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::constructor_1
}
//--------------------------------------------------------
TM700Srv::TM700Srv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(TM700Srv::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::constructor_2
}
//--------------------------------------------------------
TM700Srv::TM700Srv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(TM700Srv::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : TM700Srv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void TM700Srv::delete_device()
{
	DEBUG_STREAM << "TM700Srv::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(TM700Srv::delete_device) ENABLED START -----*/
	
	if(dev) {
		dev->terminate();
		int *retval;
		dev->join((void**)&retval);
		delete retval;
	}
	dev = NULL;

	//	Delete device allocated objects
	if(*attr_LastError_read)
		CORBA::string_free(*attr_LastError_read);
	if(*attr_FirmwareVersion_read)
		CORBA::string_free(*attr_FirmwareVersion_read);
	if(*attr_HardwareVersion_read)
		CORBA::string_free(*attr_HardwareVersion_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::delete_device
	delete[] attr_BearingTemperature_read;
	delete[] attr_BearingWear_read;
	delete[] attr_ConverterTemperature_read;
	delete[] attr_Current_read;
	delete[] attr_ElecOpHours_read;
	delete[] attr_ElectronicsTemperature_read;
	delete[] attr_EnableStandby_read;
	delete[] attr_FirmwareVersion_read;
	delete[] attr_Frequency_read;
	delete[] attr_GasMode_read;
	delete[] attr_HardwareVersion_read;
	delete[] attr_LastError_read;
	delete[] attr_MotorTemperature_read;
	delete[] attr_OperatingHours_read;
	delete[] attr_Power_read;
	delete[] attr_PumpBottomTemperature_read;
	delete[] attr_RotorImbalance_read;
	delete[] attr_StandbySpeed_read;
}

//--------------------------------------------------------
/**
 *	Method      : TM700Srv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void TM700Srv::init_device()
{
	DEBUG_STREAM << "TM700Srv::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(TM700Srv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_BearingTemperature_read = new Tango::DevUShort[1];
	attr_BearingWear_read = new Tango::DevUShort[1];
	attr_ConverterTemperature_read = new Tango::DevUShort[1];
	attr_Current_read = new Tango::DevFloat[1];
	attr_ElecOpHours_read = new Tango::DevUShort[1];
	attr_ElectronicsTemperature_read = new Tango::DevUShort[1];
	attr_EnableStandby_read = new Tango::DevBoolean[1];
	attr_FirmwareVersion_read = new Tango::DevString[1];
	attr_Frequency_read = new Tango::DevUShort[1];
	attr_GasMode_read = new GasModeEnum[1];
	attr_HardwareVersion_read = new Tango::DevString[1];
	attr_LastError_read = new Tango::DevString[1];
	attr_MotorTemperature_read = new Tango::DevUShort[1];
	attr_OperatingHours_read = new Tango::DevFloat[1];
	attr_Power_read = new Tango::DevFloat[1];
	attr_PumpBottomTemperature_read = new Tango::DevUShort[1];
	attr_RotorImbalance_read = new Tango::DevUShort[1];
	attr_StandbySpeed_read = new Tango::DevFloat[1];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(TM700Srv::init_device) ENABLED START -----*/

	*attr_LastError_read = CORBA::string_dup("");
	*attr_FirmwareVersion_read = CORBA::string_dup("");
	*attr_HardwareVersion_read = CORBA::string_dup("");

	//	Initialize device
	dev = new TM700Monitor(proxy, address, this);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : TM700Srv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void TM700Srv::get_device_property()
{
	/*----- PROTECTED REGION ID(TM700Srv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("proxy"));
	dev_prop.push_back(Tango::DbDatum("address"));
	dev_prop.push_back(Tango::DbDatum("polling"));
	dev_prop.push_back(Tango::DbDatum("expertPolling"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on TM700SrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		TM700SrvClass	*ds_class =
			(static_cast<TM700SrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize proxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxy;
		else {
			//	Try to initialize proxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxy;
		}
		//	And try to extract proxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxy;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize address from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  address;
		else {
			//	Try to initialize address from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  address;
		}
		//	And try to extract address value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  address;

		//	Try to initialize polling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  polling;
		else {
			//	Try to initialize polling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  polling;
		}
		//	And try to extract polling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  polling;

		//	Try to initialize expertPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  expertPolling;
		else {
			//	Try to initialize expertPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  expertPolling;
		}
		//	And try to extract expertPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  expertPolling;

	}

	/*----- PROTECTED REGION ID(TM700Srv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : TM700Srv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void TM700Srv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(TM700Srv::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	TM700Srv::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : TM700Srv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void TM700Srv::always_executed_hook()
{
	//DEBUG_STREAM << "TM700Srv::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"TM700Srv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(TM700Srv::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : TM700Srv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void TM700Srv::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	//DEBUG_STREAM << "TM700Srv::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : TM700Srv::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void TM700Srv::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	//DEBUG_STREAM << "TM700Srv::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::write_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute BearingTemperature related method
 *	Description: Actual bearing temperature
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_BearingTemperature(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_BearingTemperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_BearingTemperature) ENABLED START -----*/

	*attr_BearingTemperature_read = dev->getBearingT();

	//	Set the attribute value
	attr.set_value(attr_BearingTemperature_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_BearingTemperature
}
//--------------------------------------------------------
/**
 *	Read attribute BearingWear related method
 *	Description: Wear conditions of the safety bearings
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_BearingWear(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_BearingWear(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_BearingWear) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_BEAR_WEAR);
	*attr_BearingWear_read = val.i;

	//	Set the attribute value
	attr.set_value(attr_BearingWear_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_BearingWear
}
//--------------------------------------------------------
/**
 *	Read attribute ConverterTemperature related method
 *	Description: Actual converter temperature
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_ConverterTemperature(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_ConverterTemperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_ConverterTemperature) ENABLED START -----*/

	*attr_ConverterTemperature_read = dev->getConverterT();

	//	Set the attribute value
	attr.set_value(attr_ConverterTemperature_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_ConverterTemperature
}
//--------------------------------------------------------
/**
 *	Read attribute Current related method
 *	Description: Actual current value of the intermediate circuit of the frequency converter
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_Current(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_Current(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_Current) ENABLED START -----*/

	*attr_Current_read = dev->getCurrent();

	//	Set the attribute value
	attr.set_value(attr_Current_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_Current
}
//--------------------------------------------------------
/**
 *	Read attribute ElecOpHours related method
 *	Description: Operating hours of the electronics
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_ElecOpHours(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_ElecOpHours(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_ElecOpHours) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_OPH_ELEC);
	*attr_ElecOpHours_read = val.i;

	//	Set the attribute value
	attr.set_value(attr_ElecOpHours_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_ElecOpHours
}
//--------------------------------------------------------
/**
 *	Read attribute ElectronicsTemperature related method
 *	Description: Temperature of the electronics
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_ElectronicsTemperature(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_ElectronicsTemperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_ElectronicsTemperature) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_T_ELEC);
	*attr_ElectronicsTemperature_read = val.i;

	//	Set the attribute value
	attr.set_value(attr_ElectronicsTemperature_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_ElectronicsTemperature
}
//--------------------------------------------------------
/**
 *	Read attribute EnableStandby related method
 *	Description: Enable standby mode
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_EnableStandby(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_EnableStandby(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_EnableStandby) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_EnableStandby_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_EnableStandby
}
//--------------------------------------------------------
/**
 *	Write attribute EnableStandby related method
 *	Description: Enable standby mode
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::write_EnableStandby(Tango::WAttribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::write_EnableStandby(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(TM700Srv::write_EnableStandby) ENABLED START -----*/


	/*----- PROTECTED REGION END -----*/	//	TM700Srv::write_EnableStandby
}
//--------------------------------------------------------
/**
 *	Read attribute FirmwareVersion related method
 *	Description: Controller firmware version
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_FirmwareVersion(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_FirmwareVersion(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_FirmwareVersion) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_FW_VER);

	if(*attr_FirmwareVersion_read) {
		CORBA::string_free(*attr_FirmwareVersion_read);
	}
	*attr_FirmwareVersion_read = CORBA::string_dup(val.s.c_str());

	//	Set the attribute value
	attr.set_value(attr_FirmwareVersion_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_FirmwareVersion
}
//--------------------------------------------------------
/**
 *	Read attribute Frequency related method
 *	Description: Actual output frequency of the converter
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_Frequency(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_Frequency(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_Frequency) ENABLED START -----*/

	*attr_Frequency_read = dev->getFrequency();

	//	Set the attribute value
	attr.set_value(attr_Frequency_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_Frequency
}
//--------------------------------------------------------
/**
 *	Read attribute GasMode related method
 *	Description: Select gas mode for the turbopump
 *
 *	Data type:	Tango::DevEnum (GasModeEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_GasMode(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_GasMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_GasMode) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_GAS_MODE);
	switch(val.i) {
		default:
		case 0:
			*attr_GasMode_read = _HEAVY_GASES;
			break;
		case 1:
			*attr_GasMode_read = _LIGHT_GASES;
			break;
		case 2:
			*attr_GasMode_read = _HELIUM;
			break;
	}

	//	Set the attribute value
	attr.set_value(attr_GasMode_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_GasMode
}
//--------------------------------------------------------
/**
 *	Write attribute GasMode related method
 *	Description: Select gas mode for the turbopump
 *
 *	Data type:	Tango::DevEnum (GasModeEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::write_GasMode(Tango::WAttribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::write_GasMode(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	GasModeEnum	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(TM700Srv::write_GasMode) ENABLED START -----*/


	/*----- PROTECTED REGION END -----*/	//	TM700Srv::write_GasMode
}
//--------------------------------------------------------
/**
 *	Read attribute HardwareVersion related method
 *	Description: Controller hardware version
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_HardwareVersion(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_HardwareVersion(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_HardwareVersion) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_HW_VER);

	if(*attr_HardwareVersion_read) {
		CORBA::string_free(*attr_HardwareVersion_read);
	}
	*attr_HardwareVersion_read = CORBA::string_dup(val.s.c_str());

	//	Set the attribute value
	attr.set_value(attr_HardwareVersion_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_HardwareVersion
}
//--------------------------------------------------------
/**
 *	Read attribute LastError related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_LastError(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_LastError(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_LastError) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_LastError_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_LastError
}
//--------------------------------------------------------
/**
 *	Read attribute MotorTemperature related method
 *	Description: Actual motor temperature
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_MotorTemperature(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_MotorTemperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_MotorTemperature) ENABLED START -----*/

	*attr_MotorTemperature_read = dev->getMotorT();

	//	Set the attribute value
	attr.set_value(attr_MotorTemperature_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_MotorTemperature
}
//--------------------------------------------------------
/**
 *	Read attribute OperatingHours related method
 *	Description: 
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_OperatingHours(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_OperatingHours(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_OperatingHours) ENABLED START -----*/

	*attr_OperatingHours_read = dev->getOperatingHours();

	//	Set the attribute value
	attr.set_value(attr_OperatingHours_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_OperatingHours
}
//--------------------------------------------------------
/**
 *	Read attribute Power related method
 *	Description: Power consumption
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_Power(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_Power(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_Power) ENABLED START -----*/

	*attr_Power_read = dev->getPower();

	//	Set the attribute value
	attr.set_value(attr_Power_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_Power
}
//--------------------------------------------------------
/**
 *	Read attribute PumpBottomTemperature related method
 *	Description: Temperature of the bottom of the pump
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_PumpBottomTemperature(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_PumpBottomTemperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_PumpBottomTemperature) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_T_PUMPB);
	*attr_PumpBottomTemperature_read = val.i;

	//	Set the attribute value
	attr.set_value(attr_PumpBottomTemperature_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_PumpBottomTemperature
}
//--------------------------------------------------------
/**
 *	Read attribute RotorImbalance related method
 *	Description: Rotor out-of-balance condition
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_RotorImbalance(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_RotorImbalance(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_RotorImbalance) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_ROT_IMB);
	*attr_RotorImbalance_read = val.i;

	//	Set the attribute value
	attr.set_value(attr_RotorImbalance_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_RotorImbalance
}
//--------------------------------------------------------
/**
 *	Read attribute StandbySpeed related method
 *	Description: Standby rotation speed
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::read_StandbySpeed(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::read_StandbySpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TM700Srv::read_StandbySpeed) ENABLED START -----*/

	const TM700_param& val = dev->readExpertParam(TM700_PAR_SB_SP);
	*attr_StandbySpeed_read = val.f;

	//	Set the attribute value
	attr.set_value(attr_StandbySpeed_read);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::read_StandbySpeed
}
//--------------------------------------------------------
/**
 *	Write attribute StandbySpeed related method
 *	Description: Standby rotation speed
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void TM700Srv::write_StandbySpeed(Tango::WAttribute &attr)
{
	//DEBUG_STREAM << "TM700Srv::write_StandbySpeed(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(TM700Srv::write_StandbySpeed) ENABLED START -----*/

	TM700_param val;
	val.dtype = TM700_DTYPE_FLOAT;
	val.f = w_val;
	dev->writeParam(TM700_PAR_SB_SP, val);

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::write_StandbySpeed
}

//--------------------------------------------------------
/**
 *	Method      : TM700Srv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void TM700Srv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(TM700Srv::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Start related method
 *	Description: Start the turbo pump
 *
 */
//--------------------------------------------------------
void TM700Srv::start()
{
	DEBUG_STREAM << "TM700Srv::Start()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TM700Srv::start) ENABLED START -----*/

	//	Add your own code
	try {
		dev->start();
	} catch(Tango::DevFailed &e) {
		Tango::Except::re_throw_exception(e,
				(const char*)"Start command failed",
				(const char*)"Failed to start turbopump",
				(const char*)"TM700Srv::Start()");
	}

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::start
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stop the turbo pump
 *
 */
//--------------------------------------------------------
void TM700Srv::stop()
{
	DEBUG_STREAM << "TM700Srv::Stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TM700Srv::stop) ENABLED START -----*/

	try {
		dev->stop();
	} catch(Tango::DevFailed &e) {
		Tango::Except::re_throw_exception(e,
				(const char*)"Stop command failed",
				(const char*)"Failed to stop turbopump",
				(const char*)"TM700Srv::Stop()");
	}

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::stop
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset error on the turbo pump controller
 *
 */
//--------------------------------------------------------
void TM700Srv::reset()
{
	DEBUG_STREAM << "TM700Srv::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TM700Srv::reset) ENABLED START -----*/

	try {
		dev->reset();
	} catch(Tango::DevFailed &e) {
		Tango::Except::re_throw_exception(e,
				(const char*)"Reset command failed",
				(const char*)"Failed to reset turbopump",
				(const char*)"TM700Srv::Reset()");
	}

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::reset
}
//--------------------------------------------------------
/**
 *	Command getError related method
 *	Description: Get list of logged errors
 *
 *	@param argin Error index (min 0, max 39)
 *	@returns Error message
 */
//--------------------------------------------------------
Tango::DevString TM700Srv::get_error(Tango::DevUShort argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "TM700Srv::getError()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TM700Srv::get_error) ENABLED START -----*/

	//	Add your own code
	argout = CORBA::string_dup("");

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::get_error
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : TM700Srv::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void TM700Srv::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(TM700Srv::add_dynamic_commands) ENABLED START -----*/

	//	Add your own code to create and add dynamic commands if any

	/*----- PROTECTED REGION END -----*/	//	TM700Srv::add_dynamic_commands
}

/*----- PROTECTED REGION ID(TM700Srv::namespace_ending) ENABLED START -----*/

//	Additional Methods

// Constructor
TM700Monitor::TM700Monitor(const std::string& proxy, uint8_t address, TM700Srv* parent) :
	_dev(NULL),
	_terminate(false),
	_address(address),
	_parent(parent),
	_conv_t(0),
	_motor_t(0),
	_bearing_t(0),
	_freq(0),
	_current(0.0),
	_power(0.0),
	_op_hours(0.0),
	_ev_ophours(NULL),
	_ev_current(NULL),
	_ev_power(NULL),
	_ev_freq(NULL),
	_ev_ct(NULL),
	_ev_mt(NULL),
	_ev_bt(NULL) {

	// Get polling times from parent
	_polling = _parent->polling;
	_expert_polling = _parent->expertPolling;

	// Initialize parameters' data type map
	TM700_generate_parameter_map(_type_map);

	// Create serial device proxy
	_dev = new Tango::DeviceProxy(proxy.c_str());

	// Allocate event variables
	CREATE_EVENT_MEMBER(_ev_ophours, float, 0.0);
	CREATE_EVENT_MEMBER(_ev_current, float, 0.0);
	CREATE_EVENT_MEMBER(_ev_power, float, 0.0);
	CREATE_EVENT_MEMBER(_ev_freq, uint16_t, 0);
	CREATE_EVENT_MEMBER(_ev_ct, uint16_t, 0);
	CREATE_EVENT_MEMBER(_ev_mt, uint16_t, 0);
	CREATE_EVENT_MEMBER(_ev_bt, uint16_t, 0);

	// Start monitor thread
	start_undetached();
}


// Destructor
TM700Monitor::~TM700Monitor() {

	// Delete serial device proxy
	if(_dev) {
		delete _dev;
		_dev = NULL;
	}

	// Delete event members
	DELETE_EVENT_MEMBER(_ev_ophours);
	DELETE_EVENT_MEMBER(_ev_current);
	DELETE_EVENT_MEMBER(_ev_power);
	DELETE_EVENT_MEMBER(_ev_freq);
	DELETE_EVENT_MEMBER(_ev_ct);
	DELETE_EVENT_MEMBER(_ev_mt);
	DELETE_EVENT_MEMBER(_ev_bt);
}


// Start pump
void TM700Monitor::start() {
	TM700_param par;
	par.dtype = TM700_DTYPE_BOOL;
	par.b = true;
	writeParam(TM700_PAR_PUMPSTAT, par);
	writeParam(TM700_PAR_MOTOR, par);
}


// Stop pump
void TM700Monitor::stop() {
	TM700_param par;
	par.dtype = TM700_DTYPE_BOOL;
	par.b = false;
	writeParam(TM700_PAR_PUMPSTAT, par);
}


// Read parameter from TM700 controller
TM700_param TM700Monitor::readParam(int param) {
	// Check if serial device is available
	if(_dev == NULL) {
		Tango::Except::throw_exception(
					(const char *)"No serial device",
					(const char *)"Communication device not defined",
					(const char *)"TM700Monitor::readParam()");
	}

	// Check if parameter exist
	if(_type_map.find(param) == _type_map.end()) {
		// Parameter not defined
		Tango::Except::throw_exception(
					(const char *)"Bad parameter",
					(const char *)"The requested parameter is not supported by the library",
					(const char *)"TM700Monitor::readParam()");
	}

	TM700_param out;
	out.dtype = _type_map[param];

	// Format request
	stringstream request;
	request << std::setfill('0') << std::setw(3) << (int)_address;
	request << "00";
	request << std::setfill('0') << std::setw(3) << param;
	request << "02=?";

	// Compute crc code
	int crc = 0;
	for(size_t i = 0; i < request.str().length(); i++) {
		crc += (int)(request.str()[i]);
	}
	crc = crc % 256;

	// Add crc to buffer
	request << std::setfill('0') << std::setw(3) << crc;

	Tango::DeviceData din, dout;
	// Create request
	string message = request.str();
	din << message;

	{
		// Send request to serial device
		omni_mutex_lock sync(this->_lock);
		dout = _dev->command_inout("SendCommandWithResponse", din);
	}

	// Extract response
	string response;
	dout >> response;

	// Parse response
	parse_response(response, param, out);

	return out;
}


// Read expert parameter (handle pseudo-polling)
const TM700_param& TM700Monitor::readExpertParam(int param) {
	// Check if parameter was already read
	if(_cache_time.find(param) != _cache_time.end() && _cache_value.find(param) != _cache_value.end()) {
		// Check elapsed time
		struct timeval now;
		gettimeofday(&now, NULL);
		size_t elapsed = ELAPSED_TIME_MS(_cache_time[param], now);
		if(elapsed < _expert_polling) {
			return _cache_value[param];
		}
	}

	// If we arrive here the parameter was never read or the value is old
	TM700_param val = readParam(param);

	// Get current time
	struct timeval now;
	gettimeofday(&now, NULL);

	// Add parameter to cache
	_cache_time[param] = now;
	_cache_value[param] = val;

	// Return value
	return _cache_value[param];
}


// Write parameter to TM700 controller
void TM700Monitor::writeParam(int param, const TM700_param& value) {
	// Check if serial device is available
	if(_dev == NULL) {
		Tango::Except::throw_exception(
					(const char *)"No serial device",
					(const char *)"Communication device not defined",
					(const char *)"TM700Monitor::writeParam()");
	}

	// Check if parameter exist
	if(_type_map.find(param) == _type_map.end()) {
		// Parameter not defined
		Tango::Except::throw_exception(
					(const char *)"Bad parameter",
					(const char *)"The requested parameter is not supported by the library",
					(const char *)"TM700Monitor::writeParam()");
	}

	// Check data type
	if(value.dtype != _type_map[param]) {
		// Parameter not defined
		Tango::Except::throw_exception(
					(const char *)"Bad data type",
					(const char *)"The data type of supplied value does not match that of parameter",
					(const char *)"TM700Monitor::writeParam()");
	}

	// Format request
	stringstream request;
	request << std::setfill('0') << std::setw(3) << (int)_address;
	request << "10";
	request << std::setfill('0') << std::setw(3) << param;

	if(value.dtype == TM700_DTYPE_BOOL) {
		if(value.b)
			request << "06" << "111111";
		else
			request << "06" << "000000";

	} else if(value.dtype == TM700_DTYPE_ULONG) {
		request << "06" << std::setfill('0') << std::setw(6) << value.i;

	} else if(value.dtype == TM700_DTYPE_FLOAT) {
		int val = static_cast<int>(value.f * 100.0);
		request << "06" << std::setfill('0') << std::setw(6) << val;

	} else if(value.dtype == TM700_DTYPE_STR) {
		request << "06" << std::setfill(' ') << std::setw(6) << value.s.substr(0, 6); // TODO: must be checked!

	} else if(value.dtype == TM700_DTYPE_UINT) {
		request << "03" << std::setfill('0') << std::setw(3) << value.i;

	} else if(value.dtype == TM700_DTYPE_TEXT) {
		request << "16" << std::setfill(' ') << std::setw(16) << value.s.substr(0, 16); // TODO: must be checked!

	} else {
		// This should never happen
		Tango::Except::throw_exception(
					(const char *)"Bad data type",
					(const char *)"Bad data type. This indicates a bug in the application. Report to developer.",
					(const char *)"TM700Monitor::writeParam()");
	}

	// Compute crc code
	int crc = 0;
	for(size_t i = 0; i < request.str().length(); i++) {
		crc += (int)(request.str()[i]);
	}
	crc = crc % 256;

	// Add crc to buffer
	request << std::setfill('0') << std::setw(3) << crc;

	Tango::DeviceData din, dout;
	// Create request
	string message = request.str();
	din << message;

	{
		// Send request to serial device
		omni_mutex_lock sync(this->_lock);
		dout = _dev->command_inout("SendCommandWithResponse", din);
	}

	// Extract response
	string response;
	dout >> response;

	// Parse response
	TM700_param out;
	out.dtype = value.dtype;
	parse_response(response, param, out);

	// Check if value was written correctly
	stringstream msg;
	msg << "Failed to set parameter " << param << " to value ";
	if(value.dtype == TM700_DTYPE_BOOL) {
		if(value.b != out.b) {
			msg << value.b;
			Tango::Except::throw_exception(
					(const char *)"Failed to set parameter",
					msg.str().c_str(),
					(const char *)"TM700Monitor::writeParam()");
		}

	} else if(value.dtype == TM700_DTYPE_ULONG || value.dtype == TM700_DTYPE_UINT) {
		if(value.i != out.i) {
			msg << value.i;
			Tango::Except::throw_exception(
					(const char *)"Failed to set parameter",
					msg.str().c_str(),
					(const char *)"TM700Monitor::writeParam()");
		}

	} else if(value.dtype == TM700_DTYPE_FLOAT) {
		if(std::abs(value.f - out.f) > 0.05) {
			msg << value.f;
			Tango::Except::throw_exception(
					(const char *)"Failed to set parameter",
					msg.str().c_str(),
					(const char *)"TM700Monitor::writeParam()");
		}

	} else if(value.dtype == TM700_DTYPE_STR || value.dtype == TM700_DTYPE_TEXT) {
		if(value.s.compare(0, out.s.length(), out.s)) {
			msg << value.s;
			Tango::Except::throw_exception(
					(const char *)"Failed to set parameter",
					msg.str().c_str(),
					(const char *)"TM700Monitor::writeParam()");
		}

	} else {
		// This should never happen
		Tango::Except::throw_exception(
					(const char *)"Bad data type",
					(const char *)"Bad data type. This indicates a bug in the application. Report to developer.",
					(const char *)"TM700Monitor::writeParam()");
	}
}


// Parse controller response
void TM700Monitor::parse_response(const string& response, int param, TM700_param &out) {

	// Check response length
	if(response.length() < 16) {
		// Corrupted message
		Tango::Except::throw_exception(
					(const char *)"Controller error",
					(const char *)"Incomplete response",
					(const char *)"TM700Monitor::parse_response()");
	}

	try {
	
		// Check CRC
		int crc = 0;
		int crc_o = std::stoi(response.substr(response.length() - 3, 3));
		for(size_t i = 0; i < response.length() - 3; i++) {
			crc += (int)response[i];
		}
		crc = crc % 256;
		if(crc != crc_o) {
			// Corrupted message
			Tango::Except::throw_exception(
						(const char *)"Controller error",
						(const char *)"Malformed response. CRC didn't match",
						(const char *)"TM700Monitor::parse_response()");
		}

		// Check address
		int address_o = std::stoi(response.substr(0, 3));
		if(address_o != _address) {
			// Bad address in response
			Tango::Except::throw_exception(
						(const char *)"Controller error",
						(const char *)"Malformed response. Address in response does not match that of request",
						(const char *)"TM700Monitor::parse_response()");
		}

		// Check parameter number
		int param_o = std::stoi(response.substr(5, 3));
		if(param_o != param) {
			// Bad parameter in response
			Tango::Except::throw_exception(
						(const char *)"Controller error",
						(const char *)"Malformed response. Parameter number in response does not match that of request",
						(const char *)"TM700Monitor::parse_response()");
		}

		// Get data length
		int len = std::stoi(response.substr(8, 2));

		// Check if we have an error
		if(len == 6) {
			if(response.compare(10, len, "NO_DEF") == 0) {
				// Parameter does not exist
				Tango::Except::throw_exception(
							(const char *)"Controller error",
							(const char *)"Requested parameter does not exist",
							(const char *)"TM700Monitor::check_error()");

			} else if(response.compare(10, len, "_RANGE") == 0) {
				// Value outside permitted range
				Tango::Except::throw_exception(
							(const char *)"Controller error",
							(const char *)"Parameter value out of range",
							(const char *)"TM700Monitor::check_error()");

			} else if(response.compare(10, len, "_LOGIC") == 0) {
				// Logic access violation
				Tango::Except::throw_exception(
							(const char *)"Controller error",
							(const char *)"Logic access violation",
							(const char *)"TM700Monitor::check_error()");
			}
		}

		// Everything fine! Let's extract response
		if(out.dtype == TM700_DTYPE_BOOL) {
			if(response.compare(10, len, "111111") == 0)
				out.b = true;
			else
				out.b = false;

		} else if(out.dtype == TM700_DTYPE_ULONG || out.dtype == TM700_DTYPE_UINT) {
			out.i = std::stoi(response.substr(10, len));

		} else if(out.dtype == TM700_DTYPE_FLOAT) {
			int val = std::stoi(response.substr(10, len));
			out.f = static_cast<float>(val) / 100.0;

		} else if(out.dtype == TM700_DTYPE_STR || out.dtype == TM700_DTYPE_TEXT) {
			out.s = response.substr(10, len);

		} else {
			// This should never happen
			Tango::Except::throw_exception(
						(const char *)"Bad data type",
						(const char *)"Bad data type. This indicates a bug in the application. Report to developer.",
						(const char *)"TM700Monitor::parse_response()");
		}

	// Catch only std::stoi exceptions
	} catch(std::invalid_argument &) {
		Tango::Except::throw_exception(
					(const char *)"Controller error",
					(const char *)"Conversion of string to number failed because of wrong input",
					(const char *)"TM700Monitor::parse_response()");
	} catch(std::out_of_range&) {
		Tango::Except::throw_exception(
					(const char *)"Controller error",
					(const char *)"Conversion of string to number failed because of out-of-range error",
					(const char *)"TM700Monitor::parse_response()");
	}
}


// Monitor thread main loop
void *TM700Monitor::run_undetached(void *arg) {

	// Parameters
	size_t param_counter = 0;
	const uint16_t params[] = {
		TM700_PAR_CURR,     // Current
		TM700_PAR_POWER,    // Power
		TM700_PAR_T_BEAR,   // Bearing temperature
		TM700_PAR_T_POWER,  // Converter temperature
		TM700_PAR_T_MOTOR,  // Motor temperature
		TM700_PAR_OPH_PUMP, // Operating hours
	};

	// Status params
	const uint16_t status_params[] = {
		TM700_PAR_PUMPSTAT,  // Pumping station on
		TM700_PAR_MOTOR,     // Motor pump on
		TM700_PAR_SETSP_ATT, // Normal operation
		TM700_PAR_PUMP_ACC,  // Pump accelerates
	};

	TM700_param par;
	bool status[sizeof(status_params)/sizeof(uint16_t)];
	std::vector<double> freq_log;

	// Error counter
	size_t error_count = 0;

	while(!this->_terminate) {
		// Starting timestamp
		struct timeval start, end;
		gettimeofday(&start, NULL);

		// Reset variables
		memset(&status, 0, sizeof(status));
		bool has_err = false;
		bool has_warn = false;
		uint16_t code = 0;

		try {

			// Read status
			for(size_t i = 0; i < sizeof(status_params)/sizeof(uint16_t); i++) {
				par = readParam(status_params[i]);
				status[i] = par.b;
			}

			// Read last error
			par = readParam(TM700_PAR_ERRCODE);
			if(par.s.compare("000000") == 0) {
				// No error

			} else if(par.s.compare(0, 3, "Err") == 0) {
				code = std::stoi(par.s.substr(3));
				if(code > 0) {
					has_err = true;
					// Immediately stop the pump!
					stop();
				}
			} else if(par.s.compare(0, 3, "Wrn") == 0) {
				code = std::stoi(par.s.substr(3));
				if(code > 0)
					has_warn = true;
			} else {
				// This should not happen
				_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Unexpected error string: " << par.s;
			}

			// Read rotation frequency
			par = readParam(TM700_PAR_ROT_SP);

			// Update frequency log and calculate derivative
			if(freq_log.size() == 5) {
				freq_log.erase(freq_log.begin());
			}
			freq_log.push_back(static_cast<double>(par.i));
			double fder = compute_5point_derivative(static_cast<double>(_polling) / 1000.0, freq_log);

			// Update freq and push event if needed
			if(_freq != par.i) {
				_freq = par.i;
				*_ev_freq = _freq;
				_parent->push_change_event("Frequency", _ev_freq);
			}

			// Update status
			stringstream status_msg;
			Tango::DevState state = Tango::STANDBY;
			if(status[0] && status[1]) { // Pumping station on
				if(status[2]) {
					// Normal operation
					state = Tango::RUNNING;
					status_msg << "Normal operation";
				} else {
					state = Tango::MOVING;
					if(fder > 0 || status[4]) {
						// Pump is actively accelerating
						status_msg << "Pump is accelerating.";
					} else {
						status_msg << "Pump hasn't reached normal operation but it's not accelerating.";
					}
				}

			} else { // Pumping station off
				if(_freq > 5) {
					// Pump still rotating
					if(fder < 0) {
						// Pump is decelerating
						state = Tango::MOVING;
						status_msg << "Pump is decelerating.";

					} else if(_freq > 50) {
						// Pump is off but it's not decelerating...
						state = Tango::MOVING;
						status_msg << "Pump is off but it's not decelerating.";
					}
				} else {
					// Pump is off
					state = Tango::STANDBY;
					status_msg << "Pump is off.";
				}
			}

			// Handle errors and warnings
			if(has_err) {
				if(error_can_be_reset(code, _freq)) {
					// Reset error
					par.clear();
					par.dtype = TM700_DTYPE_BOOL;
					par.b = true;
					writeParam(TM700_PAR_ERRACK, par);
				}
				// Log error
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Pump error [" << code << "]: " << get_error_message(code) << " (freq. " << _freq << ", op. hours " << _op_hours << ")" << endl;
				state = Tango::FAULT;
				status_msg << "Error: " << get_error_message(code);

			} else if(has_warn) {
				// Reset warning
				par.clear();
				par.dtype = TM700_DTYPE_BOOL;
				par.b = true;
				writeParam(TM700_PAR_ERRACK, par);
				// Log warning
				_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Pump warning [" << code << "]: " << get_warn_message(code) << " (freq. " << _freq << ", op. hours " << _op_hours << ")" << endl;
				state = Tango::ALARM;
				status_msg << "Warning: " << get_warn_message(code);
			}

			// Update status
			_parent->set_state(state);
			_parent->set_status(status_msg.str());
			
			// Reset error counter
			error_count = 0;

		} catch(Tango::DevFailed &e) {
			// Handle error
			error_count++;
			if(error_count < 5) {
				error_log_exception(_parent, "Failed to read pump status. Errors were: ", e);
			} else {
				_parent->set_state(Tango::FAULT);
				_parent->set_status("Communication failed");
			}

		} catch(std::invalid_argument &) {
			// std::stoi failed because of bad input
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "std::stoi failed because of a bad input" << endl;

		} catch(std::out_of_range&) {
			// std::stoi failed because of out-of-range error
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "std::stoi failed because of an out-of-range error" << endl;
		}


		// Read monitoring parameters (only if error counter is zero)
		if(error_count == 0) {
			uint16_t par_n = params[param_counter];

			try {
				if(_parent->get_logger()->is_debug_enabled())
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Reading parameter " << par_n << endl;

				// Read one parameter
				par = readParam(par_n);

				// Increment counter and reset when needed
				param_counter++;
				if(param_counter >= sizeof(params)/sizeof(uint16_t)) {
					param_counter = 0;
				}

				// Update monitoring parameters
				switch(par_n) {
					case TM700_PAR_CURR: // Current
						if(std::abs(_current - par.f) > 0.05) {
							_current = par.f;
							*_ev_current = _current;
							_parent->push_change_event("Current", _ev_current);
						}
						break;

					case TM700_PAR_POWER: // Power
						if(_power != par.i) {
							_power = par.i;
							*_ev_power = static_cast<float>(_power);
							_parent->push_change_event("Power", _ev_power);
						}
						break;

					case TM700_PAR_T_BEAR: // Bearing temperature
						if(_bearing_t != par.i) {
							_bearing_t = par.i;
							*_ev_bt = _bearing_t;
							_parent->push_change_event("BearingTemperature", _ev_bt);
						}
						break;

					case TM700_PAR_T_POWER: // Converter temperature
						if(_conv_t != par.i) {
							_conv_t = par.i;
							*_ev_ct = _conv_t;
							_parent->push_change_event("ConverterTemperature", _ev_ct);
						}
						break;

					case TM700_PAR_T_MOTOR: // Motor temperature
						if(_motor_t != par.i) {
							_motor_t = par.i;
							*_ev_mt = _motor_t;
							_parent->push_change_event("MotorTemperature", _ev_mt);
						}
						break;

					case TM700_PAR_OPH_PUMP: // Operating hours
						if(_op_hours != par.i) {
							_op_hours = par.i;
							*_ev_ophours = static_cast<float>(_op_hours);
							_parent->push_change_event("BearingTemperature", _ev_bt);
						}
						break;

					default: // Unhandled parameter
						// Warning message
						_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Read an unexpected parameter with number " << par_n;
						break;
				}

			} catch(Tango::DevFailed &e) {
				// Handle error
				stringstream msg;
				msg << "Failed to read monitoring parameter " << par_n << ". Errors were: ";
				error_log_exception(_parent, msg.str().c_str(), e);
			}
		}

		// End timestamp and elapsed time
		gettimeofday(&end, NULL);
		size_t elapsed = ELAPSED_TIME_MS(start, end);
		if(elapsed < _polling) {
			msleep(_polling - elapsed);
		} else {
			if(_parent->get_logger()->is_debug_enabled()) {
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Polling cycle took more (" << elapsed << " ms) than polling period (" << _polling << " ms)" << endl;
			}
		}
	}

	int *result = new int(0);
	return result;
}


// Millisecond sleep
void TM700Monitor::msleep(uint32_t msec) {
	if(msec <= 0)
		return;
	struct timespec st;
	struct timeval start, stop;
	gettimeofday(&start, NULL);
	// Setup delay
	st.tv_sec = msec / 1000;
	st.tv_nsec = (msec % 1000) * 1000000;

	while(1) {
		int ans = nanosleep(&st, NULL);
		if(ans == -1 && errno == EINTR) {
			// Nanosleep was interrupted by a signal
			gettimeofday(&stop, NULL);
			uint32_t rem = msec - ELAPSED_TIME_MS(start, stop);
			if(rem > 0) {
				st.tv_sec = rem / 1000;
				st.tv_nsec = (rem % 1000) * 1000000;
			} else {
				break;
			}
		} else {
			break;
		}
	}
}


// 5 point numerical derivative
double TM700Monitor::compute_5point_derivative(double h, const std::vector<double>& points) {
	if(points.size() < 5) {
		return 0.0;
	}
	return (-points[4] + 8.0 * points[3] - 8.0 * points[1] + points[0]) / (12.0 * h);
}


/*----- PROTECTED REGION END -----*/	//	TM700Srv::namespace_ending
} //	namespace
