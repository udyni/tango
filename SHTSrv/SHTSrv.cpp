/*----- PROTECTED REGION ID(SHTSrv.cpp) ENABLED START -----*/
// kate: replace-tabs off; indent-width 4; indent-mode cstyle; remove-trailing-spaces all; tab-indents on; tab-width 4
//=============================================================================
//
// file :        SHTSrv.cpp
//
// description : C++ source for the SHTSrv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SHTSrv are implemented in this file.
//
// project :     Sensiron SHT server
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SHTSrv.h>
#include <SHTSrvClass.h>

/*----- PROTECTED REGION END -----*/	//	SHTSrv.cpp

/**
 *  SHTSrv class description:
 *    Device server to acquire Sensiron SHT temperature and humidity sensors.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name    |  Method name
//================================================================
//  State           |  Inherited (no method)
//  Status          |  Inherited (no method)
//  getTemperature  |  get_temperature
//  getHumidity     |  get_humidity
//  getData         |  get_data
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  Temperature  |  Tango::DevFloat	Scalar
//  Humidity     |  Tango::DevFloat	Scalar
//  DewPoint     |  Tango::DevFloat	Scalar
//  Timestamp    |  Tango::DevULong	Scalar
//  BufferSize   |  Tango::DevLong	Scalar
//  FormatTypes  |  Tango::DevString	Spectrum  ( max = 3)
//  FormatSizes  |  Tango::DevULong	Spectrum  ( max = 3)
//================================================================

namespace SHTSrv_ns
{
/*----- PROTECTED REGION ID(SHTSrv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SHTSrv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SHTSrv::SHTSrv()
 *	Description : Constructors for a Tango device
 *                implementing the classSHTSrv
 */
//--------------------------------------------------------
SHTSrv::SHTSrv(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SHTSrv::constructor_1) ENABLED START -----*/
	wiringPiSetup();
	init_device();

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::constructor_1
}
//--------------------------------------------------------
SHTSrv::SHTSrv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(SHTSrv::constructor_2) ENABLED START -----*/
	wiringPiSetup();
	init_device();

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::constructor_2
}
//--------------------------------------------------------
SHTSrv::SHTSrv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(SHTSrv::constructor_3) ENABLED START -----*/
	wiringPiSetup();
	init_device();

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SHTSrv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SHTSrv::delete_device()
{
	DEBUG_STREAM << "SHTSrv::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SHTSrv::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	acq->terminate();
	int *retval;
	acq->join((void**)&retval);
	delete retval;

	CORBA::string_free(attr_FormatTypes_read[0]);
	CORBA::string_free(attr_FormatTypes_read[1]);
	CORBA::string_free(attr_FormatTypes_read[2]);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::delete_device
	delete[] attr_Temperature_read;
	delete[] attr_Humidity_read;
	delete[] attr_DewPoint_read;
	delete[] attr_Timestamp_read;
	delete[] attr_BufferSize_read;
	delete[] attr_FormatTypes_read;
	delete[] attr_FormatSizes_read;
}

//--------------------------------------------------------
/**
 *	Method      : SHTSrv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SHTSrv::init_device()
{
	DEBUG_STREAM << "SHTSrv::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SHTSrv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::init_device_before


	//	Get the device properties from database
	get_device_property();

	attr_Temperature_read = new Tango::DevFloat[1];
	attr_Humidity_read = new Tango::DevFloat[1];
	attr_DewPoint_read = new Tango::DevFloat[1];
	attr_Timestamp_read = new Tango::DevULong[1];
	attr_BufferSize_read = new Tango::DevLong[1];
	attr_FormatTypes_read = new Tango::DevString[3];
	attr_FormatSizes_read = new Tango::DevULong[3];
	//	No longer if mandatory property not set.
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(SHTSrv::init_device) ENABLED START -----*/

	attr_FormatTypes_read[0] = CORBA::string_dup("Tango::DevLong");
	attr_FormatTypes_read[1] = CORBA::string_dup("Tango::DevFloat");
	attr_FormatTypes_read[2] = CORBA::string_dup("Tango::DevFloat");
	attr_FormatSizes_read[0] = sizeof(Tango::DevLong);
	attr_FormatSizes_read[1] = sizeof(Tango::DevFloat);
	attr_FormatSizes_read[2] = sizeof(Tango::DevFloat);

	if(ringBufferLength <= 0)
		ringBufferLength = 1;
	if(samplingPeriod < 1000) {
		WARN_STREAM << "SHTSrv::init_device(): sampling period cannot be less than 1000, but found " << samplingPeriod << ". Forcing 1000." << endl;
		samplingPeriod = 1000;
	}
	//	Initialize device
	acq = new SHTAcq(ringBufferLength, samplingPeriod, clockPin, dataPin);

	set_state(Tango::ON);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SHTSrv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SHTSrv::get_device_property()
{
	/*----- PROTECTED REGION ID(SHTSrv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("SamplingPeriod"));
	dev_prop.push_back(Tango::DbDatum("ClockPin"));
	dev_prop.push_back(Tango::DbDatum("DataPin"));
	dev_prop.push_back(Tango::DbDatum("RingBufferLength"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on SHTSrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SHTSrvClass	*ds_class =
			(static_cast<SHTSrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize SamplingPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  samplingPeriod;
		else {
			//	Try to initialize SamplingPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  samplingPeriod;
		}
		//	And try to extract SamplingPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  samplingPeriod;

		//	Try to initialize ClockPin from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clockPin;
		else {
			//	Try to initialize ClockPin from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clockPin;
		}
		//	And try to extract ClockPin value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clockPin;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize DataPin from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dataPin;
		else {
			//	Try to initialize DataPin from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dataPin;
		}
		//	And try to extract DataPin value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dataPin;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize RingBufferLength from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  ringBufferLength;
		else {
			//	Try to initialize RingBufferLength from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  ringBufferLength;
		}
		//	And try to extract RingBufferLength value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  ringBufferLength;

	}

	/*----- PROTECTED REGION ID(SHTSrv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init
// 	DEBUG_STREAM << "Property 'samplingPeriod': " << samplingPeriod << endl;
// 	DEBUG_STREAM << "Property 'ringBufferLength': " << ringBufferLength << endl;
// 	DEBUG_STREAM << "Property 'clockPin': " << clockPin << endl;
// 	DEBUG_STREAM << "Property 'dataPin': " << dataPin << endl;

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : SHTSrv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void SHTSrv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(SHTSrv::check_mandatory_property) ENABLED START -----*/
		//cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	SHTSrv::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : SHTSrv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SHTSrv::always_executed_hook()
{
// 	DEBUG_STREAM << "SHTSrv::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"SHTSrv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(SHTSrv::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SHTSrv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SHTSrv::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "SHTSrv::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute Temperature related method
 *	Description: Temperature in degrees celsius
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SHTSrv::read_Temperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_Temperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_Temperature) ENABLED START -----*/

	{
		omni_mutex_lock(acq->get_lock());
		if(acq->get_buffer().size() > 0)
			attr_Temperature_read[0] = acq->get_buffer().back().t;
		else
			attr_Temperature_read[0] = 0.0;
	}

	//	Set the attribute value
	attr.set_value(attr_Temperature_read);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_Temperature
}
//--------------------------------------------------------
/**
 *	Read attribute Humidity related method
 *	Description: Relative humidity
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SHTSrv::read_Humidity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_Humidity(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_Humidity) ENABLED START -----*/

	{
		omni_mutex_lock(acq->get_lock());
		if(acq->get_buffer().size() > 0)
			attr_Humidity_read[0] = acq->get_buffer().back().h;
		else
			attr_Humidity_read[0] = 0.0;
	}

	//	Set the attribute value
	attr.set_value(attr_Humidity_read);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_Humidity
}
//--------------------------------------------------------
/**
 *	Read attribute DewPoint related method
 *	Description: Dew point in degrees celsius
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SHTSrv::read_DewPoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_DewPoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_DewPoint) ENABLED START -----*/

	float t = 0.0;
	float h = 0.0;
	{
		omni_mutex_lock(acq->get_lock());
		if(acq->get_buffer().size() > 0) {
			t = acq->get_buffer().back().t;
			h = acq->get_buffer().back().h;
		}
	}

	attr_DewPoint_read[0] = acq->computeD(t, h);

	//	Set the attribute value
	attr.set_value(attr_DewPoint_read);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_DewPoint
}
//--------------------------------------------------------
/**
 *	Read attribute Timestamp related method
 *	Description: Timestamp in ms of last sensor acquisition
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SHTSrv::read_Timestamp(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_Timestamp(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_Timestamp) ENABLED START -----*/

	{
		omni_mutex_lock(acq->get_lock());
		if(acq->get_buffer().size() > 0)
			attr_Timestamp_read[0] = acq->get_buffer().back().timestamp;
		else
			attr_Timestamp_read[0] = 0;
	}

	//	Set the attribute value
	attr.set_value(attr_Timestamp_read);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_Timestamp
}
//--------------------------------------------------------
/**
 *	Read attribute BufferSize related method
 *	Description:
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SHTSrv::read_BufferSize(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_BufferSize(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_BufferSize) ENABLED START -----*/

	{
		omni_mutex_lock(acq->get_lock());
		attr_BufferSize_read[0] = acq->get_buffer().size();
	}

	//	Set the attribute value
	attr.set_value(attr_BufferSize_read);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_BufferSize
}
//--------------------------------------------------------
/**
 *	Read attribute FormatTypes related method
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SHTSrv::read_FormatTypes(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_FormatTypes(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_FormatTypes) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_FormatTypes_read, 3);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_FormatTypes
}
//--------------------------------------------------------
/**
 *	Read attribute FormatSizes related method
 *	Description:
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SHTSrv::read_FormatSizes(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SHTSrv::read_FormatSizes(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SHTSrv::read_FormatSizes) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_FormatSizes_read, 3);

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::read_FormatSizes
}

//--------------------------------------------------------
/**
 *	Method      : SHTSrv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SHTSrv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SHTSrv::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command getTemperature related method
 *	Description: Return n samples up to the given timestamp. If the timestamp is 0 it returns the last n samples. If the timestamp is too old it returns an empty array.
 *
 *	@param argin getTemperature(timestamp, n)
 *	@returns Array of temperature values
 */
//--------------------------------------------------------
Tango::DevVarFloatArray *SHTSrv::get_temperature(const Tango::DevVarLongArray *argin)
{
	Tango::DevVarFloatArray *argout;
	DEBUG_STREAM << "SHTSrv::getTemperature()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SHTSrv::get_temperature) ENABLED START -----*/

	if(argin->length() < 2)
		Tango::Except::throw_exception("Bad parameter", "This command requires two input parameters.", "SHTSrv::getTemperature()");

	time_t timestamp = (time_t)(*argin)[0];
	Tango::DevLong nsamples = (*argin)[1];

	{
		// Get lock on ring buffer
		omni_mutex_lock(acq->get_lock());

		// Get sample queue
		const std::deque<SHTSample>& queue = acq->get_buffer();

		// Vars
		ssize_t begin = 0;
		ssize_t end = 0;

		if(queue.size() > 0) {

			if(timestamp == 0) {
				// Timestamp is zero. Return the last n samples.
				if(nsamples < 0)
					nsamples = -nsamples;
				if(queue.size() < (size_t)nsamples)
					// Reduce the number of samples if it's more than the available number
					nsamples = queue.size();
				else
					begin = queue.size() - nsamples;

			} else if(queue.front().timestamp > timestamp || queue.back().timestamp < timestamp) {
				// Timestamp too old or in the future. Return an empty array.
				nsamples = 0;

			} else {
				// Search for the nearest timestamp
				begin = 0;
				end = queue.size() - 1;
				while(end != begin && (end - begin) > 1) {
					ssize_t med = (end + begin) / 2;
					if(timestamp > queue[med].timestamp)
						begin = med;
					else
						end = med;
				}

				if(nsamples >= 0) {
					// With positive number of samples, return samples after timestamp
					// Return sample interval [end, min(end + nsamples, queue.size()) - 1
					if(queue[end].timestamp == timestamp)
						end++;
					begin = end;
					if(begin + nsamples > (ssize_t)queue.size())
						nsamples = queue.size() - begin;

				} else {
					// With negative numver of samples, return samples up to timestamp
					// Return samples interval [max(0, begin - nsamples + 1), begin]
					nsamples = -nsamples;
					if(begin - nsamples + 1 < 0) {
						nsamples = begin + 1;
						begin = 0;
					} else {
						begin = begin - nsamples + 1;
					}
				}
			}
		} else {
			nsamples = 0;
		}

		// Allocate output buffer
		argout = new Tango::DevVarFloatArray(nsamples);
		argout->length(nsamples);

		// Copy data
		for(size_t i = 0; i < (size_t)nsamples; i++)
			(*argout)[i] = queue[begin+i].t;

	} // Release lock

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::get_temperature
	return argout;
}
//--------------------------------------------------------
/**
 *	Command getHumidity related method
 *	Description: Return n samples up to the given timestamp. If the timestamp is 0 it returns the last n samples. If the timestamp is too old it returns an empty array.
 *
 *	@param argin getHumidity(timestamp, n)
 *	@returns Array of humidity values
 */
//--------------------------------------------------------
Tango::DevVarFloatArray *SHTSrv::get_humidity(const Tango::DevVarLongArray *argin)
{
	Tango::DevVarFloatArray *argout;
	DEBUG_STREAM << "SHTSrv::getHumidity()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SHTSrv::get_humidity) ENABLED START -----*/

	if(argin->length() < 2)
		Tango::Except::throw_exception("Bad parameter", "This command requires two input parameters.", "SHTSrv::getHumidity()");

	time_t timestamp = (time_t)(*argin)[0];
	Tango::DevLong nsamples = (*argin)[1];

	{
		// Get lock on ring buffer
		omni_mutex_lock(acq->get_lock());

		// Get sample queue
		const std::deque<SHTSample>& queue = acq->get_buffer();

		// Vars
		ssize_t begin = 0;
		ssize_t end = 0;

		if(queue.size() > 0) {

			if(timestamp == 0) {
				// Timestamp is zero. Return the last n samples.
				if(nsamples < 0)
					nsamples = -nsamples;
				if(queue.size() < (size_t)nsamples)
					// Reduce the number of samples if it's more than the available number
					nsamples = queue.size();
				else
					begin = queue.size() - nsamples;

			} else if(queue.front().timestamp > timestamp || queue.back().timestamp < timestamp) {
				// Timestamp too old or in the future. Return an empty array.
				nsamples = 0;

			} else {
				// Search for the nearest timestamp
				begin = 0;
				end = queue.size() - 1;
				while(end != begin && (end - begin) > 1) {
					ssize_t med = (end + begin) / 2;
					if(timestamp > queue[med].timestamp)
						begin = med;
					else
						end = med;
				}

				if(nsamples >= 0) {
					// With positive number of samples, return samples after timestamp
					// Return sample interval [end, min(end + nsamples, queue.size()) - 1
					if(queue[end].timestamp == timestamp)
						end++;
					begin = end;
					if(begin + nsamples > (ssize_t)queue.size())
						nsamples = queue.size() - begin;

				} else {
					// With negative numver of samples, return samples up to timestamp
					// Return samples interval [max(0, begin - nsamples + 1), begin]
					nsamples = -nsamples;
					if(begin - nsamples + 1 < 0) {
						nsamples = begin + 1;
						begin = 0;
					} else {
						begin = begin - nsamples + 1;
					}
				}
			}
		} else {
			nsamples = 0;
		}

		// Allocate output buffer
		argout = new Tango::DevVarFloatArray(nsamples);
		argout->length(nsamples);

		// Copy data
		for(size_t i = 0; i < (size_t)nsamples; i++)
			(*argout)[i] = queue[begin+i].h;

	} // Release lock

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::get_humidity
	return argout;
}
//--------------------------------------------------------
/**
 *	Command getData related method
 *	Description: Return n samples up to the given timestamp, in encoded form, with timestamp, temperature and humidity. If the timestamp is 0 it returns the last n samples. If the timestamp is too old it returns an empty array.
 *
 *	@param argin getTemperature(timestamp, n)
 *	@returns Encoded output with triplets (uint32, float, float) representing respectively (timestamp, temperature, humidity)
 */
//--------------------------------------------------------
Tango::DevVarCharArray *SHTSrv::get_data(const Tango::DevVarLongArray *argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "SHTSrv::getData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SHTSrv::get_data) ENABLED START -----*/

	if(argin->length() < 2)
		Tango::Except::throw_exception("Bad parameter", "This command requires two input parameters.", "SHTSrv::getData()");

	time_t timestamp = (time_t)(*argin)[0];
	Tango::DevLong nsamples = (*argin)[1];

	{
		// Get lock on ring buffer
		omni_mutex_lock(acq->get_lock());

		// Get sample queue
		const std::deque<SHTSample>& queue = acq->get_buffer();

		// Vars
		ssize_t begin = 0;
		ssize_t end = 0;

		if(queue.size() > 0) {

			if(timestamp == 0) {
				// Timestamp is zero. Return the last n samples.
				if(nsamples < 0)
					nsamples = -nsamples;
				if(queue.size() < (size_t)nsamples)
					// Reduce the number of samples if it's more than the available number
					nsamples = queue.size();
				else
					begin = queue.size() - nsamples;

			} else if(queue.front().timestamp > timestamp || queue.back().timestamp < timestamp) {
				// Timestamp too old or in the future. Return an empty array.
				nsamples = 0;

			} else {
				// Search for the nearest timestamp
				begin = 0;
				end = queue.size() - 1;
				while(end != begin && (end - begin) > 1) {
					ssize_t med = (end + begin) / 2;
					if(timestamp > queue[med].timestamp)
						begin = med;
					else
						end = med;
				}

				if(nsamples >= 0) {
					// With positive number of samples, return samples after timestamp
					// Return sample interval [end, min(end + nsamples, queue.size()) - 1
					if(queue[end].timestamp == timestamp)
						end++;
					begin = end;
					if(begin + nsamples > (ssize_t)queue.size())
						nsamples = queue.size() - begin;

				} else {
					// With negative numver of samples, return samples up to timestamp
					// Return samples interval [max(0, begin - nsamples + 1), begin]
					nsamples = -nsamples;
					if(begin - nsamples + 1 < 0) {
						nsamples = begin + 1;
						begin = 0;
					} else {
						begin = begin - nsamples + 1;
					}
				}
			}
		} else {
			nsamples = 0;
		}

		// Allocate output buffer
		size_t samplesize = sizeof(Tango::DevLong) + sizeof(Tango::DevFloat) + sizeof(Tango::DevFloat);
		argout = new Tango::DevVarCharArray(nsamples * samplesize);
		argout->length(nsamples * samplesize);

		// Copy data
		Tango::DevUChar *ptr = (Tango::DevUChar*)argout->get_buffer();
		for(size_t i = 0; i < (size_t)nsamples; i++) {
			*((Tango::DevLong*)(ptr + i * samplesize)) = queue[begin+i].timestamp;
			*((Tango::DevFloat*)(ptr + i * samplesize + sizeof(Tango::DevLong))) = queue[begin+i].t;
			*((Tango::DevFloat*)(ptr + i * samplesize + sizeof(Tango::DevLong) + sizeof(Tango::DevFloat))) = queue[begin+i].h;
		}

	} // Release lock

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::get_data
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : SHTSrv::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SHTSrv::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(SHTSrv::add_dynamic_commands) ENABLED START -----*/

	//	Add your own code to create and add dynamic commands if any

	/*----- PROTECTED REGION END -----*/	//	SHTSrv::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SHTSrv::namespace_ending) ENABLED START -----*/

//	Additional Methods
void *SHTAcq::run_undetached(void* ptr) {

	struct timeval prev, last;
	struct timespec st = {0, 250000000};  // 250 ms

	// Initialize timeval structures
	// NOTE: the first sample is acquired "period" ms after the thread is started
	gettimeofday(&prev, NULL);

	while(!_terminate) {

		// Check if the period elapsed
		gettimeofday(&last, NULL);
		int elapsed = ELAPSED_TIME_MS(prev, last);
		if(elapsed >= (int)_period) {
			// Acquire sensor
			if(sensor->measure()) {
				// Measure error. Reset sensor.
				sensor->init();
				continue;
			}

			// Store data in circular buffer
			{
				omni_mutex_lock(this->_lock);

				// Add it to deque
				ring_buffer.push_back(SHTSample(last.tv_sec, sensor->getT(), sensor->getH()));

				// If needed, remove the oldest one
				if(ring_buffer.size() > _length) {
					ring_buffer.pop_front();
				}
			}

			// Update prev
			prev = last;
		}
		// Sleep
		nanosleep(&st, NULL);
	}

	int *retval = new int();
	*retval = 0;
	return (void*)retval;
}

/*----- PROTECTED REGION END -----*/	//	SHTSrv::namespace_ending
} //	namespace
