/*----- PROTECTED REGION ID(MercurySrv.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        MercurySrv.cpp
//
// description : C++ source for the MercurySrv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               MercurySrv are implemented in this file.
//
// project :     Mercury C863 Server
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <MercurySrv.h>
#include <MercurySrvClass.h>

/*----- PROTECTED REGION END -----*/	//	MercurySrv.cpp

/**
 *  MercurySrv class description:
 *    Tango device server for a Mercury C863 motion controller
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  setHome       |  set_home
//  goHome        |  go_home
//  timeStep      |  time_step
//  posStep       |  pos_step
//  Stop          |  stop
//  Abort         |  abort
//  Reset         |  reset
//  StartMacro    |  start_macro
//  StopMacro     |  stop_macro
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  Acceleration  |  Tango::DevFloat	Scalar
//  Velocity      |  Tango::DevFloat	Scalar
//  RawPosition   |  Tango::DevDouble	Scalar
//  Position      |  Tango::DevDouble	Scalar
//  Time          |  Tango::DevDouble	Scalar
//  HomePosition  |  Tango::DevDouble	Scalar
//  StageName     |  Tango::DevString	Scalar
//  LastError     |  Tango::DevLong	Scalar
//  MotionDone    |  Tango::DevBoolean	Scalar
//  Macro         |  Tango::DevString	Scalar
//================================================================

namespace MercurySrv_ns
{
/*----- PROTECTED REGION ID(MercurySrv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	MercurySrv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : MercurySrv::MercurySrv()
 *	Description : Constructors for a Tango device
 *                implementing the classMercurySrv
 */
//--------------------------------------------------------
MercurySrv::MercurySrv(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(MercurySrv::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::constructor_1
}
//--------------------------------------------------------
MercurySrv::MercurySrv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(MercurySrv::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::constructor_2
}
//--------------------------------------------------------
MercurySrv::MercurySrv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(MercurySrv::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : MercurySrv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void MercurySrv::delete_device()
{
	DEBUG_STREAM << "MercurySrv::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	dev->terminate();
	int *retval;
	dev->join((void**)&retval);
	delete retval;
	
	// Delete strings
	if(*attr_StageName_read) {
		CORBA::string_free(*attr_StageName_read);
	}
	delete attr_StageName_read;
	if(*attr_Macro_read) {
		CORBA::string_free(*attr_Macro_read);
	}
	delete attr_Macro_read;

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::delete_device
	delete[] attr_Acceleration_read;
	delete[] attr_Velocity_read;
	delete[] attr_RawPosition_read;
	delete[] attr_Position_read;
	delete[] attr_Time_read;
	delete[] attr_HomePosition_read;
	delete[] attr_LastError_read;
	delete[] attr_MotionDone_read;
}

//--------------------------------------------------------
/**
 *	Method      : MercurySrv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void MercurySrv::init_device()
{
	DEBUG_STREAM << "MercurySrv::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	attr_StageName_read = new Tango::DevString;
	*attr_StageName_read = CORBA::string_dup("DEFAULT_STAGE");
	attr_Macro_read = new Tango::DevString;
	*attr_Macro_read = CORBA::string_dup("");

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_Acceleration_read = new Tango::DevFloat[1];
	attr_Velocity_read = new Tango::DevFloat[1];
	attr_RawPosition_read = new Tango::DevDouble[1];
	attr_Position_read = new Tango::DevDouble[1];
	attr_Time_read = new Tango::DevDouble[1];
	attr_HomePosition_read = new Tango::DevDouble[1];
	attr_LastError_read = new Tango::DevLong[1];
	attr_MotionDone_read = new Tango::DevBoolean[1];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(MercurySrv::init_device) ENABLED START -----*/

	// Set state to INIT
	set_state(Tango::INIT);

	// Read home position from DB
	if (Tango::Util::instance()->_UseDb==true) {
		try {
			// Prepare
			Tango::DbData dev_prop;
			dev_prop.push_back(Tango::DbDatum("HomePosition"));
			// Get data from DB
			get_db_device()->get_property(dev_prop);
			// Extract data
			if(dev_prop[0].is_empty() == false) {
				dev_prop[0] >> (*attr_HomePosition_read);
			} else {
				*attr_HomePosition_read = 0.0;
			}
		} catch(Tango::DevFailed &e) {
			WARN_STREAM << "Failed to read home position from database. Initializing at zero." << endl;
			*attr_HomePosition_read = 0.0;
		}
	}

	//	Initialize device
	dev = new MercuryComm(this);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : MercurySrv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void MercurySrv::get_device_property()
{
	/*----- PROTECTED REGION ID(MercurySrv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Proxy"));
	dev_prop.push_back(Tango::DbDatum("Address"));
	dev_prop.push_back(Tango::DbDatum("Referenced"));
	dev_prop.push_back(Tango::DbDatum("TimeConversion"));
	dev_prop.push_back(Tango::DbDatum("PollingPeriod"));
	dev_prop.push_back(Tango::DbDatum("StageConfiguration"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on MercurySrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		MercurySrvClass	*ds_class =
			(static_cast<MercurySrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Proxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxy;
		else {
			//	Try to initialize Proxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxy;
		}
		//	And try to extract Proxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxy;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize Address from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  address;
		else {
			//	Try to initialize Address from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  address;
		}
		//	And try to extract Address value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  address;

		//	Try to initialize Referenced from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  referenced;
		else {
			//	Try to initialize Referenced from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  referenced;
		}
		//	And try to extract Referenced value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  referenced;

		//	Try to initialize TimeConversion from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  timeConversion;
		else {
			//	Try to initialize TimeConversion from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  timeConversion;
		}
		//	And try to extract TimeConversion value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeConversion;

		//	Try to initialize PollingPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pollingPeriod;
		else {
			//	Try to initialize PollingPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pollingPeriod;
		}
		//	And try to extract PollingPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pollingPeriod;

		//	Try to initialize StageConfiguration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stageConfiguration;
		else {
			//	Try to initialize StageConfiguration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stageConfiguration;
		}
		//	And try to extract StageConfiguration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stageConfiguration;

	}

	/*----- PROTECTED REGION ID(MercurySrv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : MercurySrv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void MercurySrv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(MercurySrv::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	MercurySrv::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : MercurySrv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void MercurySrv::always_executed_hook()
{
	DEBUG_STREAM << "MercurySrv::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"MercurySrv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(MercurySrv::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : MercurySrv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void MercurySrv::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "MercurySrv::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : MercurySrv::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void MercurySrv::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "MercurySrv::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::write_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute Acceleration related method
 *	Description: Stage acceleration
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_Acceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_Acceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_Acceleration) ENABLED START -----*/

	*attr_Acceleration_read = dev->getAcceleration();

	//	Set the attribute value
	attr.set_value(attr_Acceleration_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_Acceleration
}
//--------------------------------------------------------
/**
 *	Write attribute Acceleration related method
 *	Description: Stage acceleration
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::write_Acceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MercurySrv::write_Acceleration(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MercurySrv::write_Acceleration) ENABLED START -----*/

	dev->setAcceleration(w_val);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_Acceleration
}
//--------------------------------------------------------
/**
 *	Read attribute Velocity related method
 *	Description: Stage velocity
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_Velocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_Velocity(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_Velocity) ENABLED START -----*/

	*attr_Velocity_read = dev->getVelocity();

	//	Set the attribute value
	attr.set_value(attr_Velocity_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_Velocity
}
//--------------------------------------------------------
/**
 *	Write attribute Velocity related method
 *	Description: Stage velocity
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::write_Velocity(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MercurySrv::write_Velocity(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MercurySrv::write_Velocity) ENABLED START -----*/

	dev->setVelocity(w_val);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_Velocity
}
//--------------------------------------------------------
/**
 *	Read attribute RawPosition related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_RawPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_RawPosition(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_RawPosition) ENABLED START -----*/

	*attr_RawPosition_read = dev->getPosition();

	//	Set the attribute value
	attr.set_value(attr_RawPosition_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_RawPosition
}
//--------------------------------------------------------
/**
 *	Write attribute RawPosition related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::write_RawPosition(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MercurySrv::write_RawPosition(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MercurySrv::write_RawPosition) ENABLED START -----*/

	dev->moveAbsolute(w_val);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_RawPosition
}
//--------------------------------------------------------
/**
 *	Read attribute Position related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_Position(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_Position(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_Position) ENABLED START -----*/

	*attr_Position_read = dev->getPosition() - *attr_HomePosition_read;

	//	Set the attribute value
	attr.set_value(attr_Position_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_Position
}
//--------------------------------------------------------
/**
 *	Write attribute Position related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::write_Position(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MercurySrv::write_Position(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MercurySrv::write_Position) ENABLED START -----*/

	dev->moveAbsolute(w_val + *attr_HomePosition_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_Position
}
//--------------------------------------------------------
/**
 *	Read attribute Time related method
 *	Description: Time in femtoseconds (for 2 way pass)
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_Time(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_Time(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_Time) ENABLED START -----*/

	*attr_Time_read = (dev->getPosition() - *attr_HomePosition_read) * timeConversion;

	//	Set the attribute value
	attr.set_value(attr_Time_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_Time
}
//--------------------------------------------------------
/**
 *	Write attribute Time related method
 *	Description: Time in femtoseconds (for 2 way pass)
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::write_Time(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MercurySrv::write_Time(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MercurySrv::write_Time) ENABLED START -----*/

	dev->moveAbsolute(w_val / timeConversion + *attr_HomePosition_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_Time
}
//--------------------------------------------------------
/**
 *	Read attribute HomePosition related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_HomePosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_HomePosition(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_HomePosition) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(attr_HomePosition_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_HomePosition
}
//--------------------------------------------------------
/**
 *	Read attribute StageName related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_StageName(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_StageName(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_StageName) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(attr_StageName_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_StageName
}
//--------------------------------------------------------
/**
 *	Read attribute LastError related method
 *	Description: Store the last error got from the controller
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_LastError(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_LastError(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_LastError) ENABLED START -----*/

	*attr_LastError_read = dev->getLastError();

	//	Set the attribute value
	attr.set_value(attr_LastError_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_LastError
}
//--------------------------------------------------------
/**
 *	Read attribute MotionDone related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_MotionDone(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_MotionDone(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_MotionDone) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_MotionDone_read);
	
	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_MotionDone
}
//--------------------------------------------------------
/**
 *	Read attribute Macro related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::read_Macro(Tango::Attribute &attr)
{
	DEBUG_STREAM << "MercurySrv::read_Macro(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(MercurySrv::read_Macro) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_Macro_read);
	
	/*----- PROTECTED REGION END -----*/	//	MercurySrv::read_Macro
}
//--------------------------------------------------------
/**
 *	Write attribute Macro related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void MercurySrv::write_Macro(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "MercurySrv::write_Macro(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(MercurySrv::write_Macro) ENABLED START -----*/
	
	if(*attr_Macro_read != NULL)
		CORBA::string_free(*attr_Macro_read);
	*attr_Macro_read = CORBA::string_dup(w_val);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::write_Macro
}

//--------------------------------------------------------
/**
 *	Method      : MercurySrv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void MercurySrv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(MercurySrv::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command setHome related method
 *	Description: Set stage home to the current position
 *
 */
//--------------------------------------------------------
void MercurySrv::set_home()
{
	DEBUG_STREAM << "MercurySrv::setHome()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::set_home) ENABLED START -----*/

	// Get current position
	Tango::DevDouble home_pos = (Tango::DevDouble)dev->getPosition();

	// Save home position to database
	if(Tango::Util::instance()->_UseDb==true) {
		// Prepare data
		Tango::DbData dev_prop;
		Tango::DbDatum pos = Tango::DbDatum("HomePosition");
		DEBUG_STREAM << "Saving home position position: " << home_pos << endl;
		pos << home_pos;
		dev_prop.push_back(pos);
		// Write data to DB
		get_db_device()->put_property(dev_prop);
	}

	// Update local variable
	*attr_HomePosition_read = home_pos;

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::set_home
}
//--------------------------------------------------------
/**
 *	Command goHome related method
 *	Description: Go to home position
 *
 */
//--------------------------------------------------------
void MercurySrv::go_home()
{
	DEBUG_STREAM << "MercurySrv::goHome()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::go_home) ENABLED START -----*/

	dev->moveAbsolute(*attr_HomePosition_read);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::go_home
}
//--------------------------------------------------------
/**
 *	Command timeStep related method
 *	Description: Make a relative move in time
 *
 *	@param argin Time step in fs
 */
//--------------------------------------------------------
void MercurySrv::time_step(Tango::DevDouble argin)
{
	DEBUG_STREAM << "MercurySrv::timeStep()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::time_step) ENABLED START -----*/

	dev->moveRelative(argin / timeConversion);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::time_step
}
//--------------------------------------------------------
/**
 *	Command posStep related method
 *	Description: Make a relative move in position
 *
 *	@param argin Step in phys unit
 */
//--------------------------------------------------------
void MercurySrv::pos_step(Tango::DevDouble argin)
{
	DEBUG_STREAM << "MercurySrv::posStep()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::pos_step) ENABLED START -----*/

	dev->moveRelative(argin);

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::pos_step
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stop motion
 *
 */
//--------------------------------------------------------
void MercurySrv::stop()
{
	DEBUG_STREAM << "MercurySrv::Stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::stop) ENABLED START -----*/

	dev->stop();

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::stop
}
//--------------------------------------------------------
/**
 *	Command Abort related method
 *	Description: Abort motion abruptly
 *
 */
//--------------------------------------------------------
void MercurySrv::abort()
{
	DEBUG_STREAM << "MercurySrv::Abort()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::abort) ENABLED START -----*/

	dev->abort();

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::abort
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset controller. Restore configuration from database and search again for reference (if needed).
 *
 */
//--------------------------------------------------------
void MercurySrv::reset()
{
	DEBUG_STREAM << "MercurySrv::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::reset) ENABLED START -----*/

	dev->reset();

	/*----- PROTECTED REGION END -----*/	//	MercurySrv::reset
}
//--------------------------------------------------------
/**
 *	Command StartMacro related method
 *	Description: Start the macro configured in the attribute Macro
 *
 */
//--------------------------------------------------------
void MercurySrv::start_macro()
{
	DEBUG_STREAM << "MercurySrv::StartMacro()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::start_macro) ENABLED START -----*/
	
	Tango::Except::throw_exception(
			(const char*)"Not implemented",
			(const char*)"Macro functionality not yet implemented",
			(const char*)"MercurySrv::start_macro()");
		
	
	/*----- PROTECTED REGION END -----*/	//	MercurySrv::start_macro
}
//--------------------------------------------------------
/**
 *	Command StopMacro related method
 *	Description: Start the macro configured in the attribute Macro
 *
 */
//--------------------------------------------------------
void MercurySrv::stop_macro()
{
	DEBUG_STREAM << "MercurySrv::StopMacro()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(MercurySrv::stop_macro) ENABLED START -----*/
	
	Tango::Except::throw_exception(
			(const char*)"Not implemented",
			(const char*)"Macro functionality not yet implemented",
			(const char*)"MercurySrv::stop_macro()");
	
	/*----- PROTECTED REGION END -----*/	//	MercurySrv::stop_macro
}
//--------------------------------------------------------
/**
 *	Method      : MercurySrv::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void MercurySrv::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(MercurySrv::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	MercurySrv::add_dynamic_commands
}

/*----- PROTECTED REGION ID(MercurySrv::namespace_ending) ENABLED START -----*/


// MercuryComm constructor
MercuryComm::MercuryComm(MercurySrv* parent) :
	_terminate(false),
	_old_controller(false),
	_address(parent->address),
	_polling(parent->pollingPeriod),
	_position(0.0),
	_factor(0.0),
	_lasterror(0),
	_dev(NULL),
	_parent(parent),
	_need_refsearch(false)
{
	// Connect to proxy
	_dev = new Tango::DeviceProxy(parent->proxy);

	// Try to find the controller. If not found we try to reconnect the serial line to ensure good communication.
	try {
		checkCtrlType();
	} catch(Tango::DevFailed &e) {
		_dev->command_inout("Disconnect");
		_dev->command_inout("Connect");
	}

	// Initialization of position timestamp
	gettimeofday(&_pos_timestamp, NULL);

	// Convert configuration string from DB to configuration map
	string2map(_parent->stageConfiguration, _config);

	// Start monitor thread
	this->start_undetached();
}


// MercuryComm destructor
MercuryComm::~MercuryComm() {
	if(_dev)
		delete _dev;
	_dev = NULL;
}


// Initialize mercury controller
void MercuryComm::init() {

	// First check the type of connected controller
	_old_controller = checkCtrlType();

	// If we are using the new Mercury we need the axis name
	if(!_old_controller) {
		std::string rsp = sendCommandWithResponse_new("SAI?");
		strncpy(_axisid, rsp.c_str(), 8);
		_axisid[8] = 0x00;
		
		// Update status to reflect controller found
		_parent->set_status("Found C-863 Mercury controller. Loading configuration...");
	} else {
		_parent->set_status("Found C-862 Mercury controller. Loading configuration...");
	}

	// Check if controller is initialized or not
	if(_old_controller) {
		if(getStatusByte_old(O_MERCURY_1F) & O_MERCURY_MOTOFF) {
			// Servo-motor off. We assume the controller was reset. Turn motor on.
			sendCommand_old("MN");

			// If needed, start reference search
			if(_parent->referenced) {
				_need_refsearch = true;
			}

			// Update configuration
			writeConfiguration();

		} else {
			// Controller was not reset. We keep current configuration.
			//checkConfiguration(); // TODO
		}

	} else {
		std::string rsp = sendCommandWithResponse_new("FRF?");
		int status;
		int ans = sscanf(rsp.c_str(), "%*[^=]=%d", &status);

		// Turn motor on
		std::stringstream cmd;
		cmd << "SVO " << _axisid << " 1";
		sendCommand_new(cmd.str());

		if(ans == 1) {
			if(status == 0) {
				// Update configuration
				writeConfiguration();

				// Not referenced. Book a reference move or set position
				if(_parent->referenced) {
					// Set mode as referenced
					std::stringstream cmd;
					cmd << "RON " << _axisid << " 1";
					sendCommand_new(cmd.str());
					// Absolute reference needed, book a ref move
					_need_refsearch = true;
				} else {
					// Set axis as referenced to the current position
					std::stringstream cmd;
					cmd << "RON " << _axisid << " 0";
					sendCommand_new(cmd.str());
					cmd.str("");
					cmd << "POS " << _axisid << " 0";
					sendCommand_new(cmd.str());
				}

			} else {
				// Already referenced. Controller was not reset. We keep current configuration
				//checkConfiguration();  // TODO
			}
		} else {
			// Parsing failed
			std::stringstream msg;
			msg << "Failed to read reference status from controller. Response was: '" << rsp << "'";
			Tango::Except::throw_exception( 
					(const char*)"Read failed",
					msg.str(),
					(const char*)"MercuryComm::init()");
		}
	}

	// Update status
	_parent->set_status("Configuration loaded. Restoring memorized attributes...");

	// Restore memorized attributes
	restoreMemAttributes();
}


// Restore memorized attributes
void MercuryComm::restoreMemAttributes() {
	// Restore velocity
	Tango::WAttribute &vel_att = _parent->get_device_attr()->get_w_attr_by_name("Velocity");
	if(vel_att.is_memorized()) {
		std::string mem_value = vel_att.get_mem_value();
		if(mem_value != Tango::MemNotUsed) {
			Tango::DevDouble vel_value;
			TangoSys_MemStream str;
			str << mem_value << ends;
			if(str >> vel_value)
				setVelocity(vel_value);
			else
				_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to restore velocity from memorized value." << endl;
		}
	}

	// Restore acceleration
	Tango::WAttribute &acc_att = _parent->get_device_attr()->get_w_attr_by_name("Acceleration");
	if(acc_att.is_memorized()) {
		std::string mem_value = acc_att.get_mem_value();
		if(mem_value != Tango::MemNotUsed) {
			Tango::DevDouble acc_value;
			TangoSys_MemStream str;
			str << mem_value << ends;
			if(str >> acc_value)
				setAcceleration(acc_value);
			else
				_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to restore velocity from memorized value." << endl;
		}
	}
}


// Check controller type (return true if the controller is old type)
bool MercuryComm::checkCtrlType() {
	try {
		// Try to read position from old controller
		std::string rsp = this->sendCommandWithResponse_old("TP");

		// Analyze response (should be in the form P:+/-000000000)
		int pos = 0;
		int ans = sscanf(rsp.c_str(), "P:%d", &pos);
		if(ans != 1) {
			// Parse failed
			std::stringstream msg;
			msg << "Cannot parse response from controller. Response was: '" << rsp << "'";
			Tango::Except::throw_exception(
					(const char*)"Parse failed",
					msg.str(),
					(const char*)"MercuryComm::init()");
		}
		return true;

	} catch(Tango::DevFailed &e) {
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Error[" << e.errors[0].origin << " ]: " << e.errors[0].desc << endl;
		// Read failed, may be a new controller
		try {
			std::string rsp = this->sendCommandWithResponse_new("POS?");

			// Analyze response (should be in the form 1=%f)
			float pos = 0;
			int ans = sscanf(rsp.c_str(), "%*[^=]=%f", &pos);
			if(ans != 1) {
				// Parse failed
				std::stringstream msg;
				msg << "Cannot parse response from controller. Response was: '" << rsp << "'";
				Tango::Except::throw_exception(
						(const char*)"Parse failed",
						msg.str(),
						(const char*)"MercuryComm::init()");
			}
			// Read error flag and reset it if needed
			if(getStatus_new() & N_MERCURY_ERROR) {
				// Error setting parameter. Get error code.
				std::string rsp = sendCommandWithResponse_new("ERR?");
				_parent->get_logger()->info_stream() << log4tango::LogInitiator::_begin_log << "Found error " << rsp << " while checking controller type." << endl;
			}
			return false;

		} catch(Tango::DevFailed &e) {
			Tango::Except::throw_exception(
					(const char*)"No controller found",
					(const char*)"No controller was found. Check connection.",
					(const char*)"MercuryComm::init()");
		}
	}
}


// Check if configuration on the controller match that in the DB
bool MercuryComm::checkConfiguration() {

	// Read current configuration from controller
	std::map<uint32_t, std::string> current_config;
	if(_old_controller) {
		// Get P-Term
		std::string rsp = sendCommandWithResponse_old("GP");
		int ans = sscanf(rsp.c_str(), "G:%*d");
		if(ans == 1)
			current_config[0x80000001] = rsp.substr(2);

		// Get I-Term
		rsp = sendCommandWithResponse_old("GI");
		ans = sscanf(rsp.c_str(), "I:%*d");
		if(ans == 1)
			current_config[0x80000002] = rsp.substr(2);

		// Get D-Term
		rsp = sendCommandWithResponse_old("GD");
		ans = sscanf(rsp.c_str(), "D:%*d");
		if(ans == 1)
			current_config[0x80000003] = rsp.substr(2);

		// Get I-Limit
		rsp = sendCommandWithResponse_old("GM");
		ans = sscanf(rsp.c_str(), "M:%*d");
		if(ans == 1)
			current_config[0x80000004] = rsp.substr(2);

		// Get velocity
		rsp = sendCommandWithResponse_old("TY");
		ans = sscanf(rsp.c_str(), "Y:%*d");
		if(ans == 1)
			current_config[0x80000005] = rsp.substr(2);

		// Get acceleration
		rsp = sendCommandWithResponse_old("TL");
		ans = sscanf(rsp.c_str(), "L:%*d");
		if(ans == 1)
			current_config[0x80000006] = rsp.substr(2);

	} else {
		std::string rsp = sendCommandWithResponse_new("SPA?");
		size_t offset = 0;
		while(offset < rsp.size()) {
			size_t next = rsp.find("\n", offset);
			if(next == std::string::npos)
				next = rsp.size();
			std::string param = rsp.substr(offset, next - offset);
			size_t pos = param.find("=");
			if(pos != std::string::npos) {
				uint32_t id = uint32_t(std::strtol(param.substr(0, pos).c_str(), NULL, 16));
				current_config[id] = param.substr(pos+1);
			}
			offset = next + 1;
		}
	}

	// Check configuration
	// TODO

	return true;
}


// Write configuration to controller
void MercuryComm::writeConfiguration() {

	// Update stage name
	if(*(_parent->attr_StageName_read) != NULL)
		CORBA::string_free(*(_parent->attr_StageName_read));
	*(_parent->attr_StageName_read) = CORBA::string_dup(_config[0x3C].c_str());

	if(_old_controller) {
		std::stringstream cmd;
		// P-term
		cmd << "DP" << _config[0x80000001];
		sendCommand_old(cmd.str());

		// I-term
		cmd.str("");
		cmd << "DI" << _config[0x80000002];
		sendCommand_old(cmd.str());

		// D-term
		cmd.str("");
		cmd << "DD" << _config[0x80000003];
		sendCommand_old(cmd.str());

		// I-limit
		cmd.str("");
		cmd << "DL" << _config[0x80000004];
		sendCommand_old(cmd.str());

		// Velocity
		cmd.str("");
		cmd << "SV" << _config[0x80000005];
		sendCommand_old(cmd.str());

		// Acceleration
		cmd.str("");
		cmd << "SA" << _config[0x80000006];
		sendCommand_old(cmd.str());

		// Enable limit switches
		if(_config[0x32] == "0") {
			// Has limit switches
			sendCommand_old("LN");
			if(_config[0x18] == "0")
				// Limit switches active high
				sendCommand_old("LH");
			else
				// Limit switches active low
				sendCommand_old("LL");

		} else {
			// No limit switches
			sendCommand_old("LF");
		}

		// Conversion factor
		_factor = double(std::strtol(_config[0xE].c_str(), NULL, 10)) / double(std::strtol(_config[0xF].c_str(), NULL, 10));

	} else {
		// New mercury

		// Check servo status
		std::string rsp = sendCommandWithResponse_new("SVO?");
		int svo_status;
		int ans = sscanf(rsp.c_str(), "%*[^=]=%d", &svo_status);
		if(ans != 1) {
			// Error
			std::stringstream msg;
			msg << "Cannot parse SVO response from controller. Response was: '" << rsp << "'";
			Tango::Except::throw_exception(
				(const char*)"Parse failed",
				msg.str(),
				(const char*)"MercuryComm::writeConfiguration()");
		}

		// Turn servo off for configuration
		if(svo_status) {
			std::stringstream cmd;
			cmd << "SVO " << _axisid << " 0";
			sendCommand_new(cmd.str());
		}
		
		// First thing to do is to set the conversion factor from counts to physical units (if the mercury has a wrong value some values may be stored incorrectly)
		std::map<uint32_t, std::string>::iterator val = _config.find(0xE);
		if(val != _config.end()) {
			std::stringstream cmd;
			cmd << "SPA " << _axisid << " " << val->first << " " << val->second;
			sendCommand_new(cmd.str());
		}
		val = _config.find(0xF);
		if(val != _config.end()) {
			std::stringstream cmd;
			cmd << "SPA " << _axisid << " " << val->first << " " << val->second;
			sendCommand_new(cmd.str());
		}

		for(std::map<uint32_t, std::string>::iterator iter = _config.begin(); iter != _config.end(); iter++) {
			// Exclude parameters for the old C862 mercury controller (and conversion parameters)
			if(!(iter->first & 0x80000000) && iter->first != 0xE && iter->first != 0xF) {

				std::stringstream cmd;
				//cmd << "SPA " << _axisid << " 0x" << std::hex << iter->first << " " << iter->second;
				cmd << "SPA " << _axisid << " " << iter->first << " " << iter->second;
				sendCommand_new(cmd.str());
				
				if(_parent->get_logger()->is_debug_enabled())
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Setting parameter 0x" << std::hex << iter->first << std::dec << " to " << iter->second << endl;

				if(getStatus_new() & N_MERCURY_ERROR) {
					// Error setting parameter. Get error code.
					std::string rsp = sendCommandWithResponse_new("ERR?");
					int err = std::strtol(rsp.c_str(), NULL, 10);
					switch(err) {
						case 17: // Parameter out of range
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Parameter 0x" << std::hex << iter->first << std::dec << " is out of range. Skipping." << endl;
							break;
						case 54: // Unknown parameter
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Parameter 0x" << std::hex << iter->first << std::dec << " is not supported by the current controller." << endl;
							break;
						case 79: // Parameter cannot be changed with servo on
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Parameter 0x" << std::hex << iter->first << std::dec << " cannot be change when the servo motor is on." << endl;
							break;
						default:
							// Unrecoverable error
							_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to set parameter 0x" << std::hex << iter->first << std::dec << " with error " << err << ". Configuration aborted." << endl;
							// Throw exception
							std::stringstream msg;
							msg << "Failed to write parameter 0x" << std::hex << iter->first << std::dec << " with value '" << iter->second << "'. Error was: " << err;
							Tango::Except::throw_exception(
								(const char*)"Configuration failed",
								msg.str(),
								(const char*)"MercuryComm::writeConfiguration()");
							break;
					}
				}

				if(_parent->get_logger()->is_debug_enabled()) {
					// Only in debug mode we check that the value was set correctly
					_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Checking parameter 0x" << std::hex << iter->first << std::dec << endl;
					cmd.str("");
					cmd << "SPA? " << _axisid << " " << iter->first;
					std::string rsp = sendCommandWithResponse_new(cmd.str());
					char buffer[128];
					int ans = sscanf(rsp.c_str(), "%*s %*d=%127s", buffer);
					if(ans == 1) {
						if(iter->second != buffer) {
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to write parameter 0x" << std::hex << iter->first << std::dec << ". Write val: " << iter->second << ", read val: " << buffer << endl;
						}
					} else {
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to parse value of parameter 0x" << std::hex << iter->first << std::dec << endl;
					}
				}
			}
		}

		// Turn servo on (if needed)
		if(svo_status) {
			std::stringstream cmd;
			cmd << "SVO " << _axisid << " 1";
			sendCommand_new(cmd.str());
		}
	}
}


// Convert configuration string to std::map
void MercuryComm::string2map(const std::string& config, std::map<uint32_t, std::string>& conf_map) {

	size_t index = 0;
	while(index < config.size()) {
		size_t pos = config.find(",", index);
		if(pos == std::string::npos)
			pos = config.size();
		// Extract parameter
		std::string parameter = config.substr(index, pos-index);
		// Search for the equal position
		size_t eqpos = parameter.find("=");
		if(eqpos != std::string::npos) {
			uint32_t param = uint32_t(std::strtol(parameter.substr(0, eqpos).c_str(), NULL, 16));
			conf_map[param] = parameter.substr(eqpos+1);
		}
		// Update index
		index = pos+1;
	}
}


// Get velocity (in mm/s)
double MercuryComm::getVelocity() {
	if(_old_controller) {
		std::string rsp = sendCommandWithResponse_old("TY");
		int vel;
		int ans = sscanf(rsp.c_str(), "Y:%d", &vel);
		if(ans == 1)
			return double(vel) / _factor;
		else
			return std::nan("");

	} else {
		std::string rsp = sendCommandWithResponse_new("VEL?");
		double vel;
		int ans = sscanf(rsp.c_str(), "%*[^=]=%lf", &vel);
		if(ans == 1)
			return vel;
		else
			return std::nan("");
	}
}


// Set velocity (in mm/s)
void MercuryComm::setVelocity(double value) {
	if(_old_controller) {
		std::stringstream cmd;
		uint32_t vel = uint32_t(value * _factor + 0.5);
		cmd << "SV" << vel;
		sendCommand_old(cmd.str());

	} else {
		std::stringstream cmd;
		cmd << std::setprecision(6) << std::fixed << "VEL " << _axisid << " " << value;
		sendCommand_new(cmd.str());
	}
}


// Get acceleration (in mm/s)
double MercuryComm::getAcceleration() {
	if(_old_controller) {
		std::string rsp = sendCommandWithResponse_old("TL");
		int acc;
		int ans = sscanf(rsp.c_str(), "L:%d", &acc);
		if(ans == 1)
			return double(acc) / _factor;
		else
			return std::nan("");

	} else {
		std::string rsp = sendCommandWithResponse_new("ACC?");
		double acc;
		int ans = sscanf(rsp.c_str(), "%*[^=]=%lf", &acc);
		if(ans == 1)
			return acc;
		else
			return std::nan("");
	}
}


// Set acceleration (in mm/s)
void MercuryComm::setAcceleration(double value) {
	if(_old_controller) {
		std::stringstream cmd;
		uint32_t acc = uint32_t(value * _factor + 0.5);
		cmd << "SA" << acc;
		sendCommand_old(cmd.str());

	} else {
		std::stringstream cmd;
		cmd << std::setprecision(6) << std::fixed << "ACC " << _axisid << " " << value;
		sendCommand_new(cmd.str());
	}
}


// Relative move (in mm)
void MercuryComm::moveRelative(double delta, bool save) {
	// Get current position
	double curr_pos = getPosition();
	// Relative move
	if(_old_controller) {
		std::stringstream cmd;
		uint32_t move = uint32_t(delta * _factor + 0.5);
		cmd << "MR" << move;
		sendCommand_old(cmd.str());

	} else {
		std::stringstream cmd;
		cmd << std::setprecision(6) << std::fixed << "MVR " << _axisid << " " << delta;
		sendCommand_new(cmd.str());
	}
	msleep(5);
	*(_parent->attr_MotionDone_read) = Tango::DevBoolean(0);

	// Save new position -> Moved to the monitoring thread. The position will be saved when the motion is stopped on-target
// 	if(save) {
// 		try {
// 			savePosition(curr_pos + delta);
// 		} catch(Tango::DevFailed &e) {
// 			print_error("Failed to save position to database", e);
// 		}
// 	}
}


// Absolute move (raw position in mm)
void MercuryComm::moveAbsolute(double position, bool save) {
	if(_old_controller) {
		std::stringstream cmd;
		uint32_t move = uint32_t(position * _factor + 0.5);
		cmd << "MA" << move;
		sendCommand_old(cmd.str());

	} else {
		std::stringstream cmd;
		cmd << std::setprecision(6) << std::fixed << "MOV " << _axisid << " " << position;
		sendCommand_new(cmd.str());
	}
	msleep(5);
	*(_parent->attr_MotionDone_read) = Tango::DevBoolean(0);

	// Save new position
// 	if(save) {
// 		try {
// 			savePosition(position);
// 		} catch(Tango::DevFailed &e) {
// 			print_error("Failed to save position to database", e);
// 		}
// 	}
}


// Stop motion
void MercuryComm::stop() {
	if(_old_controller) {
		sendCommand_old("AB1");
	} else {
		sendCommand_new("HLT");
	}
}


// Abort motion
void MercuryComm::abort() {
	if(_old_controller) {
		sendCommand_old("!");
	} else {
		sendCommand_new("\x24");
	}
}


// Reset controller
void MercuryComm::reset() {
	// Set status to DISABLE
	_parent->set_state(Tango::DISABLE);

	// Update controller type (if needed)
	_old_controller = checkCtrlType();

	// Reboot controller
	if(_old_controller) {
		sendCommand_old("RT");
	} else {
		sendCommand_new("RBT");
	}

	// Set status to INIT, then we move to the monitor cycle...
	_parent->set_state(Tango::INIT);
	_parent->set_status("Re-initialization in progress");
}


// Get status bytes of old mercury controller
uint8_t MercuryComm::getStatusByte_old(int index) {
	if(index < 0 || index > 5)
		Tango::Except::throw_exception(
				(const char*)"Bad index",
				(const char*)"Requested status byte index out of range",
				(const char*)"MercuryComm::getStatusByte_old()");
	std::string rsp = sendCommandWithResponse_old("%");
	uint8_t sb[6];
	int ans = sscanf(rsp.c_str(), "S:%02hhX %02hhX %02hhX %02hhX %02hhX %02hhX", &sb[0], &sb[1], &sb[2], &sb[3], &sb[4], &sb[5]);
	if(ans != 6) {
		// Malformed response
		std::stringstream msg;
		msg << "Parsing of status string failed. Response was: '" << rsp << "' (ans = " << ans << ")";
		Tango::Except::throw_exception(
				(const char*)"Bad status string",
				msg.str(),
				(const char*)"MercuryComm::getStatusByte_old()");
	}
	return sb[index];
}


// Get status register of new controller
uint16_t MercuryComm::getStatus_new() {
	std::string rsp = sendCommandWithResponse_new("\x04");
	uint16_t status;
	int ans = sscanf(rsp.c_str(), "0x%04hX", &status);
	if(ans == 1) {
		return status;
	} else {
		std::stringstream msg;
		msg << "Parsing of status value failed. Response was: '" << rsp << "' (ans = " << ans << ")";
		Tango::Except::throw_exception(
				(const char*)"Bad status response",
				msg.str(),
				(const char*)"MercuryComm::getStatusByte_new()");
	}
}


// Search for reference on old controller
void MercuryComm::searchReference_old() {

	// Check reference availability
	bool has_ref = std::strtol(_config[0x14].c_str(), NULL, 10) == 1;
	bool has_lim = std::strtol(_config[0x32].c_str(), NULL, 10) == 0;
	bool ref_inv = std::strtol(_config[0x31].c_str(), NULL, 10) == 1;
	double ref_vel = std::strtod(_config[0x50].c_str(), NULL);
	double max_speed = std::strtod(_config[0x0A].c_str(), NULL);

	// Get reference value
	uint8_t reg = 0;

	// Get original velocity value
	double vel = getVelocity();

	if(has_ref) {
		// Set velocity to 90% maximum velocity
		setVelocity(0.9 * max_speed);
		// Start reference search
		if(ref_inv) {
			// Inverted reference, use FE3
			sendCommand_old("FE3");
			// Wait
			waitMove_old();

			// Check if ref is on (on the negative side)
			reg = getStatusByte_old(O_MERCURY_5F);
			if(!(reg & O_MERCURY_REF)) {
				// On the positive side, call FE3 again
				sendCommand_old("FE3");
				// Wait
				waitMove_old();
			}
			setVelocity(ref_vel);
			// Run FE3 again at low speed
			sendCommand_old("FE3");
			// Wait
			waitMove_old();

		} else {
			// Non-inverted reference, use FE2
			sendCommand_old("FE2");
			// Wait
			waitMove_old();

			// Check if ref is on (on the negative side)
			reg = getStatusByte_old(O_MERCURY_5F);
			if(reg & O_MERCURY_REF) {
				// On the positive side, call FE3 again
				sendCommand_old("FE2");
				// Wait
				waitMove_old();
			}
			setVelocity(ref_vel);
			// Run FE3 again at low speed
			sendCommand_old("FE2");
			// Wait
			waitMove_old();
		}
		// Restore velocity value
		setVelocity(vel);

	} else if(has_lim) {
		// No reference, but limit switches: use negative limit
		// Set velocity to 90% maximum velocity
		setVelocity(0.9 * max_speed);
		// Move to the negative limit
		sendCommand_old("MR-999999999");
		// Wait
		waitMove_old();
		// Move back in the positive direction by 1mm
		std::stringstream cmd;
		cmd << "MR" << int(2.0 * _factor);
		sendCommand_old(cmd.str());
		// Wait
		waitMove_old();
		// Decrease velocity
		setVelocity(ref_vel);
		// Move again to the negative limit
		sendCommand_old("MR-999999999");
		// Wait
		waitMove_old();
		// Restore velocity value
		setVelocity(vel);

	} else {
		// No available reference
		Tango::Except::throw_exception(
				(const char*)"No available reference",
				(const char*)"No reference available. Stage should be configured as unreferenced",
				(const char*)"MercuryComm::searchReference_old()");
	}

	try {
		// Set current position as zero
		sendCommand_old("DH");

		// Go back to last save position
		moveAbsolute(getSavedPosition(), false);

	} catch(Tango::DevFailed &e) {
		print_error("Failed to restore last saved position", e);
	}
	// Wait
	waitMove_old();
}


// Wait for the motion to complete
void MercuryComm::waitMove_old(int timeout) {
	uint8_t reg = getStatusByte_old(O_MERCURY_1F);
	struct timeval b, e;
	gettimeofday(&b, NULL);
	while(!(reg & O_MERCURY_DONE)) {
		msleep(20);
		reg = getStatusByte_old(O_MERCURY_1F);

		if(timeout > 0) {
			gettimeofday(&e, NULL);
			if(ELAPSED_TIME_MS(b, e) > timeout)
				Tango::Except::throw_exception(
					(const char*)"Timeout expired",
					(const char*)"Timeout expired without the motion to complete",
					(const char*)"MercuryComm::waitMove_old()");
		}
	}
}


// Wait for the motion to complete
void MercuryComm::waitMove_new(int timeout) {
	struct timeval b, e, s_b, s_e;
	gettimeofday(&b, NULL);
	while(1) {
		// Wait
		msleep(20);

		// Check status
		uint16_t status = getStatus_new();
		if(!(status & N_MERCURY_MOTION)) {
			if(status & N_MERCURY_ONTG) {
				return;
			} else {
				// The motion stopped but not on target...
				if(status & N_MERCURY_NEGLIM) {
					// We are at the negative limit switch. We stop waiting...
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Motion stopped at the negative limit switch" << endl;
					return;
				} else if(status & N_MERCURY_POSLIM) {
					// We are at the positive limit switch. We stop waiting...
					_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Motion stopped at the positive limit switch" << endl;
					return;
				} else {
					// We may be in a reference move or it may be that the position error is too high
					// We wait a little bit to see if the motion starts again...
					gettimeofday(&s_b, NULL);
					while(true) {
						msleep(20);
						status = getStatus_new();
						if(status & N_MERCURY_MOTION)
							break;
						gettimeofday(&s_e, NULL);
						if(ELAPSED_TIME_MS(s_b, s_e) > 500) {
							_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Motion stopped out of target. Operation aborted or position error is too high" << endl;
							return;
						}
					}
				}
			}
		}

		// Check timeout
		if(timeout > 0) {
			gettimeofday(&e, NULL);
			if(ELAPSED_TIME_MS(b, e) > timeout)
				Tango::Except::throw_exception(
					(const char*)"Timeout expired",
					(const char*)"Timeout expired without the motion to complete",
					(const char*)"MercuryComm::waitMove_new()");
		}
	}
}


// Search for reference on new controller
void MercuryComm::searchReference_new() {

	// Check reference availability
	bool has_ref = std::strtol(_config[0x14].c_str(), NULL, 10) == 1;
	bool has_lim = std::strtol(_config[0x32].c_str(), NULL, 10) == 0;
	double max_speed = std::strtod(_config[0x0A].c_str(), NULL);

	// Get original velocity value
	double vel = getVelocity();

	if(has_ref) {
		// Set velocity to 90% maximum velocity
		setVelocity(0.9 * max_speed);
		// Start reference search
		std::stringstream cmd;
		cmd << "FRF " << _axisid;
		sendCommand_new(cmd.str());

		// Wait
		waitMove_new();

	} else  if(has_lim) {
		// Set velocity to 90% maximum velocity
		setVelocity(0.9 * max_speed);
		// Start reference search
		std::stringstream cmd;
		cmd << "FNL " << _axisid;
		sendCommand_new(cmd.str());

		// Wait
		waitMove_new();

	} else {
		// No available reference
		Tango::Except::throw_exception(
				(const char*)"No available reference",
				(const char*)"No reference available. Stage should be configured as unreferenced",
				(const char*)"MercuryComm::searchReference_new()");
	}

	// Restore velocity value
	setVelocity(vel);

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Going back to last saved position: " << getSavedPosition() << endl;

	try {
		// Go back to last saved position
		moveAbsolute(getSavedPosition(), false);

	} catch(Tango::DevFailed &e) {
		print_error("Failed to restore last saved position", e);
	}
	// Wait
	waitMove_new();
}


// Send command with no response to old controller
void MercuryComm::sendCommand_old(const std::string& cmd) {
	if(!this->_dev)
		Tango::Except::throw_exception(
			(const char*)"No proxy available",
			(const char*)"No proxy device is available",
			(const char*)"MercuryComm::sendCommand_old()");

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Command: " << cmd << endl;

	// Setup buffer
	size_t n = cmd.size() + 2 + ((cmd.size() > 1) ? 1 : 0);
	Tango::DevVarCharArray *arg = new Tango::DevVarCharArray(n);
	arg->length(n);
	// Set address
	(*arg)[0] = 0x01;
	(*arg)[1] = '0' + _address - 1;
	// Copy command
	memcpy(arg->get_buffer()+2, cmd.c_str(), cmd.size());
	// Set termination
	if(cmd.size() > 1)
		(*arg)[2+cmd.size()] = '\r';

	// Prepare device data
	Tango::DeviceData din;
	din << arg;
	{
		// Acquire mutex
		omni_mutex_lock sync(this->_lock);
		// Send command
		_dev->command_inout("Send", din);
	}
}


// Send command with response to old controller
std::string MercuryComm::sendCommandWithResponse_old(const std::string& cmd) {
	if(!this->_dev)
		Tango::Except::throw_exception(
			(const char*)"No proxy available",
			(const char*)"No proxy device is available",
			(const char*)"MercuryComm::sendCommandWithResponse_old()");

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Command: " << cmd << endl;

	// Setup buffer
	size_t n = cmd.size() + 2 + ((cmd.size() > 1) ? 1 : 0);
	Tango::DevVarCharArray *arg = new Tango::DevVarCharArray(n);
	arg->length(n);
	// Set address
	(*arg)[0] = 0x01;
	(*arg)[1] = '0' + _address - 1;
	// Copy command
	memcpy(arg->get_buffer()+2, cmd.c_str(), cmd.size());
	// Set termination
	if(cmd.size() > 1)
		(*arg)[2+cmd.size()] = '\r';

	// Prepare device data
	Tango::DeviceData din, dout;
	din << arg;
	{
		// Acquire mutex
		omni_mutex_lock sync(this->_lock);
		// Send command
		dout = _dev->command_inout("SyncSendRecv", din);
	}
	// Extract response
	const Tango::DevVarCharArray *rsp;
	if(!(dout >> rsp))
		// Conversion failed
		Tango::Except::throw_exception(
				(const char*)"Conversion failed",
				(const char*)"Failed to convert response",
				(const char*)"MercuryComm::sendCommandWithResponse_old()");

	// Create output string
	std::string out;
	out.reserve(rsp->length());
	for(size_t i = 0; i < rsp->length(); i++) {
		if((*rsp)[i] == '\r')
			break;
		else
			out += (*rsp)[i];
	}
	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Response: " << out << endl;
	return out;
}


// Send command with no response to new controller
void MercuryComm::sendCommand_new(const std::string& cmd) {
	if(!this->_dev)
		Tango::Except::throw_exception(
			(const char*)"No proxy available",
			(const char*)"No proxy device is available",
			(const char*)"MercuryComm::sendCommand_new()");

	// Format command
	std::stringstream cmd_s;
	cmd_s << _address << " " << cmd << "\n";

	if(_parent->get_logger()->is_debug_enabled()) {
		if(cmd.size() == 1)
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Command: 0x"<< hex << int(cmd.c_str()[0]);
		else
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Command: "<< cmd;
	}

	// Setup buffer
	Tango::DevVarCharArray *arg = new Tango::DevVarCharArray(cmd_s.str().size());
	arg->length(cmd_s.str().size());
	// Copy command
	memcpy(arg->get_buffer(), cmd_s.str().c_str(), cmd_s.str().size());

	Tango::DeviceData din;
	din << arg;

	{
		// Acquire mutex
		omni_mutex_lock sync(this->_lock);
		// Send command
		_dev->command_inout("Send", din);
	}
}


// Send command with response to new controller
std::string MercuryComm::sendCommandWithResponse_new(const std::string& cmd) {
	if(!this->_dev)
		Tango::Except::throw_exception(
			(const char*)"No proxy available",
			(const char*)"No proxy device is available",
			(const char*)"MercuryComm::sendCommandWithResponse_new()");

	// Format command
	std::stringstream cmd_s;
	cmd_s << _address << " " << cmd << "\n";

	if(_parent->get_logger()->is_debug_enabled()) {
		if(cmd.size() == 1)
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Command: 0x"<< hex << int(cmd.c_str()[0]) << endl;
		else
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Command: "<< cmd << endl;
	}

	// Setup buffer
	Tango::DevVarCharArray *arg = new Tango::DevVarCharArray(cmd_s.str().size());
	arg->length(cmd_s.str().size());
	// Copy command
	memcpy(arg->get_buffer(), cmd_s.str().c_str(), cmd_s.str().size());

	Tango::DeviceData din, dout;
	din << arg;

	{
		// Acquire mutex
		omni_mutex_lock sync(this->_lock);
		// Send command
		dout = _dev->command_inout("SyncSendRecv", din);
	}
	// Extract response
	const Tango::DevVarCharArray *rsp;
	if(!(dout >> rsp))
		// Conversion failed
		Tango::Except::throw_exception(
				(const char*)"Conversion failed",
				(const char*)"Failed to convert response",
				(const char*)"MercuryComm::sendCommandWithResponse_new()");

	// Create output string
	std::string out;
	out.reserve(rsp->length());
	for(size_t i = 0; i < rsp->length(); i++)
		out += (*rsp)[i];

	// Remove trailing new line and address at the beginning
	size_t start = out.find(" ");
	start = out.find(" ", start+1);
	size_t end = out.find_last_of("\n");

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Response: " << out.substr(start+1, end-(start+1)) << endl;

	return out.substr(start+1, end-(start+1));
}


// Save raw position in database
void MercuryComm::savePosition(double value) {
	if(Tango::Util::instance()->_UseDb==true) {
		try {
			// Prepare data
			Tango::DbData dev_prop;
			Tango::DbDatum pos = Tango::DbDatum("RawPosition");

			if(_parent->get_logger()->is_debug_enabled())
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Saving position: " << value << endl;

			pos << (Tango::DevDouble)value;
			dev_prop.push_back(pos);
			// Write data to DB
			_parent->get_db_device()->put_property(dev_prop);

		} catch(Tango::DevFailed &e) {
			Tango::Except::re_throw_exception(e,
				(const char*)"Write to DB failed",
				(const char*)"Failed to save last set position into DB",
				(const char*)"MercuryComm::savePosition()");
		}
	}
}


// Get last saved raw position from database
double MercuryComm::getSavedPosition() {
	if(Tango::Util::instance()->_UseDb==true) {
		try {
			// Prepare data
			Tango::DbData dev_prop;
			dev_prop.push_back(Tango::DbDatum("RawPosition"));
			// Read data fronm DB
			_parent->get_db_device()->get_property(dev_prop);
			// Extract value
			double val;
			dev_prop[0] >> val;
			return val;

		}catch(Tango::DevFailed &e) {
			Tango::Except::re_throw_exception(e,
				(const char*)"Read from DB failed",
				(const char*)"Failed to read from DB last set position",
				(const char*)"MercuryComm::getSavedPosition()");
		}

	} else {
		Tango::Except::throw_exception(
			(const char*)"DB not in use",
			(const char*)"DB not in use. Cannot retrieve last saved position",
			(const char*)"MercuryComm::getSavedPosition()");
	}
}


void MercuryComm::print_error(const char* message, const Tango::DevFailed &e) {
	_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << message << " - Errors:" << endl;
	for(size_t i = 0; i < e.errors.length(); i++)
		_parent->get_logger()->error_stream() << "[" << (i+1) << "] " << e.errors[i].origin << ": " << e.errors[i].desc << endl;
}


double MercuryComm::getPosition(bool force_update) {
	// Get current time
	struct timeval curr_time;
	gettimeofday(&curr_time, NULL);

	int elapsed = ELAPSED_TIME_MS(_pos_timestamp, curr_time);
	if(force_update || elapsed > _polling/2) {
		// Need to update position
		if(_old_controller) {
			try {
				// Poll position
				std::string rsp = sendCommandWithResponse_old("'");
				uint32_t pos;
				int ans = sscanf(rsp.c_str(), "P:%d", &pos);
				if(ans == 1) {
					_position = double(pos) / _factor;
					gettimeofday(&_pos_timestamp, NULL);
				} else {
					std::stringstream msg;
					msg << "Failed to parse response from old Mercury controller. Response was: '" << rsp << "'";
					Tango::Except::throw_exception(
						(const char*)"Parsing failed.",
						msg.str(),
						(const char*)"MercuryComm::getPosition()");
				}

			} catch(Tango::DevFailed &e) {
				Tango::Except::re_throw_exception(e,
						(const char*)"Read failed",
						(const char*)"Failed to read position from old Mercury controller",
						(const char*)"MercuryComm::getPosition()");
			}

		} else {
			try {
				// Poll position
				std::string rsp = sendCommandWithResponse_new("POS?");
				double pos;
				int ans = sscanf(rsp.c_str(), "%*[^=]=%lf", &pos);
				if(ans == 1) {
					_position = pos;
					gettimeofday(&_pos_timestamp, NULL);
				} else {
					std::stringstream msg;
					msg << "Failed to parse response from new Mercury controller. Response was: '" << rsp << "'";
					Tango::Except::throw_exception(
						(const char*)"Parsing failed.",
						msg.str(),
						(const char*)"MercuryComm::getPosition()");
				}

			} catch(Tango::DevFailed &e) {
				Tango::Except::re_throw_exception(e,
						(const char*)"Read failed",
						(const char*)"Failed to read position from new Mercury controller",
						(const char*)"MercuryComm::getPosition()");
			}
		}
	}

	// Return position value
	return _position;
}


// Main loop
void *MercuryComm::run_undetached(void* ptr) {

	// Initialize return value
	int *retval = new int(0);

	// Wait for the DServer to become available (it means initialization has ended)
	// NOTE: this is needed to be able to restore manually the memorized attributes, because the write value is initialized after init_device has returned
	Tango::Util *tg = Tango::Util::instance();
	do {
		msleep(500);
		try {
			tg->get_dserver_device();
			break;
		} catch(Tango::DevFailed &e) {
			if(_parent->get_logger()->is_debug_enabled())
				_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Waiting for the DServer to finish initialization" << endl;
		}
		if(_terminate) {
			*retval = -1;
			return (void*)retval;
		}
	} while(true);

	// Initialize communication
	init();

	// Check if we need a reference search
	if(_need_refsearch) {
		_parent->set_status("Starting reference move...");
		try {
			if(_old_controller) {
				searchReference_old();
			} else {
				searchReference_new();
			}
		} catch(Tango::DevFailed &e) {
			// Reference move failed...
			print_error("Reference move failed", e);
			_parent->set_status("Initialization failed");
			_parent->set_state(Tango::DISABLE);
		}
	}

	// Timing structures
	struct timeval b, e;

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Initialization finished!" << endl;

	// Set state to STANDBY
	_parent->set_state(Tango::STANDBY);
	_parent->set_status("Ready");

	// Error counter
	int error_counter = 0;

	while(!_terminate) {

		// Starting time...
		gettimeofday(&b, NULL);

		// Check error counter
		if(_parent->get_state() != Tango::INIT && _parent->get_state() != Tango::DISABLE && error_counter > 5) {
			_parent->set_state(Tango::FAULT);
			_parent->set_status("Communication failure");
			error_counter = 0; // Reset counter...
		}

		if(_parent->get_state() == Tango::FAULT) {
			// Fault status (communication failure)
			try {
				// Try to reconnect to serial device
				_dev->command_inout("Disconnect");
				_dev->command_inout("Connect");

				// Try to read controller type. I read is successful, communication is back.
				bool type = checkCtrlType();

				// Read successful. Check if the controller type is the same.
				if(_old_controller != type) {
					// Controller type changed. Cannot continue.
					_parent->set_state(Tango::DISABLE);
					_parent->set_status("Bad controller. Re-initialization needed.");
				} else {
					if(_old_controller) {
						if(getStatusByte_old(O_MERCURY_1F) & O_MERCURY_MOTOFF) {
							reset();
						} else {
							// Nothing to do
						}

					} else {
						// Update axis ID
						std::string rsp = sendCommandWithResponse_new("SAI?");
						strncpy(_axisid, rsp.c_str(), 8);
						_axisid[8] = 0x00;

						// If the controller is referenced, we keep it as is.
						rsp = sendCommandWithResponse_new("FRF?");
						int status;
						int ans = sscanf(rsp.c_str(), "%*[^=]=%d", &status);
						if(ans == 1) {
							if(status == 0) {
								// Not referenced. Must re-initialize.
								reset();
							} else {
								// Referenced. We just update the stage name
								std::stringstream cmd;
								cmd << "SPA? " << _axisid << " 0x3C";
								rsp = sendCommandWithResponse_new(cmd.str());
								size_t pos = rsp.find("=");
								if(pos != std::string::npos) {
									// Update stage name
									if(*(_parent->attr_StageName_read) != NULL)
										CORBA::string_free(*(_parent->attr_StageName_read));
									*(_parent->attr_StageName_read) = CORBA::string_dup(rsp.substr(pos).c_str());
								}
								// Set device state
								_parent->set_state(Tango::STANDBY);
								_parent->set_status("Ready");
							}

						} else {
							std::stringstream msg;
							msg << "Failed to parse reference status. Response was: '" << rsp << "'";
							Tango::Except::throw_exception(
								(const char *)"Parse failed",
								msg.str(),
								(const char *)"MercuryComm::run_undetached()");
						}
					}
				}

			} catch(Tango::DevFailed &e) {
				print_error("Failed to recover from fault", e);
			}

		} else if(_parent->get_state() == Tango::INIT) {
			try {
				// We are re-initializing the controller

				// Wait for the controller to reboot
				while(1) {
					msleep(500);
					try {
						if(_old_controller) {
							std::string rsp = sendCommandWithResponse_old("TP");
						} else {
							std::string rsp = sendCommandWithResponse_new("POS?");
						}
						// Reponse received
						break;
					} catch(Tango::DevFailed &e) {
						continue;
					}
				}
				// Just to be sure...
				msleep(500);
				_parent->set_status("Re-initialization: writing configuration...");

				if(_old_controller) {
					// Turn motor ON
					sendCommand_old("MN");

					// Update configuration
					writeConfiguration();

					// If reference is needed, start a reference search
					if(_parent->referenced) {
						_parent->set_status("Re-initialization: searching for reference...");
						searchReference_old();
					}

				} else {
					// Update axis ID
					std::string rsp = sendCommandWithResponse_new("SAI?");
					strncpy(_axisid, rsp.c_str(), 8);
					_axisid[8] = 0x00;

					// Update configuration
					writeConfiguration();

					// Turn motor on
					std::stringstream cmd;
					cmd << "SVO " << _axisid << " 1";
					sendCommand_new(cmd.str());

					// If reference is needed, start a reference search
					if(_parent->referenced) {
						_parent->set_status("Re-initialization: searching for reference...");
						cmd.str("");
						cmd << "RON " << _axisid << " 1";
						sendCommand_new(cmd.str());
						// Start reference search
						searchReference_new();

					} else {
						// Set axis as referenced to the current position
						cmd.str("");
						cmd << "RON " << _axisid << " 0";
						sendCommand_new(cmd.str());
						cmd.str("");
						cmd << "POS " << _axisid << " 0";
						sendCommand_new(cmd.str());
					}
				}

				// Restore memorized attributes
				restoreMemAttributes();

			} catch(Tango::DevFailed &e) {
				// Re-initialization failed
				print_error("Re-initialization failed", e);
				_parent->set_state(Tango::DISABLE);
				_parent->set_status("Re-initialization failed.");
			}

			// Reinitialization done
			_parent->set_state(Tango::STANDBY);
			_parent->set_status("Ready");

		} else if(_parent->get_state() == Tango::DISABLE) {
			// Device disabled. Waiting for re-init
			// Noting to do...

		} else {
			if(_old_controller) {
				try {
					// Poll status register
					std::string rsp = sendCommandWithResponse_old("%");
					uint8_t sb[6];
					int ans = sscanf(rsp.c_str(), "S:%02hhX %02hhX %02hhX %02hhX %02hhX %02hhX", &sb[0], &sb[1], &sb[2], &sb[3], &sb[4], &sb[5]);
					if(ans == 6) {
						if(sb[0] & 0x04) {
							// Motion done
							_parent->set_state(Tango::STANDBY);
							_parent->set_status("Ready");
							if(*(_parent->attr_MotionDone_read) == Tango::DevBoolean(0)) {
								savePosition(getPosition(true));
								*(_parent->attr_MotionDone_read) = Tango::DevBoolean(1);
								_parent->push_change_event("MotionDone", _parent->attr_MotionDone_read);
							}
						} else {
							// Moving...
							_parent->set_state(Tango::MOVING);
							_parent->set_status("Moving...");
						}

						if(sb[5] != 0) {
							_lasterror = sb[5];
							sendCommandWithResponse_old("TE");
						}
					} else {
						
					}
					// Read successful, reset error counter
					error_counter = 0;

				} catch(Tango::DevFailed &e) {
					error_counter++;
					print_error("Failed to poll status register", e);
				}

			} else {
				try {
					// Check status register
					uint16_t status = getStatus_new();
					if(status & N_MERCURY_MOTION) {
						_parent->set_state(Tango::MOVING);
						_parent->set_status("Moving...");
					} else {
						_parent->set_state(Tango::STANDBY);
						_parent->set_status("Ready");
						if(*(_parent->attr_MotionDone_read) == Tango::DevBoolean(0)) {
							// Save position to database if the stage stopped on target
							if(status % N_MERCURY_ONTG)
								savePosition(getPosition(true));
							*(_parent->attr_MotionDone_read) = Tango::DevBoolean(1);
							_parent->push_change_event("MotionDone", _parent->attr_MotionDone_read);
						}
					}

					if(status & N_MERCURY_ERROR) {
						std::string rsp = sendCommandWithResponse_new("ERR?");
						int err;
						int ans = sscanf(rsp.c_str(), "%d", &err);
						if(ans == 1 && err != 0)
							_lasterror = err;
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Controller error: " << err << endl;
					}

				} catch(Tango::DevFailed &e) {
					error_counter++;
					print_error("Failed to poll status register", e);
				}
			}
		}
		
		// Check end timing
		gettimeofday(&e, NULL);
		int elapsed = ELAPSED_TIME_MS(b, e);
		if(_parent->get_logger()->is_debug_enabled())
			_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Polling cycle completed in: " << elapsed << " ms (error count: " << error_counter << ")" << endl;
		if(elapsed < _polling)
			msleep(_polling - elapsed);
	}

	// Default return value
	*retval = 0;
	return (void*)retval;
}


// Millisecond sleep
void MercuryComm::msleep(uint32_t msec) {
	if(msec <= 0)
		return;
	struct timespec st;
	struct timeval start, stop;
	gettimeofday(&start, NULL);
	// Setup delay
	st.tv_sec = msec / 1000;
	st.tv_nsec = (msec % 1000) * 1000000;

	while(1) {
		int ans = nanosleep(&st, NULL);
		if(ans == -1 && errno == EINTR) {
			// Nanosleep was interrupted by a signal
			gettimeofday(&stop, NULL);
			uint32_t rem = msec - ELAPSED_TIME_MS(start, stop);
			if(rem > 0) {
				st.tv_sec = rem / 1000;
				st.tv_nsec = (rem % 1000) * 1000000;
			} else {
				break;
			}
		} else {
			break;
		}
	}
}


/*----- PROTECTED REGION END -----*/	//	MercurySrv::namespace_ending
} //	namespace
