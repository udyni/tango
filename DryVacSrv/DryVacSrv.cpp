/*----- PROTECTED REGION ID(DryVacSrv.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        DryVacSrv.cpp
//
// description : C++ source for the DryVacSrv class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               DryVacSrv are implemented in this file.
//
// project :     DryVac Device Server
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <DryVacSrv.h>
#include <DryVacSrvClass.h>

/*----- PROTECTED REGION END -----*/	//	DryVacSrv.cpp

/**
 *  DryVacSrv class description:
 *    Device server for a Leybold DryVac screw vacuum pump. Depends on libmodbus for serial communication with the pump.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  Start         |  start
//  Stop          |  stop
//  Reset         |  reset
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  FreqSetpoint   |  Tango::DevFloat	Scalar
//  Frequency      |  Tango::DevFloat	Scalar
//  Voltage        |  Tango::DevFloat	Scalar
//  Current        |  Tango::DevFloat	Scalar
//  Power          |  Tango::DevFloat	Scalar
//  Temperature    |  Tango::DevShort	Scalar
//  Pressure       |  Tango::DevDouble	Scalar
//  EnablePurge    |  Tango::DevBoolean	Scalar
//  EnableBallast  |  Tango::DevBoolean	Scalar
//  CompressedAir  |  Tango::DevBoolean	Scalar
//  WaterValve     |  Tango::DevState	Scalar
//================================================================

namespace DryVacSrv_ns
{
/*----- PROTECTED REGION ID(DryVacSrv::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	DryVacSrv::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::DryVacSrv()
 *	Description : Constructors for a Tango device
 *                implementing the classDryVacSrv
 */
//--------------------------------------------------------
DryVacSrv::DryVacSrv(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(DryVacSrv::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::constructor_1
}
//--------------------------------------------------------
DryVacSrv::DryVacSrv(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(DryVacSrv::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::constructor_2
}
//--------------------------------------------------------
DryVacSrv::DryVacSrv(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(DryVacSrv::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void DryVacSrv::delete_device()
{
	DEBUG_STREAM << "DryVacSrv::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if(dev) {
		int *retval;
		dev->terminate();
		dev->join((void**)&retval);
		dev = NULL;
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::delete_device
	delete[] attr_FreqSetpoint_read;
	delete[] attr_Frequency_read;
	delete[] attr_Voltage_read;
	delete[] attr_Current_read;
	delete[] attr_Power_read;
	delete[] attr_Temperature_read;
	delete[] attr_Pressure_read;
	delete[] attr_EnablePurge_read;
	delete[] attr_EnableBallast_read;
	delete[] attr_CompressedAir_read;
	delete[] attr_WaterValve_read;
}

//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void DryVacSrv::init_device()
{
	DEBUG_STREAM << "DryVacSrv::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::init_device_before


	//	Get the device properties from database
	get_device_property();
	if (mandatoryNotDefined)
		return;

	attr_FreqSetpoint_read = new Tango::DevFloat[1];
	attr_Frequency_read = new Tango::DevFloat[1];
	attr_Voltage_read = new Tango::DevFloat[1];
	attr_Current_read = new Tango::DevFloat[1];
	attr_Power_read = new Tango::DevFloat[1];
	attr_Temperature_read = new Tango::DevShort[1];
	attr_Pressure_read = new Tango::DevDouble[1];
	attr_EnablePurge_read = new Tango::DevBoolean[1];
	attr_EnableBallast_read = new Tango::DevBoolean[1];
	attr_CompressedAir_read = new Tango::DevBoolean[1];
	attr_WaterValve_read = new Tango::DevState[1];

	/*----- PROTECTED REGION ID(DryVacSrv::init_device) ENABLED START -----*/

	// Convert attribute names to lowercase
	::transform(compAirDetect.begin(), compAirDetect.end(), compAirDetect.begin(), ::tolower);
	::transform(enBallast.begin(), enBallast.end(), enBallast.begin(), ::tolower);
	::transform(enPurge.begin(), enPurge.end(), enPurge.begin(), ::tolower);
	::transform(waterCoolingValve.begin(), waterCoolingValve.end(), waterCoolingValve.begin(), ::tolower);
	::transform(analogIN.begin(), analogIN.end(), analogIN.begin(), ::tolower);

	//	Initialize device
	try {
#ifdef USE_LIBMODBUS
		DEBUG_STREAM << "DryVacSrv::init_device()  Connecting to " << port << " with baudrate " << portBaudrate << " and address 0x" << std::hex << address << endl;
#else
		DEBUG_STREAM << "DryVacSrv::init_device()  Connecting to " << port << endl;
#endif
		dev = new DryVacMonitorThread(this);

	} catch(DryVacException &e) {
		TangoSys_OMemStream	tms;
		tms << "Failed to start polling thread. Exception was: " << e.what();
		ERROR_STREAM << "DryVacSrv::init_device()  " << tms.str() << endl;
		Tango::Except::throw_exception("Failed to start polling thread", tms.str(), "DryVacSrv::init_device()");
	}

	dev->msleep(1000);

	DEBUG_STREAM << "DryVac::init_device(): ended!" << endl;

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::init_device
}

//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void DryVacSrv::get_device_property()
{
	/*----- PROTECTED REGION ID(DryVacSrv::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Address"));
	dev_prop.push_back(Tango::DbDatum("PollingTime"));
	dev_prop.push_back(Tango::DbDatum("Port"));
	dev_prop.push_back(Tango::DbDatum("PortConfiguration"));
	dev_prop.push_back(Tango::DbDatum("PortBaudrate"));
	dev_prop.push_back(Tango::DbDatum("CompAirDetect"));
	dev_prop.push_back(Tango::DbDatum("EnBallast"));
	dev_prop.push_back(Tango::DbDatum("EnPurge"));
	dev_prop.push_back(Tango::DbDatum("WaterCoolingValve"));
	dev_prop.push_back(Tango::DbDatum("AnalogIN"));
	dev_prop.push_back(Tango::DbDatum("WaterCloseTemperature"));
	dev_prop.push_back(Tango::DbDatum("DisableWater"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on DryVacSrvClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		DryVacSrvClass	*ds_class =
			(static_cast<DryVacSrvClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Address from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  address;
		else {
			//	Try to initialize Address from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  address;
		}
		//	And try to extract Address value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  address;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize PollingTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pollingTime;
		else {
			//	Try to initialize PollingTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pollingTime;
		}
		//	And try to extract PollingTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pollingTime;

		//	Try to initialize Port from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  port;
		else {
			//	Try to initialize Port from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  port;
		}
		//	And try to extract Port value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  port;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize PortConfiguration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  portConfiguration;
		else {
			//	Try to initialize PortConfiguration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  portConfiguration;
		}
		//	And try to extract PortConfiguration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  portConfiguration;

		//	Try to initialize PortBaudrate from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  portBaudrate;
		else {
			//	Try to initialize PortBaudrate from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  portBaudrate;
		}
		//	And try to extract PortBaudrate value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  portBaudrate;

		//	Try to initialize CompAirDetect from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  compAirDetect;
		else {
			//	Try to initialize CompAirDetect from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  compAirDetect;
		}
		//	And try to extract CompAirDetect value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  compAirDetect;

		//	Try to initialize EnBallast from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enBallast;
		else {
			//	Try to initialize EnBallast from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enBallast;
		}
		//	And try to extract EnBallast value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enBallast;

		//	Try to initialize EnPurge from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enPurge;
		else {
			//	Try to initialize EnPurge from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enPurge;
		}
		//	And try to extract EnPurge value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enPurge;

		//	Try to initialize WaterCoolingValve from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  waterCoolingValve;
		else {
			//	Try to initialize WaterCoolingValve from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  waterCoolingValve;
		}
		//	And try to extract WaterCoolingValve value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  waterCoolingValve;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize AnalogIN from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  analogIN;
		else {
			//	Try to initialize AnalogIN from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  analogIN;
		}
		//	And try to extract AnalogIN value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  analogIN;

		//	Try to initialize WaterCloseTemperature from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  waterCloseTemperature;
		else {
			//	Try to initialize WaterCloseTemperature from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  waterCloseTemperature;
		}
		//	And try to extract WaterCloseTemperature value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  waterCloseTemperature;

		//	Try to initialize DisableWater from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  disableWater;
		else {
			//	Try to initialize DisableWater from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  disableWater;
		}
		//	And try to extract DisableWater value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  disableWater;

	}

	/*----- PROTECTED REGION ID(DryVacSrv::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void DryVacSrv::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(DryVacSrv::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	DryVacSrv::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void DryVacSrv::always_executed_hook()
{
// 	INFO_STREAM << "DryVacSrv::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"DryVacSrv::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(DryVacSrv::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void DryVacSrv::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
// 	DEBUG_STREAM << "DryVacSrv::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void DryVacSrv::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "DryVacSrv::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::write_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute FreqSetpoint related method
 *	Description: Frequency setpoint for the inverter
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_FreqSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_FreqSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_FreqSetpoint) ENABLED START -----*/
	*attr_FreqSetpoint_read = dev->getFreqSetpoint();
	//	Set the attribute value
	attr.set_value(attr_FreqSetpoint_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_FreqSetpoint
}
//--------------------------------------------------------
/**
 *	Write attribute FreqSetpoint related method
 *	Description: Frequency setpoint for the inverter
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::write_FreqSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::write_FreqSetpoint(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(DryVacSrv::write_FreqSetpoint) ENABLED START -----*/

	try {
		dev->setFreqSetpoint(w_val);
	} catch(DryVacException &e) {
		TangoSys_OMemStream	tms;
		tms << "Failed to set frequency setpoint. Exception was: " << e.what();
		ERROR_STREAM << "DryVacSrv::write_FreqSetpoint()  " << tms.str() << endl;
		Tango::Except::throw_exception("Failed to set frequency setpoint", tms.str(), "DryVacSrv::write_FreqSetpoint()");
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::write_FreqSetpoint
}
//--------------------------------------------------------
/**
 *	Read attribute Frequency related method
 *	Description: Converter output frequency
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_Frequency(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_Frequency(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_Frequency) ENABLED START -----*/

	*attr_Frequency_read = dev->getFrequency();
	attr.set_value(attr_Frequency_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_Frequency
}
//--------------------------------------------------------
/**
 *	Read attribute Voltage related method
 *	Description: Converter output voltage
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_Voltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_Voltage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_Voltage) ENABLED START -----*/

	*attr_Voltage_read = dev->getVoltage();
	attr.set_value(attr_Voltage_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_Voltage
}
//--------------------------------------------------------
/**
 *	Read attribute Current related method
 *	Description: Converter output current
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_Current(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_Current(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_Current) ENABLED START -----*/

	*attr_Current_read = dev->getCurrent();
	attr.set_value(attr_Current_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_Current
}
//--------------------------------------------------------
/**
 *	Read attribute Power related method
 *	Description: Converter output power
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_Power(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_Power(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_Power) ENABLED START -----*/

	*attr_Power_read = dev->getPower();
	attr.set_value(attr_Power_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_Power
}
//--------------------------------------------------------
/**
 *	Read attribute Temperature related method
 *	Description: Converter heatsink temperature
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_Temperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_Temperature(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_Temperature) ENABLED START -----*/

	*attr_Temperature_read = dev->getTemperature();
	attr.set_value(attr_Temperature_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_Temperature
}
//--------------------------------------------------------
/**
 *	Read attribute Pressure related method
 *	Description: Pressure al the pump inlet
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_Pressure(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_Pressure(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_Pressure) ENABLED START -----*/

	*attr_Pressure_read = dev->getPressure();
	attr.set_value(attr_Pressure_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_Pressure
}
//--------------------------------------------------------
/**
 *	Read attribute EnablePurge related method
 *	Description:
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_EnablePurge(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_EnablePurge(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_EnablePurge) ENABLED START -----*/

	*attr_EnablePurge_read = dev->getPurge();
	attr.set_value(attr_EnablePurge_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_EnablePurge
}
//--------------------------------------------------------
/**
 *	Write attribute EnablePurge related method
 *	Description:
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::write_EnablePurge(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::write_EnablePurge(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(DryVacSrv::write_EnablePurge) ENABLED START -----*/

	try {
		dev->setPurge(w_val);
	} catch(DryVacException &e) {
		TangoSys_OMemStream	tms;
		tms << "Failed to set purge. Exception was: " << e.what();
		ERROR_STREAM << "DryVacSrv::write_EnablePurge()  " << tms.str() << endl;
		Tango::Except::throw_exception("Failed to set purge", tms.str(), "DryVacSrv::write_EnablePurge()");
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::write_EnablePurge
}
//--------------------------------------------------------
/**
 *	Read attribute EnableBallast related method
 *	Description:
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_EnableBallast(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_EnableBallast(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_EnableBallast) ENABLED START -----*/

	*attr_EnableBallast_read = dev->getBallast();
	attr.set_value(attr_EnableBallast_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_EnableBallast
}
//--------------------------------------------------------
/**
 *	Write attribute EnableBallast related method
 *	Description:
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::write_EnableBallast(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::write_EnableBallast(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(DryVacSrv::write_EnableBallast) ENABLED START -----*/

	try {
		dev->setBallast(w_val);
	} catch(DryVacException &e) {
		TangoSys_OMemStream	tms;
		tms << "Failed to set ballast. Exception was: " << e.what();
		ERROR_STREAM << "DryVacSrv::write_EnableBallast()  " << tms.str() << endl;
		Tango::Except::throw_exception("Failed to set ballast", tms.str(), "DryVacSrv::write_EnableBallast()");
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::write_EnableBallast
}
//--------------------------------------------------------
/**
 *	Read attribute CompressedAir related method
 *	Description:
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_CompressedAir(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_CompressedAir(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_CompressedAir) ENABLED START -----*/

	*attr_CompressedAir_read = dev->getCompressedAirStatus();
	attr.set_value(attr_CompressedAir_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_CompressedAir
}
//--------------------------------------------------------
/**
 *	Read attribute WaterValve related method
 *	Description: Water valve status
 *
 *	Data type:	Tango::DevState
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DryVacSrv::read_WaterValve(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DryVacSrv::read_WaterValve(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::read_WaterValve) ENABLED START -----*/

	*attr_WaterValve_read = dev->getCooling();
	attr.set_value(attr_WaterValve_read);

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::read_WaterValve
}

//--------------------------------------------------------
/**
 *	Method      : DryVacSrv::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void DryVacSrv::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(DryVacSrv::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Start related method
 *	Description: Start the pump with the configure rotation frequency
 *
 */
//--------------------------------------------------------
void DryVacSrv::start()
{
	DEBUG_STREAM << "DryVacSrv::Start()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::start) ENABLED START -----*/

	if(get_state() == Tango::STANDBY) {
		try {
			// First open water valve (if not disabled)
			if(!disableWater) {
				//omni_mutex_lock sync(dev->_wv_lock);  // Not needed anymore because now we use events!
				Tango::DeviceData dout = dev->_wvalve->command_inout("State");
				Tango::DevState wv_state;
				dout >> wv_state;
				if(wv_state == Tango::CLOSE) {
					dev->_wvalve->command_inout("Open");
				} else if(wv_state == Tango::OPEN) {
					// Do nothing...
				} else {
					TangoSys_OMemStream	tms;
					tms << "Failed to start pump. Water valve in bad state: " << wv_state;
					ERROR_STREAM << "DryVacSrv::Start()  " << tms.str() << endl;
					Tango::Except::throw_exception("Failed to start pump", tms.str(), "DryVacSrv::Start()");
				}
			}
			dev->start();
		} catch(DryVacException &e) {
			TangoSys_OMemStream	tms;
			tms << "Failed to start pump. Exception was: " << e.what();
			ERROR_STREAM << "DryVacSrv::Start()  " << tms.str() << endl;
			Tango::Except::throw_exception("Failed to start pump", tms.str(), "DryVacSrv::Start()");
		}
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::start
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stop the pump
 *
 */
//--------------------------------------------------------
void DryVacSrv::stop()
{
	DEBUG_STREAM << "DryVacSrv::Stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::stop) ENABLED START -----*/

	if(get_state() == Tango::RUNNING) {
		try {
			dev->stop();
		} catch(DryVacException &e) {
			TangoSys_OMemStream	tms;
			tms << "Failed to stop pump. Exception was: " << e.what();
			ERROR_STREAM << "DryVacSrv::Stop()  " << tms.str() << endl;
			Tango::Except::throw_exception("Failed to stop pump", tms.str(), "DryVacSrv::Stop()");
		}
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::stop
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: Reset pump fault
 *
 */
//--------------------------------------------------------
void DryVacSrv::reset()
{
	DEBUG_STREAM << "DryVacSrv::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DryVacSrv::reset) ENABLED START -----*/

	if(get_state() == Tango::FAULT) {
		try {
			dev->reset();
		} catch(DryVacException &e) {
			TangoSys_OMemStream	tms;
			tms << "Failed to reset pump. Exception was: " << e.what();
			ERROR_STREAM << "DryVacSrv::Reset()  " << tms.str() << endl;
			Tango::Except::throw_exception("Failed to reset pump", tms.str(), "DryVacSrv::Reset()");
		}
	}

	/*----- PROTECTED REGION END -----*/	//	DryVacSrv::reset
}

/*----- PROTECTED REGION ID(DryVacSrv::namespace_ending) ENABLED START -----*/

//	Additional Methods
DryVacMonitorThread::DryVacMonitorThread(DryVacSrv* parent) :
	_parent(parent),
	_terminate(false),
#ifdef USE_LIBMODBUS
	ctx(NULL),
#else
	_dev(NULL),
#endif
	_freq_setpoint(0.0),
	_frequency(0.0),
	_voltage(0.0),
	_current(0.0),
	_power(0.0),
	_temperature(0),
	_polling(parent->pollingTime),
	_wvalve(NULL),
	_wvalve_state(Tango::UNKNOWN),
	_ballast(NULL),
	_ballast_state(false),
	_purge(NULL),
	_purge_state(false),
	_compair(NULL),
	_compair_state(false),
	_analogin(NULL),
	_id_wvalve_state(-1),
	_id_purge(-1),
	_id_ballast(-1),
	_id_compair(-1),
	_id_pressure(-1)
{
	gettimeofday(&_last_running, NULL);

#ifdef USE_LIBMODBUS
	if(_parent->portConfiguration.length() < 3)
		throw DryVacException("Malformed port configuration string");
	// Create new MODBUS context
	ctx = modbus_new_rtu(_parent->port.c_str(), _parent->portBaudrate, _parent->portConfiguration[1], int(_parent->portConfiguration[0] - '0'), int(_parent->portConfiguration[2] - '0'));
	if(ctx == NULL)
		throw DryVacException("Failed to initialize MODBUS context");

	// Set slave address
	if(modbus_set_slave(ctx, _parent->address) == -1) {
		modbus_free(ctx);
		ctx = NULL;
		throw DryVacException("Failed to set slave address");
	}

	// Connect to port
	if(modbus_connect(ctx) == -1) {
		modbus_free(ctx);
		ctx = NULL;
		throw DryVacException("Failed to connect to port (Error: %s)", modbus_strerror(errno));
	}
#else
	_dev = new Tango::DeviceProxy(_parent->port);

	size_t count = 0;
	while(1) {
		count++;
		try {
			_dev->ping();
			break;
		} catch(Tango::DevFailed &e) {}
	}
#endif

	// Create event callback
	_callback = new EventCallback(this);

	// Create AttributeProxy for purge valve
	try {
		_purge = new Tango::AttributeProxy(_parent->enPurge);
	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize AttributeProxy for purge valve (Error: " << e.errors[0].desc << ")" << endl;
		_purge = NULL;
	}
	if(_purge) {
		try {
			Tango::DeviceProxy *gpio = _purge->get_device_proxy();
			int pin;
			sscanf(_purge->name().c_str(), "b%02d", &pin);
			char buffer[16];
			// Set GPIO to output
			snprintf(buffer, 16, "d%02d", pin);
			Tango::DeviceAttribute attr_in(buffer, false);
			gpio->write_attribute(attr_in);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize purge GPIO pin (Error: " << e.errors[0].desc << ")" << endl;
			delete _purge;
			_purge = NULL;
		}
	}
	// Subscribe change event
	if(_purge) {
		try {
			_id_purge = _purge->subscribe_event(Tango::EventType::CHANGE_EVENT, _callback);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to subscribe to purge GPIO pin change event (Error: " << e.errors[0].desc << ")" << endl;
			delete _purge;
			_purge = NULL;
		}
	}

	// Create AttributeProxy for ballast valve
	try {
		_ballast = new Tango::AttributeProxy(_parent->enBallast);
	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize AttributeProxy for ballast valve (Error: " << e.errors[0].desc << ")" << endl;
		_ballast = NULL;
	}
	if(_ballast) {
		try {
			Tango::DeviceProxy *gpio = _ballast->get_device_proxy();
			int pin;
			sscanf(_ballast->name().c_str(), "b%02d", &pin);
			char buffer[16];
			// Set GPIO to output
			snprintf(buffer, 16, "d%02d", pin);
			Tango::DeviceAttribute attr_in(buffer, false);
			gpio->write_attribute(attr_in);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize ballast GPIO pin (Error: " << e.errors[0].desc << ")" << endl;
			delete _ballast;
			_ballast = NULL;
		}
	}
	// Subscribe change event
	if(_ballast) {
		try {
			_id_ballast = _ballast->subscribe_event(Tango::EventType::CHANGE_EVENT, _callback);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to subscribe to ballast GPIO pin change event (Error: " << e.errors[0].desc << ")" << endl;
			delete _ballast;
			_ballast = NULL;
		}
	}

	// Create AttributeProxy for compressed air sensor
	try {
		_compair = new Tango::AttributeProxy(_parent->compAirDetect);
	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize AttributeProxy for compressed air sensor (Error: " << e.errors[0].desc << ")" << endl;
		_compair = NULL;
	}
	if(_compair) {
		try {
			Tango::DeviceProxy *gpio = _compair->get_device_proxy();
			int pin;
			sscanf(_compair->name().c_str(), "b%02d", &pin);
			char buffer[16];
			// Set GPIO to input
			{
				snprintf(buffer, 16, "d%02d", pin);
				Tango::DeviceAttribute attr_in(buffer, true);
				gpio->write_attribute(attr_in);
			}
			// Set polarity to normal
			{
				snprintf(buffer, 16, "p%02d", pin);
				Tango::DeviceAttribute attr_in(buffer, false);
				gpio->write_attribute(attr_in);
			}
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize compressed air state GPIO pin (Error: " << e.errors[0].desc << ")" << endl;
			delete _compair;
			_compair = NULL;
		}
	}
	// Subscribe change event
	if(_compair) {
		try {
			_id_compair = _compair->subscribe_event(Tango::EventType::CHANGE_EVENT, _callback);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to subscribe to compressed air state GPIO pin change event (Error: " << e.errors[0].desc << ")" << endl;
			delete _compair;
			_compair = NULL;
		}
	}

	// Create DeviceProxy object for water valve
	try {
		_wvalve = new Tango::DeviceProxy(_parent->waterCoolingValve);
	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize DeviceProxy for water cooling valve (Error: " << e.errors[0].desc << ")" << endl;
		_wvalve = NULL;
	}
	// Subscribe valve state change events
	if(_wvalve) {
		try {
			_id_wvalve_state = _wvalve->subscribe_event("State", Tango::EventType::CHANGE_EVENT, _callback);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to subscribe to water cooling valve state change event (Error: " << e.errors[0].desc << ")" << endl;
			delete _wvalve;
			_wvalve = NULL;
		}
	}

	// Create AttributeProxy for pressure value
	_pressure = ::nan("");
	try {
		_analogin = new Tango::AttributeProxy(_parent->analogIN);
	} catch(Tango::DevFailed &e) {
		_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to initialize AttributeProxy for pump pressure (Error: " << e.errors[0].desc << ")" << endl;
		_analogin = NULL;
	}
	// Subscribe change event
	if(_analogin) {
		try {
			_analogin->subscribe_event(Tango::EventType::CHANGE_EVENT, _callback);
		} catch(Tango::DevFailed &e) {
			_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Failed to subscribe to pump pressure change event (Error: " << e.errors[0].desc << ")" << endl;
			delete _analogin;
			_analogin = NULL;
		}
	}

	// Start polling thread
	start_undetached();
}


DryVacMonitorThread::~DryVacMonitorThread() {
#ifdef USE_LIBMODBUS
	if(ctx) {
		// Close MODBUS port
		modbus_close(ctx);
		modbus_free(ctx);
	}
#else
	if(_dev)
		delete _dev;
#endif

	// Delete attribute proxies
	if(_purge) {
		if(_id_purge != -1)
			_purge->unsubscribe_event(_id_purge);
		_id_purge = -1;
		delete _purge;
	}
	if(_ballast) {
		if(_id_ballast != -1)
			_ballast->unsubscribe_event(_id_ballast);
		_id_ballast = -1;
		delete _ballast;
	}
	if(_compair) {
		if(_id_compair != -1)
			_compair->unsubscribe_event(_id_compair);
		_id_compair = -1;
		delete _compair;
	}
	if(_wvalve) {
		if(_id_wvalve_state != -1)
			_wvalve->unsubscribe_event(_id_wvalve_state);
		_id_wvalve_state = -1;
		delete _wvalve;
	}
	if(_analogin) {
		if(_id_pressure != -1)
			_analogin->unsubscribe_event(_id_pressure);
		_id_pressure = -1;
		delete _analogin;
	}
}


void DryVacMonitorThread::msleep(uint32_t msec) {
	if(msec <= 0)
		return;
	struct timespec st;
	struct timeval start, stop;
	gettimeofday(&start, NULL);
	// Setup delay
	st.tv_sec = msec / 1000;
	st.tv_nsec = (msec % 1000) * 1000000;

	while(1) {
		int ans = nanosleep(&st, NULL);
		if(ans == -1 && errno == EINTR) {
			// Nanosleep was interrupted by a signal
			gettimeofday(&stop, NULL);
			int rem = msec - ELAPSED_TIME_MS(start, stop);
			if(rem > 0) {
				st.tv_sec = rem / 1000;
				st.tv_nsec = (rem % 1000) * 1000000;
			} else {
				break;
			}
		} else {
			break;
		}
	}
}


void DryVacMonitorThread::enter() {
	// Send enter command to confirm configuration change
#ifdef USE_LIBMODBUS
	uint16_t reg = 0;
	if(modbus_write_registers(ctx, 0x0910, 1, &reg) == -1) {
		throw DryVacException("Failed to send enter command (Error: %s)", modbus_strerror(errno));
	}
#else
	try {
		Tango::DeviceData din;
		Tango::DevVarShortArray *data = new Tango::DevVarShortArray(3);
		data->length(3);
		(*data)[0] = 0x0910; // Address
		(*data)[1] = 1;      // Num. registers (1)
		(*data)[2] = 0;      // Register value
		din << data;
		_dev->command_inout("PresetMultipleRegisters", din);
	} catch(Tango::DevFailed &e) {
		std::string msg(e.errors[0].desc);
		throw DryVacException("Failed to send enter command (Error: %s)", msg.c_str());
	}
#endif
	// Sleep for 400ms
	msleep(DRYVAC_DELAY_ENTER);
}


void DryVacMonitorThread::start() {
	// Lock MODBUS
	//omni_mutex_lock sync(this->_lock);

#ifdef USE_LIBMODBUS
	uint16_t reg = 0x0001;

	// Write register
	if(modbus_write_registers(ctx, 0x0001, 1, &reg) == -1) {
		throw DryVacException("Failed to write operation register (Error: %s)", modbus_strerror(errno));
	}

#else
	if(!_dev)
		throw DryVacException("Tango device not connected");
	try {
		Tango::DeviceData din;
		Tango::DevVarShortArray *data = new Tango::DevVarShortArray(3);
		data->length(3);
		(*data)[0] = 0x0001; // Address
		(*data)[1] = 1;      // Num. registers (1)
		(*data)[2] = 0x0001; // Register value
		din << data;
		_dev->command_inout("PresetMultipleRegisters", din);
	} catch(Tango::DevFailed &e) {
		std::string msg(e.errors[0].desc);
		throw DryVacException("Failed to write operation register (Error: %s)", msg.c_str());
	}
#endif
	// Sleep for 100ms before sending enter command
	msleep(DRYVAC_DELAY_CMD);

	// Send enter
	this->enter();
}


void DryVacMonitorThread::stop() {
	// Lock MODBUS
	//omni_mutex_lock sync(this->_lock);

#ifdef USE_LIBMODBUS
	uint16_t reg = 0x0008;

	// Write register
	if(modbus_write_registers(ctx, 0x0001, 1, &reg) == -1) {
		throw DryVacException("Failed to write operation register (Error: %s)", modbus_strerror(errno));
	}

#else
	if(!_dev)
		throw DryVacException("Tango device not connected");
	try {
		Tango::DeviceData din;
		Tango::DevVarShortArray *data = new Tango::DevVarShortArray(3);
		data->length(3);
		(*data)[0] = 0x0001; // Address
		(*data)[1] = 1;      // Num. registers (1)
		(*data)[2] = 0x0008; // Register value
		din << data;
		_dev->command_inout("PresetMultipleRegisters", din);
	} catch(Tango::DevFailed &e) {
		std::string msg(e.errors[0].desc);
		throw DryVacException("Failed to write operation register (Error: %s)", msg.c_str());
	}
#endif
	msleep(DRYVAC_DELAY_CMD);

	// Send enter
	this->enter();
}


void DryVacMonitorThread::reset() {
	// Lock MODBUS
	//omni_mutex_lock sync(this->_lock);

#ifdef USE_LIBMODBUS
	uint16_t reg = 0x0008;

	// Write register
	if(modbus_write_registers(ctx, 0x0001, 1, &reg) == -1) {
		throw DryVacException("Failed to write operation register (Error: %s)", modbus_strerror(errno));
	}

#else
	if(!_dev)
		throw DryVacException("Tango device not connected");
	try {
		Tango::DeviceData din;
		Tango::DevVarShortArray *data = new Tango::DevVarShortArray(3);
		data->length(3);
		(*data)[0] = 0x0001; // Address
		(*data)[1] = 1;      // Num. registers (1)
		(*data)[2] = 0x0008; // Register value
		din << data;
		_dev->command_inout("PresetMultipleRegisters", din);
	} catch(Tango::DevFailed &e) {
		std::string msg(e.errors[0].desc);
		throw DryVacException("Failed to write operation register (Error: %s)", msg.c_str());
	}
#endif
	msleep(DRYVAC_DELAY_CMD);

	// Send enter
	this->enter();
}


void DryVacMonitorThread::setFreqSetpoint(float freq) {
	// Convert frequency to integer
	uint16_t raw_freq = uint16_t(freq * 100.0);

	// Lock MODBUS
	//omni_mutex_lock sync(this->_lock);

	// Write register
#ifdef USE_LIBMODBUS
	if(modbus_write_registers(ctx, 0x0002, 1, &raw_freq) == -1) {
		throw DryVacException("Failed to write setpoint register (Error: %s)", modbus_strerror(errno));
	}

#else
	if(!_dev)
		throw DryVacException("Tango device not connected");
	try {
		Tango::DeviceData din;
		Tango::DevVarShortArray *data = new Tango::DevVarShortArray(3);
		data->length(3);
		(*data)[0] = 0x0002;   // Address
		(*data)[1] = 1;        // Num. registers (1)
		(*data)[2] = raw_freq; // Register value
		din << data;
		_dev->command_inout("PresetMultipleRegisters", din);
	} catch(Tango::DevFailed &e) {
		std::string msg(e.errors[0].desc);
		throw DryVacException("Failed to write setpoint register (Error: %s)", msg.c_str());
	}
#endif
	msleep(DRYVAC_DELAY_CMD);

	// Check set point
	uint16_t set_freq = 0;
#ifdef USE_LIBMODBUS
	if(modbus_read_registers(ctx, 0x0002, 1, &set_freq) == -1) {
		throw DryVacException("Failed to check frequency setpoint (Error: %s)", modbus_strerror(errno));
	}
#else
	try {
		Tango::DeviceData din;
		Tango::DevVarShortArray *data = new Tango::DevVarShortArray(2);
		data->length(2);
		(*data)[0] = 0x0002;   // Address
		(*data)[1] = 1;        // Num. registers (1)
		din << data;
		Tango::DeviceData dout = _dev->command_inout("ReadHoldingRegisters", din);
		const Tango::DevVarShortArray* argout;
		if(dout >> argout && argout->length())
			set_freq = (*argout)[0];
		else
			throw DryVacException("Bad response while reading setpoint register");
	} catch(Tango::DevFailed &e) {
		std::string msg(e.errors[0].desc);
		throw DryVacException("Failed to check frequency setpoint (Error: %s)", msg.c_str());
	}

#endif
	msleep(DRYVAC_DELAY_READ);

	if(set_freq != raw_freq) {
		throw DryVacException("Failed to set frequency setpoint");
	}

	// Send enter
	this->enter();

	// Store new frequency setpoint
	_freq_setpoint = freq;
}


// Enable purge
void DryVacMonitorThread::setPurge(bool enable) {
	string attr_name = _purge->name();
	if(enable) {
		// Open purge
		try {
			Tango::DeviceAttribute attr(attr_name, (Tango::DevBoolean)true);
			_purge->write(attr);
		} catch(Tango::DevFailed &e) {
			throw DryVacException("Failed to set purge attribute to true");
		}

	} else {
		// Close purge
		try {
			Tango::DeviceAttribute attr(attr_name, (Tango::DevBoolean)false);
			_purge->write(attr);
		} catch(Tango::DevFailed &e) {
			throw DryVacException("Failed to set purge attribute to false");
		}
	}
}


// Enable ballast
void DryVacMonitorThread::setBallast(bool enable) {
	string attr_name = _ballast->name();
	if(enable) {
		// Open purge
		try {
			Tango::DeviceAttribute attr(attr_name, (Tango::DevBoolean)true);
			_ballast->write(attr);
		} catch(Tango::DevFailed &e) {
			throw DryVacException("Failed to set purge attribute to true");
		}

	} else {
		// Close purge
		try {
			Tango::DeviceAttribute attr(attr_name, (Tango::DevBoolean)false);
			_ballast->write(attr);
		} catch(Tango::DevFailed &e) {
			throw DryVacException("Failed to set purge attribute to false");
		}
	}
}


void *DryVacMonitorThread::run_undetached(void *opt) {

	// Timing structs
	struct timeval b, e;

	// Register buffer
	uint16_t buffer[128];
#ifdef USE_LIBMODBUS
	uint16_t buffer2[128];
#endif

	if(_parent->get_logger()->is_debug_enabled())
		_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "DryVacMonitorThread::run_undetached(): monitor thread started!" << endl;

	while(!_terminate) {
		// Poll cycle start time
		gettimeofday(&b, NULL);
		bool err = false;
		bool water_alarm = false;

		// Check water valve status
		if(_wvalve) {
			try {
				if(_wvalve_state.load() == Tango::CLOSE) {
					if(_parent->get_state() == Tango::RUNNING) {
						// Water valve should be open
						if(!_parent->disableWater) {
							// Force valve open!
							//omni_mutex_lock sync(this->_wv_lock);
							_wvalve->command_inout("Open");
						} else {
							water_alarm = true;
						}
					}

				} else if(_wvalve_state.load() == Tango::OPEN) {
					if(_parent->get_state() == Tango::STANDBY && _temperature.load() < _parent->waterCloseTemperature) {
						// Automatically close valve
						//omni_mutex_lock sync(this->_wv_lock);
						_wvalve->command_inout("Close");
					}

				} else {
					// Valve in fault state
					water_alarm = true;
				}
			} catch(Tango::DevFailed &e) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error checking water valve. Error was: " << e.errors[0].desc << endl;
				water_alarm = true;
			}
		}

		{   // Lock MODBUS
			//omni_mutex_lock sync(this->_lock);

			// Fetch status registers
			memset(buffer, 0, sizeof(uint16_t)*128);
#ifdef USE_LIBMODBUS
			int rc = modbus_read_registers(ctx, 0x20, 13, buffer);
			if(rc == -1) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error reading MODBUS registers (Error was: " << modbus_strerror(errno) << ")" << endl;
				err = true;
			} else if(rc != 13) {
				err = true;
			}
#else
			try {
				Tango::DeviceData din;
				Tango::DevVarShortArray *data = new Tango::DevVarShortArray(3);
				data->length(2);
				(*data)[0] = 0x0020;  // Address
				(*data)[1] = 13;      // Num. registers (13)
				din << data;
				Tango::DeviceData dout = _dev->command_inout("ReadHoldingRegisters", din);
				const Tango::DevVarShortArray *argout;
				if(dout >> argout) {
					if(argout->length() == 13) {
						memcpy(buffer, argout->get_buffer(), argout->length()*sizeof(Tango::DevShort));
					} else {
						_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error reading regiseters. Got " << argout->length() << " instead of 13" << endl;
						err = true;
					}
				} else {
					_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Bad response while reading registers" << endl;
					err = true;
				}
			} catch(Tango::DevFailed &e) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error reading MODBUS registers. Error was: " << e.errors[0].desc << endl;
				err = true;
			}
#endif

			// Sleep
			msleep(DRYVAC_DELAY_READ);

			// Fetch temperature
#ifdef USE_LIBMODBUS
			memset(buffer2, 0, sizeof(uint16_t)*128);
			rc = modbus_read_registers(ctx, 0x68, 1, buffer2);

			if(rc == 1) {
				update_value("Temperature", buffer2[0], _temperature);
			}
#else
			try {
				Tango::DeviceData din;
				Tango::DevVarShortArray *data = new Tango::DevVarShortArray(2);
				data->length(2);
				(*data)[0] = 0x0068; // Address
				(*data)[1] = 1;      // Num. registers (1)
				din << data;
				Tango::DeviceData dout = _dev->command_inout("ReadHoldingRegisters", din);
				const Tango::DevVarShortArray *argout;
				dout >> argout;
				if(argout->length() == 1)
					update_value("Temperature", (*argout)[0], _temperature);
				else
					err = true;
			} catch(Tango::DevFailed &e) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error reading temperature register. Error was: " << e.errors[0].desc << endl;
			}
#endif

			if(!err) {
				if(buffer[0] & 0x0008) {
					// Fault
					_parent->set_state(Tango::FAULT);

					TangoSys_OMemStream msg;
					msg << "Faults: ";
					if(buffer[1] & 0x0001) {
						msg << "overcurrent (oC) / ground fault (GF/SC), ";
					}
					if(buffer[1] & 0x0002) {
						msg << "overvoltage (ov), ";
					}
					if(buffer[1] & 0x0004) {
						msg << "drive overload (oL2), ";
					}
					if(buffer[1] & 0x0008) {
						msg << "overheat (oH1/oH2), ";
					}
					if(buffer[1] & 0x0010) {
						msg << "braking fault (rr/rH), ";
					}
					if(buffer[1] & 0x0040) {
						msg << "PID feedback loss (FbL/FbH), ";
					}
					if(buffer[1] & 0x0080) {
						msg << "external fault (EF0 to 7), ";
					}
					if(buffer[1] & 0x0100) {
						msg << "hardware fault (CPFoo/oFAoo), ";
					}
					if(buffer[1] & 0x0200) {
						msg << "motor overload (oL1) / overtorque (oL3/oL4) / undertorque (UL3/UL4), ";
					}
					if(buffer[1] & 0x0400) {
						msg << "PG disconnected (PGo) / overspeed (oS) / speed deviation (dEv), ";
					}
					if(buffer[1] & 0x0800) {
						msg << "main circuit undervoltage (Uv), ";
					}
					if(buffer[1] & 0x1000) {
						msg << "undervoltage (Uv1) / control undervoltage (Uv2) / soft charge circuit fault (Uv3), ";
					}
					if(buffer[1] & 0x2000) {
						msg << "output phase loss (LF) / input phase loss (PF), ";
					}
					if(buffer[1] & 0x4000) {
						msg << "communication error (CE/bUS), ";
					}
					if(buffer[1] & 0x8000) {
						msg << "operator connection fault (oPr), ";
					}
					_parent->set_status(msg.str().substr(0, msg.str().length()));
				} else if(_temperature.load() > 65) {
					_parent->set_state(Tango::ALARM);
					_parent->set_status("Pump overheating");
				} else if(water_alarm) {
					_parent->set_state(Tango::ALARM);
					_parent->set_status("Water valve closed or failed while the pump is running");
				} else {
					if(buffer[0] & 0x0001) {
						// Running
						_parent->set_state(Tango::RUNNING);
						_parent->set_status("Pump running");
						gettimeofday(&_last_running, NULL);
					} else {
						// Stopped
						_parent->set_state(Tango::STANDBY);
						_parent->set_status("Pump stopped");
					}
				}

				update_value("FreqSetpoint", float(buffer[3]) / 100.0, _freq_setpoint);
				update_value("Frequency", float(buffer[4]) / 100.0, _frequency);
				update_value("Voltage", float(buffer[5]) / 10.0, _voltage);
				update_value("Current", float(buffer[6]) / 10.0, _current);
				update_value("Power", float(buffer[7]) / 10.0, _power);

			} else {
				// Error!
				_parent->set_state(Tango::FAULT);
				_parent->set_status("Error reading MODBUS registers");
			}
		}

		// Check purge valve status
		if(_purge) {
			try {
				if(_purge_state.load() && _parent->get_state() == Tango::STANDBY) {
					// Automatically close purge valve when the pump stops
					setPurge(false);
				}
			} catch(Tango::DevFailed &e) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error checking purge valve. Error was: " << e.errors[0].desc << endl;
			}
		}

		// Check ballast valve status
		if(_ballast) {
			try {
				if(_ballast_state && _parent->get_state() == Tango::STANDBY) {
					// Automatically close ballast valve when the pump stops
					setBallast(false);
				}
			} catch(Tango::DevFailed &e) {
				_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Error checking ballast valve. Error was: " << e.errors[0].desc << endl;
			}
		}

		// TODO: if compressed air is missing, close purge and ballast to prevent pump contamination?

		// Polling cycle end time
		gettimeofday(&e, NULL);
		int elapsed = ELAPSED_TIME_MS(b, e);

		// Sleep...
		if(_polling - elapsed > 0)
			msleep(_polling - elapsed);
	}

	int *retval = new int();
	*retval = 0;
	return (void*)retval;
}


// Update float value
void DryVacMonitorThread::update_value(const char *attr, float value, std::atomic<float>& store) {
	if(value != store.load()) {
		Tango::DevFloat *ptr = new Tango::DevFloat(value);
		_parent->push_change_event(attr, ptr, 1, 0, true);
	}
	store = value;
}


// Update short value
void DryVacMonitorThread::update_value(const char *attr, short value, std::atomic<short>& store) {
	if(value != store.load()) {
		Tango::DevShort *ptr = new Tango::DevShort(value);
		_parent->push_change_event(attr, ptr, 1, 0, true);
	}
	store = value;
}


// Event callback
void EventCallback::push_event(Tango::EventData* event) {
	
	try {

		if(!event->err) {

			// Check if the event is empty
			if(event->attr_value->is_empty()) {
				if(_parent->_parent->get_logger()->is_debug_enabled()) {
					_parent->_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got an empty event from: " << event->attr_name << endl;
				}
				// Do nothing...
				return;
			}

			// Extract normalized Tango attribute name
			size_t pos = event->attr_name.find_last_of('/');
			string attr_name;
			if(pos != string::npos)
				attr_name = event->attr_name.substr(pos+1);
			else
				attr_name = event->attr_name;

			// Debug message to log events...
			if(_parent->_parent->get_logger()->is_debug_enabled()) {
				_parent->_parent->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log << "Got event from: " << event->attr_name << " (" << attr_name << "), Type: " << event->event << endl;
			}

			// Check event source
			if(_parent->_purge && attr_name == _parent->_purge->name()) {
				// Purge
				Tango::DevBoolean val;
				if(!(*(event->attr_value) >> val)) {
					_parent->_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to parse purge attribute value" << endl;
				} else {
					if(_parent->_purge_state.load() != (bool)val) {
						Tango::DevBoolean *ptr = new Tango::DevBoolean(val);
						_parent->_parent->push_change_event("EnablePurge", ptr, 1, 0, true);
					}
					_parent->_purge_state = (bool)val;
				}
			}
			else if(_parent->_ballast && attr_name == _parent->_ballast->name()) {
				// Ballast
				Tango::DevBoolean val;
				if(!(*(event->attr_value) >> val)) {
					_parent->_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to parse ballast attribute value" << endl;
				} else {
					if(_parent->_ballast_state.load() != (bool)val) {
						Tango::DevBoolean *ptr = new Tango::DevBoolean(val);
						_parent->_parent->push_change_event("EnableBallast", ptr, 1, 0, true);
					}
					_parent->_ballast_state = (bool)val;
				}
			}
			else if(_parent->_compair && attr_name == _parent->_compair->name()) {
				// Compressed air state
				Tango::DevBoolean val;
				if(!(*(event->attr_value) >> val)) {
					_parent->_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to parse compressed air status attribute value" << endl;
				} else {
					if(_parent->_compair_state.load() != (bool)val) {
						Tango::DevBoolean *ptr = new Tango::DevBoolean(val);
						_parent->_parent->push_change_event("CompressedAir", ptr, 1, 0, true);
					}
					_parent->_compair_state = (bool)val;
				}
			}
			else if(_parent->_wvalve && event->device->name() == _parent->_wvalve->name() && attr_name == "state") {
				// Water valve state
				Tango::DevState val;
				if(!(*(event->attr_value) >> val)) {
					_parent->_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to parse water valve state attribute value" << endl;
				} else {
					if(_parent->_wvalve_state.load() != val) {
						Tango::DevState *ptr = new Tango::DevState(val);
						_parent->_parent->push_change_event("WaterValve", ptr, 1, 0, true);
					}
					_parent->_wvalve_state = val;
				}
			}
			else if(_parent->_analogin && attr_name == _parent->_analogin->name()) {
				// Analog value
				Tango::DevDouble val;
				if(!(*(event->attr_value) >> val)) {
					_parent->_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Failed to parse pressure value" << endl;
				} else {
					_parent->_pressure = ::pow(10.0, 2.0 * val - 5.5);  // Conversion to mbar
					Tango::DevDouble *ptr = new Tango::DevDouble(_parent->_pressure.load());
					_parent->_parent->push_change_event("Pressure", ptr, 1, 0, true);
				}
			}
			else {
				// Unexpected event
				_parent->_parent->get_logger()->warn_stream() << log4tango::LogInitiator::_begin_log << "Unexpected event from attribute: " << event->attr_name << " (" << attr_name << "), type: " << event->event << endl;
			}

		} else {
			_parent->_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Found errors in event data. Errors:" << endl;
			for(size_t i = 0; i < event->errors.length(); i++)
				_parent->_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "[" << (i+1) << "] " << event->errors[i].desc << " (from: " << event->errors[i].origin << ")" << endl;
		}
	} catch(Tango::DevFailed &e) {
		_parent->_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "Caught exception while handling event from " << event->attr_name << endl;
		for(size_t i = 0; i < e.errors.length(); i++)
			_parent->_parent->get_logger()->error_stream() << log4tango::LogInitiator::_begin_log << "[" << (i+1) << "] " << e.errors[i].desc << " (from: " << e.errors[i].origin << ")" << endl;
	}
}

/*----- PROTECTED REGION END -----*/	//	DryVacSrv::namespace_ending
} //	namespace
